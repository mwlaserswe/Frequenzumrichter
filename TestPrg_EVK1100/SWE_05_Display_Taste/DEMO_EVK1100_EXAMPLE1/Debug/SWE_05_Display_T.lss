
SWE_05_Display_T.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002334  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80004400  80004400  00004800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80004600  80004600  00004a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000190  80004618  80004618  00004a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  800047a8  00004c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  800047b0  00004c10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  800047b8  00004c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  800047bc  00004c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000510  0000001c  800047bc  00004c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00000254  00000544  00000544  00000000  2**2
                  ALLOC
 14 .heap         0000e868  00000798  00000798  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  0000512c  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 000009f8  00000000  00000000  00005160  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00001540  00000000  00000000  00005b58  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   000112d0  00000000  00000000  00007098  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 00002dba  00000000  00000000  00018368  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   0000a01a  00000000  00000000  0001b122  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  0000170c  00000000  00000000  0002513c  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00003657  00000000  00000000  00026848  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    0000372b  00000000  00000000  00029e9f  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 00b7fc57  00000000  00000000  0002d5ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00000b10  00000000  00000000  00bad221  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 11 95 	rcall	80004348 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb d8 8c 	sub	r11,pc,-10100
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 30 	mov	r10,1328
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 98 	mov	r10,1944
8000204e:	e0 6c 05 30 	mov	r12,1328
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 06 74 	rcall	80002d44 <_init_startup>
80002060:	fe cc da 60 	sub	r12,pc,-9632
80002064:	e0 a0 0c 8a 	rcall	80003978 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 0f 7b 	rcall	80003f64 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 0b 11 	rcall	800036a0 <main>
80002082:	e0 a0 0c 83 	rcall	80003988 <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 44 	mov	r8,1348
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 48 	mov	r7,1352
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 44 	mov	r8,1348
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
800020dc:	d4 01       	pushm	lr
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
800020de:	30 2b       	mov	r11,2
800020e0:	fe 7c 28 00 	mov	r12,-55296
800020e4:	f0 1f 00 02 	mcall	800020ec <dip204_select+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	2b 60       	sub	r0,-74

800020f0 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
  unsigned char reverse;

  switch (byte)
800020f4:	f8 c8 ff f8 	sub	r8,r12,-8
800020f8:	30 69       	mov	r9,6
800020fa:	f2 08 18 00 	cp.b	r8,r9
800020fe:	e0 8b 00 0f 	brhi	8000211c <dip204_write_byte+0x2c>
80002102:	30 19       	mov	r9,1
80002104:	f2 08 09 48 	lsl	r8,r9,r8
80002108:	e2 18 00 55 	andl	r8,0x55,COH
8000210c:	c0 80       	breq	8000211c <dip204_write_byte+0x2c>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
8000210e:	18 9b       	mov	r11,r12
80002110:	fe 7c 28 00 	mov	r12,-55296
80002114:	f0 1f 00 0c 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      break;
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
8000211c:	5c 9c       	brev	r12
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
8000211e:	f8 07 16 18 	lsr	r7,r12,0x18
80002122:	0e 9b       	mov	r11,r7
80002124:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002128:	fe 7c 28 00 	mov	r12,-55296
8000212c:	f0 1f 00 06 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002130:	ee 0b 15 04 	lsl	r11,r7,0x4
80002134:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002138:	fe 7c 28 00 	mov	r12,-55296
8000213c:	f0 1f 00 02 	mcall	80002144 <dip204_write_byte+0x54>
80002140:	e3 cd 80 80 	ldm	sp++,r7,pc
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	29 fc       	sub	r12,-97

80002148 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80002148:	eb cd 40 c0 	pushm	r6-r7,lr
8000214c:	20 1d       	sub	sp,4
8000214e:	18 96       	mov	r6,r12
  unsigned short reverse = 0x00;
80002150:	fa c7 ff fc 	sub	r7,sp,-4
80002154:	30 08       	mov	r8,0
80002156:	0e e8       	st.h	--r7,r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
80002158:	30 0b       	mov	r11,0
8000215a:	fe 7c 28 00 	mov	r12,-55296
8000215e:	f0 1f 00 08 	mcall	8000217c <dip204_read_byte+0x34>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80002162:	0e 9b       	mov	r11,r7
80002164:	fe 7c 28 00 	mov	r12,-55296
80002168:	f0 1f 00 06 	mcall	80002180 <dip204_read_byte+0x38>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
8000216c:	1b b8       	ld.ub	r8,sp[0x3]
8000216e:	5c 98       	brev	r8
80002170:	b9 88       	lsr	r8,0x18
80002172:	ac 88       	st.b	r6[0x0],r8
}
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	29 fc       	sub	r12,-97
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	2a 18       	sub	r8,-95

80002184 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80002184:	eb cd 40 c0 	pushm	r6-r7,lr
80002188:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000218a:	fa c7 ff fc 	sub	r7,sp,-4
8000218e:	30 08       	mov	r8,0
80002190:	0e f8       	st.b	--r7,r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80002192:	e0 6c 00 fc 	mov	r12,252
80002196:	f0 1f 00 07 	mcall	800021b0 <dip204_wait_busy+0x2c>
  /* read next byte */
  do {
  dip204_read_byte(&status);
  /* keep D7 to know status */
  }while (status & 0x80);
8000219a:	30 06       	mov	r6,0

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000219c:	0e 9c       	mov	r12,r7
8000219e:	f0 1f 00 06 	mcall	800021b4 <dip204_wait_busy+0x30>
  /* keep D7 to know status */
  }while (status & 0x80);
800021a2:	1b b8       	ld.ub	r8,sp[0x3]
800021a4:	ec 08 18 00 	cp.b	r8,r6
800021a8:	cf a5       	brlt	8000219c <dip204_wait_busy+0x18>
}
800021aa:	2f fd       	sub	sp,-4
800021ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	20 f0       	sub	r0,15
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	21 48       	sub	r8,20

800021b8 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
800021b8:	d4 01       	pushm	lr
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
800021ba:	30 2b       	mov	r11,2
800021bc:	fe 7c 28 00 	mov	r12,-55296
800021c0:	f0 1f 00 02 	mcall	800021c8 <dip204_unselect+0x10>
  Assert( SPI_OK==spi_status );
}
800021c4:	d8 02       	popm	pc
800021c6:	00 00       	add	r0,r0
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	2b 20       	sub	r0,-78

800021cc <dip204_write_string>:
  dip204_unselect();
}


void dip204_write_string(const char *string)
{
800021cc:	eb cd 40 f8 	pushm	r3-r7,lr
800021d0:	18 94       	mov	r4,r12
  unsigned char i=0;

  dip204_select();
800021d2:	f0 1f 00 11 	mcall	80002214 <dip204_write_string+0x48>
  /* for all chars in string */
  while(string[i]!=0)
800021d6:	09 89       	ld.ub	r9,r4[0x0]
800021d8:	30 08       	mov	r8,0
800021da:	f0 09 18 00 	cp.b	r9,r8
800021de:	c1 60       	breq	8000220a <dip204_write_string+0x3e>
800021e0:	08 96       	mov	r6,r4
800021e2:	30 07       	mov	r7,0
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021e4:	e0 63 00 fa 	mov	r3,250
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021e8:	10 95       	mov	r5,r8
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 0b 	mcall	80002218 <dip204_write_string+0x4c>
    /* Send byte */
    dip204_write_byte(string[i]);
800021f0:	0d 8c       	ld.ub	r12,r6[0x0]
800021f2:	f0 1f 00 0a 	mcall	80002218 <dip204_write_string+0x4c>
    /* go to next char */
    i++;
800021f6:	2f f7       	sub	r7,-1
800021f8:	5c 57       	castu.b	r7
    dip204_wait_busy();
800021fa:	f0 1f 00 09 	mcall	8000221c <dip204_write_string+0x50>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021fe:	e8 07 00 06 	add	r6,r4,r7
80002202:	0d 88       	ld.ub	r8,r6[0x0]
80002204:	ea 08 18 00 	cp.b	r8,r5
80002208:	cf 11       	brne	800021ea <dip204_write_string+0x1e>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
8000220a:	f0 1f 00 06 	mcall	80002220 <dip204_write_string+0x54>
}
8000220e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002212:	00 00       	add	r0,r0
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	20 dc       	sub	r12,13
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	20 f0       	sub	r0,15
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	21 84       	sub	r4,24
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	21 b8       	sub	r8,27

80002224 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002224:	eb cd 40 c0 	pushm	r6-r7,lr
80002228:	18 96       	mov	r6,r12
8000222a:	16 97       	mov	r7,r11
  unsigned char address = 0;

  dip204_select();
8000222c:	f0 1f 00 11 	mcall	80002270 <dip204_set_cursor_position+0x4c>
  if ((column <= 20) && (line <= 4))
80002230:	31 48       	mov	r8,20
80002232:	f0 06 18 00 	cp.b	r6,r8
80002236:	5f 89       	srls	r9
80002238:	30 48       	mov	r8,4
8000223a:	f0 07 18 00 	cp.b	r7,r8
8000223e:	5f 88       	srls	r8
80002240:	f3 e8 00 08 	and	r8,r9,r8
80002244:	c0 31       	brne	8000224a <dip204_set_cursor_position+0x26>
80002246:	30 06       	mov	r6,0
80002248:	c0 68       	rjmp	80002254 <dip204_set_cursor_position+0x30>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
8000224a:	28 16       	sub	r6,-127
8000224c:	20 17       	sub	r7,1
8000224e:	a5 77       	lsl	r7,0x5
80002250:	0e 06       	add	r6,r7
80002252:	5c 56       	castu.b	r6
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002254:	e0 6c 00 f8 	mov	r12,248
80002258:	f0 1f 00 07 	mcall	80002274 <dip204_set_cursor_position+0x50>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
8000225c:	0c 9c       	mov	r12,r6
8000225e:	f0 1f 00 06 	mcall	80002274 <dip204_set_cursor_position+0x50>
  dip204_wait_busy();
80002262:	f0 1f 00 06 	mcall	80002278 <dip204_set_cursor_position+0x54>
  dip204_unselect();
80002266:	f0 1f 00 06 	mcall	8000227c <dip204_set_cursor_position+0x58>
}
8000226a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000226e:	00 00       	add	r0,r0
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	20 dc       	sub	r12,13
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	20 f0       	sub	r0,15
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	21 84       	sub	r4,24
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	21 b8       	sub	r8,27

80002280 <dip204_write_data>:
  dip204_unselect();
}


void dip204_write_data(unsigned char data)
{
80002280:	eb cd 40 80 	pushm	r7,lr
80002284:	18 97       	mov	r7,r12
  dip204_select();
80002286:	f0 1f 00 08 	mcall	800022a4 <dip204_write_data+0x24>
  /* Send Write Data Start-Byte */
  dip204_write_byte(DIP204_WRITE_DATA);
8000228a:	e0 6c 00 fa 	mov	r12,250
8000228e:	f0 1f 00 07 	mcall	800022a8 <dip204_write_data+0x28>
  /* send data */
  dip204_write_byte(data);
80002292:	0e 9c       	mov	r12,r7
80002294:	f0 1f 00 05 	mcall	800022a8 <dip204_write_data+0x28>
  dip204_wait_busy();
80002298:	f0 1f 00 05 	mcall	800022ac <dip204_write_data+0x2c>
  dip204_unselect();
8000229c:	f0 1f 00 05 	mcall	800022b0 <dip204_write_data+0x30>
}
800022a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	20 dc       	sub	r12,13
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	20 f0       	sub	r0,15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	21 84       	sub	r4,24
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	21 b8       	sub	r8,27

800022b4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
800022b4:	d4 01       	pushm	lr
  /* select the LCD chip */
  dip204_select();
800022b6:	f0 1f 00 08 	mcall	800022d4 <dip204_hide_cursor+0x20>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
800022ba:	e0 6c 00 f8 	mov	r12,248
800022be:	f0 1f 00 07 	mcall	800022d8 <dip204_hide_cursor+0x24>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
800022c2:	30 cc       	mov	r12,12
800022c4:	f0 1f 00 05 	mcall	800022d8 <dip204_hide_cursor+0x24>
  dip204_wait_busy();
800022c8:	f0 1f 00 05 	mcall	800022dc <dip204_hide_cursor+0x28>
  /* unselect chip */
  dip204_unselect();
800022cc:	f0 1f 00 05 	mcall	800022e0 <dip204_hide_cursor+0x2c>
}
800022d0:	d8 02       	popm	pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	20 dc       	sub	r12,13
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	20 f0       	sub	r0,15
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	21 84       	sub	r4,24
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	21 b8       	sub	r8,27

800022e4 <dip204_set_backlight>:
  dip204_unselect();
}


void dip204_set_backlight(backlight_power power)
{
800022e4:	d4 01       	pushm	lr
  if (channel_id != -1)
800022e6:	49 d8       	lddpc	r8,80002358 <dip204_set_backlight+0x74>
800022e8:	70 08       	ld.w	r8,r8[0x0]
800022ea:	5b f8       	cp.w	r8,-1
800022ec:	c2 a0       	breq	80002340 <dip204_set_backlight+0x5c>
  {
    if (power == backlight_power_decrease)
800022ee:	58 1c       	cp.w	r12,1
800022f0:	c1 41       	brne	80002318 <dip204_set_backlight+0x34>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Max(pwm_duty - (DIP204_PERIOD_MAX / 10), 1);
800022f2:	49 ba       	lddpc	r10,8000235c <dip204_set_backlight+0x78>
800022f4:	94 89       	ld.uh	r9,r10[0x0]
800022f6:	20 59       	sub	r9,5
800022f8:	30 1b       	mov	r11,1
800022fa:	f2 0b 0c 49 	max	r9,r9,r11
800022fe:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
80002300:	49 8b       	lddpc	r11,80002360 <dip204_set_backlight+0x7c>
80002302:	76 0a       	ld.w	r10,r11[0x0]
80002304:	30 0c       	mov	r12,0
80002306:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
8000230a:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
8000230c:	5c 79       	castu.h	r9
8000230e:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
80002310:	10 9c       	mov	r12,r8
80002312:	f0 1f 00 15 	mcall	80002364 <dip204_set_backlight+0x80>
80002316:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
80002318:	58 0c       	cp.w	r12,0
8000231a:	c1 e1       	brne	80002356 <dip204_set_backlight+0x72>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Min(pwm_duty + (DIP204_PERIOD_MAX / 10), DIP204_PERIOD_MAX - 1);
8000231c:	49 0a       	lddpc	r10,8000235c <dip204_set_backlight+0x78>
8000231e:	94 89       	ld.uh	r9,r10[0x0]
80002320:	2f b9       	sub	r9,-5
80002322:	33 1b       	mov	r11,49
80002324:	f2 0b 0d 49 	min	r9,r9,r11
80002328:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
8000232a:	48 eb       	lddpc	r11,80002360 <dip204_set_backlight+0x7c>
8000232c:	76 0a       	ld.w	r10,r11[0x0]
8000232e:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
80002332:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
80002334:	5c 79       	castu.h	r9
80002336:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
80002338:	10 9c       	mov	r12,r8
8000233a:	f0 1f 00 0b 	mcall	80002364 <dip204_set_backlight+0x80>
8000233e:	d8 02       	popm	pc
    }
  }
  else
  {
    if (power == backlight_power_decrease)
80002340:	58 1c       	cp.w	r12,1
80002342:	c0 51       	brne	8000234c <dip204_set_backlight+0x68>
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
80002344:	33 2c       	mov	r12,50
80002346:	f0 1f 00 09 	mcall	80002368 <dip204_set_backlight+0x84>
8000234a:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
8000234c:	58 0c       	cp.w	r12,0
8000234e:	c0 41       	brne	80002356 <dip204_set_backlight+0x72>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
80002350:	33 2c       	mov	r12,50
80002352:	f0 1f 00 07 	mcall	8000236c <dip204_set_backlight+0x88>
80002356:	d8 02       	popm	pc
80002358:	00 00       	add	r0,r0
8000235a:	00 1c       	sub	r12,r0
8000235c:	00 00       	add	r0,r0
8000235e:	05 6c       	ld.uh	r12,--r2
80002360:	00 00       	add	r0,r0
80002362:	05 4c       	ld.w	r12,--r2
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	28 f4       	sub	r4,-113
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	26 38       	sub	r8,99
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	26 54       	sub	r4,101

80002370 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	20 4d       	sub	sp,16
80002376:	16 97       	mov	r7,r11
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
80002378:	58 1c       	cp.w	r12,1
8000237a:	c3 11       	brne	800023dc <dip204_init+0x6c>
  {
    channel_id = DIP204_PWM_CHANNEL;
8000237c:	30 69       	mov	r9,6
8000237e:	fe f8 02 02 	ld.w	r8,pc[514]
80002382:	91 09       	st.w	r8[0x0],r9
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
80002384:	30 2b       	mov	r11,2
80002386:	33 2c       	mov	r12,50
80002388:	f0 1f 00 7f 	mcall	80002584 <dip204_init+0x214>

    // PWM controller configuration
    pwm_opt.diva=0;
8000238c:	30 08       	mov	r8,0
8000238e:	50 18       	stdsp	sp[0x4],r8
    pwm_opt.divb=0;
80002390:	50 08       	stdsp	sp[0x0],r8
    pwm_opt.prea=0;
80002392:	50 38       	stdsp	sp[0xc],r8
    pwm_opt.preb=0;
80002394:	50 28       	stdsp	sp[0x8],r8

    pwm_init(&pwm_opt);
80002396:	1a 9c       	mov	r12,sp
80002398:	f0 1f 00 7c 	mcall	80002588 <dip204_init+0x218>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
8000239c:	58 07       	cp.w	r7,0
8000239e:	f9 b7 01 31 	movne	r7,49
800023a2:	f9 b7 00 01 	moveq	r7,1
800023a6:	4f a8       	lddpc	r8,8000258c <dip204_init+0x21c>
800023a8:	b0 07       	st.h	r8[0x0],r7
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
800023aa:	4f ab       	lddpc	r11,80002590 <dip204_init+0x220>
800023ac:	76 08       	ld.w	r8,r11[0x0]
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
800023ae:	e0 18 fc ff 	andl	r8,0xfcff
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
800023b2:	ab a8       	sbr	r8,0xa
800023b4:	30 89       	mov	r9,8
800023b6:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800023ba:	97 08       	st.w	r11[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800023bc:	97 17       	st.w	r11[0x4],r7
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800023be:	33 28       	mov	r8,50
800023c0:	97 28       	st.w	r11[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800023c2:	30 08       	mov	r8,0
800023c4:	97 48       	st.w	r11[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800023c6:	4e f7       	lddpc	r7,80002580 <dip204_init+0x210>
800023c8:	6e 0c       	ld.w	r12,r7[0x0]
800023ca:	f0 1f 00 73 	mcall	80002594 <dip204_init+0x224>
    // start PWM
    pwm_start_channels(1 << channel_id);
800023ce:	6e 08       	ld.w	r8,r7[0x0]
800023d0:	30 1c       	mov	r12,1
800023d2:	f8 08 09 4c 	lsl	r12,r12,r8
800023d6:	f0 1f 00 71 	mcall	80002598 <dip204_init+0x228>
800023da:	c0 a8       	rjmp	800023ee <dip204_init+0x7e>
  }
  else
  {
    if (backlight_on)
800023dc:	58 0b       	cp.w	r11,0
800023de:	c0 50       	breq	800023e8 <dip204_init+0x78>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800023e0:	33 2c       	mov	r12,50
800023e2:	f0 1f 00 6f 	mcall	8000259c <dip204_init+0x22c>
800023e6:	c0 48       	rjmp	800023ee <dip204_init+0x7e>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800023e8:	33 2c       	mov	r12,50
800023ea:	f0 1f 00 6e 	mcall	800025a0 <dip204_init+0x230>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023f2:	e0 6a 4f 80 	mov	r10,20352
800023f6:	ea 1a 00 12 	orh	r10,0x12
800023fa:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800023fe:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002402:	14 38       	cp.w	r8,r10
80002404:	e0 88 00 08 	brls	80002414 <dip204_init+0xa4>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002408:	12 38       	cp.w	r8,r9
8000240a:	fe 98 ff fa 	brls	800023fe <dip204_init+0x8e>
8000240e:	12 3a       	cp.w	r10,r9
80002410:	c6 e3       	brcs	800024ec <dip204_init+0x17c>
80002412:	cf 6b       	rjmp	800023fe <dip204_init+0x8e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002414:	12 38       	cp.w	r8,r9
80002416:	e0 8b 00 6b 	brhi	800024ec <dip204_init+0x17c>
8000241a:	12 3a       	cp.w	r10,r9
8000241c:	c6 83       	brcs	800024ec <dip204_init+0x17c>
8000241e:	cf 0b       	rjmp	800023fe <dip204_init+0x8e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002420:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002424:	14 38       	cp.w	r8,r10
80002426:	e0 88 00 08 	brls	80002436 <dip204_init+0xc6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000242a:	12 38       	cp.w	r8,r9
8000242c:	fe 98 ff fa 	brls	80002420 <dip204_init+0xb0>
80002430:	12 3a       	cp.w	r10,r9
80002432:	c6 d3       	brcs	8000250c <dip204_init+0x19c>
80002434:	cf 6b       	rjmp	80002420 <dip204_init+0xb0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002436:	12 38       	cp.w	r8,r9
80002438:	e0 8b 00 6a 	brhi	8000250c <dip204_init+0x19c>
8000243c:	12 3a       	cp.w	r10,r9
8000243e:	c6 73       	brcs	8000250c <dip204_init+0x19c>
80002440:	cf 0b       	rjmp	80002420 <dip204_init+0xb0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002442:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002446:	14 38       	cp.w	r8,r10
80002448:	e0 88 00 08 	brls	80002458 <dip204_init+0xe8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000244c:	12 38       	cp.w	r8,r9
8000244e:	fe 98 ff fa 	brls	80002442 <dip204_init+0xd2>
80002452:	12 3a       	cp.w	r10,r9
80002454:	c6 63       	brcs	80002520 <dip204_init+0x1b0>
80002456:	cf 6b       	rjmp	80002442 <dip204_init+0xd2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002458:	12 38       	cp.w	r8,r9
8000245a:	e0 8b 00 63 	brhi	80002520 <dip204_init+0x1b0>
8000245e:	12 3a       	cp.w	r10,r9
80002460:	c6 03       	brcs	80002520 <dip204_init+0x1b0>
80002462:	cf 0b       	rjmp	80002442 <dip204_init+0xd2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002464:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002468:	14 38       	cp.w	r8,r10
8000246a:	e0 88 00 08 	brls	8000247a <dip204_init+0x10a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000246e:	12 38       	cp.w	r8,r9
80002470:	fe 98 ff fa 	brls	80002464 <dip204_init+0xf4>
80002474:	12 3a       	cp.w	r10,r9
80002476:	c5 f3       	brcs	80002534 <dip204_init+0x1c4>
80002478:	cf 6b       	rjmp	80002464 <dip204_init+0xf4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000247a:	12 38       	cp.w	r8,r9
8000247c:	e0 8b 00 5c 	brhi	80002534 <dip204_init+0x1c4>
80002480:	12 3a       	cp.w	r10,r9
80002482:	c5 93       	brcs	80002534 <dip204_init+0x1c4>
80002484:	cf 0b       	rjmp	80002464 <dip204_init+0xf4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002486:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000248a:	14 38       	cp.w	r8,r10
8000248c:	e0 88 00 08 	brls	8000249c <dip204_init+0x12c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002490:	12 38       	cp.w	r8,r9
80002492:	fe 98 ff fa 	brls	80002486 <dip204_init+0x116>
80002496:	12 3a       	cp.w	r10,r9
80002498:	c5 83       	brcs	80002548 <dip204_init+0x1d8>
8000249a:	cf 6b       	rjmp	80002486 <dip204_init+0x116>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000249c:	12 38       	cp.w	r8,r9
8000249e:	e0 8b 00 55 	brhi	80002548 <dip204_init+0x1d8>
800024a2:	12 3a       	cp.w	r10,r9
800024a4:	c5 23       	brcs	80002548 <dip204_init+0x1d8>
800024a6:	cf 0b       	rjmp	80002486 <dip204_init+0x116>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024a8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024ac:	14 38       	cp.w	r8,r10
800024ae:	e0 88 00 08 	brls	800024be <dip204_init+0x14e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024b2:	12 38       	cp.w	r8,r9
800024b4:	fe 98 ff fa 	brls	800024a8 <dip204_init+0x138>
800024b8:	12 3a       	cp.w	r10,r9
800024ba:	c5 13       	brcs	8000255c <dip204_init+0x1ec>
800024bc:	cf 6b       	rjmp	800024a8 <dip204_init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024be:	12 38       	cp.w	r8,r9
800024c0:	e0 8b 00 4e 	brhi	8000255c <dip204_init+0x1ec>
800024c4:	12 3a       	cp.w	r10,r9
800024c6:	c4 b3       	brcs	8000255c <dip204_init+0x1ec>
800024c8:	cf 0b       	rjmp	800024a8 <dip204_init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024ca:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024ce:	14 38       	cp.w	r8,r10
800024d0:	e0 88 00 08 	brls	800024e0 <dip204_init+0x170>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024d4:	12 38       	cp.w	r8,r9
800024d6:	fe 98 ff fa 	brls	800024ca <dip204_init+0x15a>
800024da:	12 3a       	cp.w	r10,r9
800024dc:	c4 a3       	brcs	80002570 <dip204_init+0x200>
800024de:	cf 6b       	rjmp	800024ca <dip204_init+0x15a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024e0:	12 38       	cp.w	r8,r9
800024e2:	e0 8b 00 47 	brhi	80002570 <dip204_init+0x200>
800024e6:	12 3a       	cp.w	r10,r9
800024e8:	c4 43       	brcs	80002570 <dip204_init+0x200>
800024ea:	cf 0b       	rjmp	800024ca <dip204_init+0x15a>
    }
  }
  // delay for power on
  delay_ms(20);
  // select the LCD chip
  dip204_select();
800024ec:	f0 1f 00 2e 	mcall	800025a4 <dip204_init+0x234>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
800024f0:	e0 6c 00 f8 	mov	r12,248
800024f4:	f0 1f 00 2d 	mcall	800025a8 <dip204_init+0x238>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
800024f8:	33 4c       	mov	r12,52
800024fa:	f0 1f 00 2c 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800024fe:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002502:	e0 69 ea 60 	mov	r9,60000
80002506:	f0 09 00 0a 	add	r10,r8,r9
8000250a:	c8 bb       	rjmp	80002420 <dip204_init+0xb0>
  // Wait for command execution
  delay_ms(1);
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
8000250c:	30 9c       	mov	r12,9
8000250e:	f0 1f 00 27 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002512:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002516:	e0 69 ea 60 	mov	r9,60000
8000251a:	f0 09 00 0a 	add	r10,r8,r9
8000251e:	c9 2b       	rjmp	80002442 <dip204_init+0xd2>
  // Wait for command execution
  delay_ms(1);
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
80002520:	33 0c       	mov	r12,48
80002522:	f0 1f 00 22 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002526:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000252a:	e0 69 ea 60 	mov	r9,60000
8000252e:	f0 09 00 0a 	add	r10,r8,r9
80002532:	c9 9b       	rjmp	80002464 <dip204_init+0xf4>
  // Wait for command execution
  delay_ms(1);
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
80002534:	30 fc       	mov	r12,15
80002536:	f0 1f 00 1d 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000253a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000253e:	e0 69 ea 60 	mov	r9,60000
80002542:	f0 09 00 0a 	add	r10,r8,r9
80002546:	ca 0b       	rjmp	80002486 <dip204_init+0x116>
  // Wait for command execution
  delay_ms(1);
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
80002548:	30 1c       	mov	r12,1
8000254a:	f0 1f 00 18 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000254e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002552:	e4 69 93 e0 	mov	r9,300000
80002556:	f0 09 00 0a 	add	r10,r8,r9
8000255a:	ca 7b       	rjmp	800024a8 <dip204_init+0x138>
  // Wait for command execution
  delay_ms(5);
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
8000255c:	30 6c       	mov	r12,6
8000255e:	f0 1f 00 13 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002562:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002566:	e0 69 ea 60 	mov	r9,60000
8000256a:	f0 09 00 0a 	add	r10,r8,r9
8000256e:	ca eb       	rjmp	800024ca <dip204_init+0x15a>
  // Wait for command execution
  delay_ms(1);
  dip204_wait_busy();
80002570:	f0 1f 00 0f 	mcall	800025ac <dip204_init+0x23c>
  // unselect chip
  dip204_unselect();
80002574:	f0 1f 00 0f 	mcall	800025b0 <dip204_init+0x240>
}
80002578:	2f cd       	sub	sp,-16
8000257a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000257e:	00 00       	add	r0,r0
80002580:	00 00       	add	r0,r0
80002582:	00 1c       	sub	r12,r0
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	25 b4       	sub	r4,91
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	29 2c       	sub	r12,-110
8000258c:	00 00       	add	r0,r0
8000258e:	05 6c       	ld.uh	r12,--r2
80002590:	00 00       	add	r0,r0
80002592:	05 4c       	ld.w	r12,--r2
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	28 ac       	sub	r12,-118
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	28 e2       	sub	r2,-114
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	26 54       	sub	r4,101
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	26 38       	sub	r8,99
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	20 dc       	sub	r12,13
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	20 f0       	sub	r0,15
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	21 84       	sub	r4,24
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	21 b8       	sub	r8,27

800025b4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800025b4:	f8 08 16 05 	lsr	r8,r12,0x5
800025b8:	a9 68       	lsl	r8,0x8
800025ba:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800025be:	58 1b       	cp.w	r11,1
800025c0:	c0 d0       	breq	800025da <gpio_enable_module_pin+0x26>
800025c2:	c0 63       	brcs	800025ce <gpio_enable_module_pin+0x1a>
800025c4:	58 2b       	cp.w	r11,2
800025c6:	c1 00       	breq	800025e6 <gpio_enable_module_pin+0x32>
800025c8:	58 3b       	cp.w	r11,3
800025ca:	c1 40       	breq	800025f2 <gpio_enable_module_pin+0x3e>
800025cc:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800025ce:	30 19       	mov	r9,1
800025d0:	f2 0c 09 49 	lsl	r9,r9,r12
800025d4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800025d6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025d8:	c1 28       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800025da:	30 19       	mov	r9,1
800025dc:	f2 0c 09 49 	lsl	r9,r9,r12
800025e0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800025e2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025e4:	c0 c8       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800025e6:	30 19       	mov	r9,1
800025e8:	f2 0c 09 49 	lsl	r9,r9,r12
800025ec:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800025ee:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025f0:	c0 68       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800025f2:	30 19       	mov	r9,1
800025f4:	f2 0c 09 49 	lsl	r9,r9,r12
800025f8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800025fa:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800025fc:	30 19       	mov	r9,1
800025fe:	f2 0c 09 4c 	lsl	r12,r9,r12
80002602:	91 2c       	st.w	r8[0x8],r12
80002604:	5e fd       	retal	0
80002606:	d7 03       	nop

80002608 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002608:	d4 21       	pushm	r4-r7,lr
8000260a:	18 97       	mov	r7,r12
8000260c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000260e:	58 0b       	cp.w	r11,0
80002610:	c0 31       	brne	80002616 <gpio_enable_module+0xe>
80002612:	30 05       	mov	r5,0
80002614:	c0 d8       	rjmp	8000262e <gpio_enable_module+0x26>
80002616:	30 06       	mov	r6,0
80002618:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000261a:	6e 1b       	ld.w	r11,r7[0x4]
8000261c:	6e 0c       	ld.w	r12,r7[0x0]
8000261e:	f0 1f 00 06 	mcall	80002634 <gpio_enable_module+0x2c>
80002622:	18 45       	or	r5,r12
		gpiomap++;
80002624:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002626:	2f f6       	sub	r6,-1
80002628:	0c 34       	cp.w	r4,r6
8000262a:	fe 9b ff f8 	brhi	8000261a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000262e:	0a 9c       	mov	r12,r5
80002630:	d8 22       	popm	r4-r7,pc
80002632:	00 00       	add	r0,r0
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	25 b4       	sub	r4,91

80002638 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002638:	f8 08 16 05 	lsr	r8,r12,0x5
8000263c:	a9 68       	lsl	r8,0x8
8000263e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002642:	30 19       	mov	r9,1
80002644:	f2 0c 09 4c 	lsl	r12,r9,r12
80002648:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000264c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002650:	91 1c       	st.w	r8[0x4],r12
}
80002652:	5e fc       	retal	r12

80002654 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002654:	f8 08 16 05 	lsr	r8,r12,0x5
80002658:	a9 68       	lsl	r8,0x8
8000265a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000265e:	30 19       	mov	r9,1
80002660:	f2 0c 09 4c 	lsl	r12,r9,r12
80002664:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80002668:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000266c:	91 1c       	st.w	r8[0x4],r12
}
8000266e:	5e fc       	retal	r12

80002670 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002670:	f8 08 16 05 	lsr	r8,r12,0x5
80002674:	a9 68       	lsl	r8,0x8
80002676:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8000267a:	30 19       	mov	r9,1
8000267c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002680:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80002684:	12 3b       	cp.w	r11,r9
80002686:	c0 a0       	breq	8000269a <gpio_enable_pin_interrupt+0x2a>
80002688:	c0 43       	brcs	80002690 <gpio_enable_pin_interrupt+0x20>
8000268a:	58 2b       	cp.w	r11,2
8000268c:	c1 11       	brne	800026ae <gpio_enable_pin_interrupt+0x3e>
8000268e:	c0 b8       	rjmp	800026a4 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002690:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80002694:	f1 4c 00 b8 	st.w	r8[184],r12
80002698:	c0 c8       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
8000269a:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000269e:	f1 4c 00 b8 	st.w	r8[184],r12
800026a2:	c0 78       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800026a4:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
800026a8:	f1 4c 00 b4 	st.w	r8[180],r12
800026ac:	c0 28       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
800026ae:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
800026b0:	f1 4c 00 94 	st.w	r8[148],r12
800026b4:	5e fd       	retal	0

800026b6 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026b6:	f8 08 16 05 	lsr	r8,r12,0x5
800026ba:	a9 68       	lsl	r8,0x8
800026bc:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
800026c0:	f0 f8 00 d0 	ld.w	r8,r8[208]
800026c4:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800026c8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800026cc:	5e fc       	retal	r12

800026ce <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026ce:	f8 08 16 05 	lsr	r8,r12,0x5
800026d2:	a9 68       	lsl	r8,0x8
800026d4:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800026d8:	30 19       	mov	r9,1
800026da:	f2 0c 09 4c 	lsl	r12,r9,r12
800026de:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
800026e2:	5e fc       	retal	r12

800026e4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800026e4:	c0 08       	rjmp	800026e4 <_unhandled_interrupt>
800026e6:	d7 03       	nop

800026e8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800026e8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800026ec:	49 99       	lddpc	r9,80002750 <INTC_register_interrupt+0x68>
800026ee:	f2 08 00 39 	add	r9,r9,r8<<0x3
800026f2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800026f6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800026f8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800026fc:	58 0a       	cp.w	r10,0
800026fe:	c0 91       	brne	80002710 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002700:	49 59       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
80002702:	49 6a       	lddpc	r10,80002758 <INTC_register_interrupt+0x70>
80002704:	12 1a       	sub	r10,r9
80002706:	fe 79 08 00 	mov	r9,-63488
8000270a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000270e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80002710:	58 1a       	cp.w	r10,1
80002712:	c0 a1       	brne	80002726 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002714:	49 09       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
80002716:	49 2a       	lddpc	r10,8000275c <INTC_register_interrupt+0x74>
80002718:	12 1a       	sub	r10,r9
8000271a:	bf aa       	sbr	r10,0x1e
8000271c:	fe 79 08 00 	mov	r9,-63488
80002720:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002724:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80002726:	58 2a       	cp.w	r10,2
80002728:	c0 a1       	brne	8000273c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000272a:	48 b9       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
8000272c:	48 da       	lddpc	r10,80002760 <INTC_register_interrupt+0x78>
8000272e:	12 1a       	sub	r10,r9
80002730:	bf ba       	sbr	r10,0x1f
80002732:	fe 79 08 00 	mov	r9,-63488
80002736:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000273a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000273c:	48 69       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
8000273e:	48 aa       	lddpc	r10,80002764 <INTC_register_interrupt+0x7c>
80002740:	12 1a       	sub	r10,r9
80002742:	ea 1a c0 00 	orh	r10,0xc000
80002746:	fe 79 08 00 	mov	r9,-63488
8000274a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000274e:	5e fc       	retal	r12
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	46 18       	lddsp	r8,sp[0x184]
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	44 00       	lddsp	r0,sp[0x100]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	45 04       	lddsp	r4,sp[0x140]
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	45 12       	lddsp	r2,sp[0x144]
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	45 20       	lddsp	r0,sp[0x148]
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	45 2e       	lddsp	lr,sp[0x148]

80002768 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002768:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000276a:	49 18       	lddpc	r8,800027ac <INTC_init_interrupts+0x44>
8000276c:	e3 b8 00 01 	mtsr	0x4,r8
80002770:	49 0e       	lddpc	lr,800027b0 <INTC_init_interrupts+0x48>
80002772:	30 07       	mov	r7,0
80002774:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002776:	49 0c       	lddpc	r12,800027b4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002778:	49 05       	lddpc	r5,800027b8 <INTC_init_interrupts+0x50>
8000277a:	10 15       	sub	r5,r8
8000277c:	fe 76 08 00 	mov	r6,-63488
80002780:	c1 08       	rjmp	800027a0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002782:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002784:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002786:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002788:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000278c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000278e:	10 3a       	cp.w	r10,r8
80002790:	fe 9b ff fc 	brhi	80002788 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002794:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002798:	2f f7       	sub	r7,-1
8000279a:	2f 8e       	sub	lr,-8
8000279c:	59 47       	cp.w	r7,20
8000279e:	c0 50       	breq	800027a8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800027a0:	7c 08       	ld.w	r8,lr[0x0]
800027a2:	58 08       	cp.w	r8,0
800027a4:	ce f1       	brne	80002782 <INTC_init_interrupts+0x1a>
800027a6:	cf 7b       	rjmp	80002794 <INTC_init_interrupts+0x2c>
800027a8:	d8 22       	popm	r4-r7,pc
800027aa:	00 00       	add	r0,r0
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	44 00       	lddsp	r0,sp[0x100]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	46 18       	lddsp	r8,sp[0x184]
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	26 e4       	sub	r4,110
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	45 04       	lddsp	r4,sp[0x140]

800027bc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800027bc:	fe 78 08 00 	mov	r8,-63488
800027c0:	e0 69 00 83 	mov	r9,131
800027c4:	f2 0c 01 0c 	sub	r12,r9,r12
800027c8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800027cc:	f2 ca ff c0 	sub	r10,r9,-64
800027d0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800027d4:	58 08       	cp.w	r8,0
800027d6:	c0 21       	brne	800027da <_get_interrupt_handler+0x1e>
800027d8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
800027da:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800027de:	48 5a       	lddpc	r10,800027f0 <_get_interrupt_handler+0x34>
800027e0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800027e4:	f0 08 11 1f 	rsub	r8,r8,31
800027e8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800027ea:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800027ee:	5e fc       	retal	r12
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	46 18       	lddsp	r8,sp[0x184]

800027f4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800027f4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800027f6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800027fa:	99 a8       	st.w	r12[0x28],r8
}
800027fc:	5e fc       	retal	r12
800027fe:	d7 03       	nop

80002800 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002800:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002802:	ec 5b bb 9f 	cp.w	r11,899999
80002806:	e0 8b 00 04 	brhi	8000280e <pm_enable_osc0_crystal+0xe>
8000280a:	30 4b       	mov	r11,4
8000280c:	c1 38       	rjmp	80002832 <pm_enable_osc0_crystal+0x32>
8000280e:	e0 68 c6 bf 	mov	r8,50879
80002812:	ea 18 00 2d 	orh	r8,0x2d
80002816:	10 3b       	cp.w	r11,r8
80002818:	e0 8b 00 04 	brhi	80002820 <pm_enable_osc0_crystal+0x20>
8000281c:	30 5b       	mov	r11,5
8000281e:	c0 a8       	rjmp	80002832 <pm_enable_osc0_crystal+0x32>
80002820:	e0 68 12 00 	mov	r8,4608
80002824:	ea 18 00 7a 	orh	r8,0x7a
80002828:	10 3b       	cp.w	r11,r8
8000282a:	f9 bb 03 06 	movlo	r11,6
8000282e:	f9 bb 02 07 	movhs	r11,7
80002832:	f0 1f 00 02 	mcall	80002838 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002836:	d8 02       	popm	pc
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	27 f4       	sub	r4,127

8000283c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000283c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000283e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002842:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002844:	78 08       	ld.w	r8,r12[0x0]
80002846:	a3 a8       	sbr	r8,0x2
80002848:	99 08       	st.w	r12[0x0],r8
}
8000284a:	5e fc       	retal	r12

8000284c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000284c:	79 58       	ld.w	r8,r12[0x54]
8000284e:	e2 18 00 80 	andl	r8,0x80,COH
80002852:	cf d0       	breq	8000284c <pm_wait_for_clk0_ready>
}
80002854:	5e fc       	retal	r12
80002856:	d7 03       	nop

80002858 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002858:	eb cd 40 80 	pushm	r7,lr
8000285c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000285e:	f0 1f 00 04 	mcall	8000286c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002862:	0e 9c       	mov	r12,r7
80002864:	f0 1f 00 03 	mcall	80002870 <pm_enable_clk0+0x18>
}
80002868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	28 3c       	sub	r12,-125
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	28 4c       	sub	r12,-124

80002874 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002874:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002876:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000287a:	99 08       	st.w	r12[0x0],r8
}
8000287c:	5e fc       	retal	r12
8000287e:	d7 03       	nop

80002880 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002880:	eb cd 40 c0 	pushm	r6-r7,lr
80002884:	18 97       	mov	r7,r12
80002886:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002888:	f0 1f 00 06 	mcall	800028a0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000288c:	0c 9b       	mov	r11,r6
8000288e:	0e 9c       	mov	r12,r7
80002890:	f0 1f 00 05 	mcall	800028a4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002894:	30 1b       	mov	r11,1
80002896:	0e 9c       	mov	r12,r7
80002898:	f0 1f 00 04 	mcall	800028a8 <pm_switch_to_osc0+0x28>
}
8000289c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	28 00       	sub	r0,-128
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	28 58       	sub	r8,-123
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	28 74       	sub	r4,-121

800028ac <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
800028ac:	58 0b       	cp.w	r11,0
800028ae:	c1 90       	breq	800028e0 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
800028b0:	58 6c       	cp.w	r12,6
800028b2:	e0 8b 00 17 	brhi	800028e0 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
800028b6:	76 0a       	ld.w	r10,r11[0x0]
800028b8:	fe 78 30 00 	mov	r8,-53248
800028bc:	f8 c9 ff f0 	sub	r9,r12,-16
800028c0:	a5 79       	lsl	r9,0x5
800028c2:	f0 09 00 09 	add	r9,r8,r9
800028c6:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
800028c8:	76 19       	ld.w	r9,r11[0x4]
800028ca:	a5 7c       	lsl	r12,0x5
800028cc:	f0 0c 00 0c 	add	r12,r8,r12
800028d0:	f8 c8 fd fc 	sub	r8,r12,-516
800028d4:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800028d6:	76 28       	ld.w	r8,r11[0x8]
800028d8:	f8 cc fd f8 	sub	r12,r12,-520
800028dc:	99 08       	st.w	r12[0x0],r8
800028de:	5e fd       	retal	0

  return PWM_SUCCESS;
800028e0:	5e ff       	retal	1

800028e2 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800028e2:	18 98       	mov	r8,r12
800028e4:	e0 18 ff 80 	andl	r8,0xff80
800028e8:	c0 20       	breq	800028ec <pwm_start_channels+0xa>
800028ea:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800028ec:	fe 78 30 00 	mov	r8,-53248
800028f0:	91 1c       	st.w	r8[0x4],r12
800028f2:	5e fd       	retal	0

800028f4 <pwm_sync_update_channel>:

int pwm_sync_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
800028f4:	58 6c       	cp.w	r12,6
800028f6:	e0 88 00 03 	brls	800028fc <pwm_sync_update_channel+0x8>
800028fa:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  AVR32_PWM.isr;                                    // Acknowledgement and clear previous register state.
800028fc:	fe 78 30 00 	mov	r8,-53248
80002900:	70 79       	ld.w	r9,r8[0x1c]
  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80002902:	76 09       	ld.w	r9,r11[0x0]
80002904:	f8 ca ff f0 	sub	r10,r12,-16
80002908:	a5 7a       	lsl	r10,0x5
8000290a:	14 08       	add	r8,r10
8000290c:	91 09       	st.w	r8[0x0],r9
  while (!(AVR32_PWM.isr & (1 << channel_id)));     // Wait until the last write has been taken into account.
8000290e:	30 1a       	mov	r10,1
80002910:	f4 0c 09 4a 	lsl	r10,r10,r12
80002914:	fe 79 30 00 	mov	r9,-53248
80002918:	72 78       	ld.w	r8,r9[0x1c]
8000291a:	f5 e8 00 08 	and	r8,r10,r8
8000291e:	cf d0       	breq	80002918 <pwm_sync_update_channel+0x24>
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80002920:	76 48       	ld.w	r8,r11[0x10]
80002922:	a5 7c       	lsl	r12,0x5
80002924:	e0 2c cd f0 	sub	r12,52720
80002928:	99 08       	st.w	r12[0x0],r8
8000292a:	5e fd       	retal	0

8000292c <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000292c:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80002930:	58 0c       	cp.w	r12,0
80002932:	c0 21       	brne	80002936 <pwm_init+0xa>
80002934:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002936:	e6 18 00 01 	andh	r8,0x1,COH
8000293a:	c0 91       	brne	8000294c <pwm_init+0x20>
8000293c:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000293e:	fe 78 30 00 	mov	r8,-53248
80002942:	37 f9       	mov	r9,127
80002944:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002946:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002948:	d5 03       	csrf	0x10
8000294a:	c0 68       	rjmp	80002956 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000294c:	fe 78 30 00 	mov	r8,-53248
80002950:	37 f9       	mov	r9,127
80002952:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002954:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80002956:	78 08       	ld.w	r8,r12[0x0]
80002958:	78 39       	ld.w	r9,r12[0xc]
8000295a:	a9 69       	lsl	r9,0x8
8000295c:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80002960:	78 18       	ld.w	r8,r12[0x4]
80002962:	10 49       	or	r9,r8
80002964:	78 28       	ld.w	r8,r12[0x8]
80002966:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000296a:	fe 78 30 00 	mov	r8,-53248
8000296e:	91 09       	st.w	r8[0x0],r9
80002970:	5e fd       	retal	0

80002972 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002972:	f8 c8 00 01 	sub	r8,r12,1
80002976:	f0 0b 00 0b 	add	r11,r8,r11
8000297a:	f6 0c 0d 0a 	divu	r10,r11,r12
8000297e:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002980:	f4 c8 00 01 	sub	r8,r10,1
80002984:	e0 48 00 fe 	cp.w	r8,254
80002988:	e0 88 00 03 	brls	8000298e <getBaudDiv+0x1c>
8000298c:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
8000298e:	5c 8c       	casts.h	r12
}
80002990:	5e fc       	retal	r12

80002992 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002992:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002996:	30 18       	mov	r8,1
80002998:	f0 09 18 00 	cp.b	r9,r8
8000299c:	e0 88 00 04 	brls	800029a4 <spi_initMaster+0x12>
800029a0:	30 2c       	mov	r12,2
800029a2:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800029a4:	e0 68 00 80 	mov	r8,128
800029a8:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800029aa:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800029ac:	30 19       	mov	r9,1
800029ae:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800029b2:	f7 39 00 0d 	ld.ub	r9,r11[13]
800029b6:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800029ba:	30 09       	mov	r9,0
800029bc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800029c0:	30 fa       	mov	r10,15
800029c2:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800029c6:	99 18       	st.w	r12[0x4],r8
800029c8:	5e f9       	retal	r9

800029ca <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800029ca:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800029cc:	30 18       	mov	r8,1
800029ce:	f0 0b 18 00 	cp.b	r11,r8
800029d2:	5f be       	srhi	lr
800029d4:	f0 0a 18 00 	cp.b	r10,r8
800029d8:	5f b8       	srhi	r8
800029da:	fd e8 10 08 	or	r8,lr,r8
800029de:	c0 30       	breq	800029e4 <spi_selectionMode+0x1a>
800029e0:	30 2c       	mov	r12,2
800029e2:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800029e4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800029e6:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800029ea:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800029ee:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800029f2:	99 18       	st.w	r12[0x4],r8
800029f4:	d8 0a       	popm	pc,r12=0

800029f6 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800029f6:	30 18       	mov	r8,1
800029f8:	99 08       	st.w	r12[0x0],r8
}
800029fa:	5e fc       	retal	r12

800029fc <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800029fc:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a00:	c0 58       	rjmp	80002a0a <spi_write+0xe>
		if (!timeout--) {
80002a02:	58 08       	cp.w	r8,0
80002a04:	c0 21       	brne	80002a08 <spi_write+0xc>
80002a06:	5e ff       	retal	1
80002a08:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a0a:	78 49       	ld.w	r9,r12[0x10]
80002a0c:	e2 19 00 02 	andl	r9,0x2,COH
80002a10:	cf 90       	breq	80002a02 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002a12:	5c 7b       	castu.h	r11
80002a14:	99 3b       	st.w	r12[0xc],r11
80002a16:	5e fd       	retal	0

80002a18 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002a18:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a1c:	c0 58       	rjmp	80002a26 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002a1e:	58 08       	cp.w	r8,0
80002a20:	c0 21       	brne	80002a24 <spi_read+0xc>
80002a22:	5e ff       	retal	1
80002a24:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a26:	78 49       	ld.w	r9,r12[0x10]
80002a28:	e2 19 02 01 	andl	r9,0x201,COH
80002a2c:	e0 49 02 01 	cp.w	r9,513
80002a30:	cf 71       	brne	80002a1e <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002a32:	78 28       	ld.w	r8,r12[0x8]
80002a34:	b6 08       	st.h	r11[0x0],r8
80002a36:	5e fd       	retal	0

80002a38 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002a38:	eb cd 40 f8 	pushm	r3-r7,lr
80002a3c:	18 95       	mov	r5,r12
80002a3e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a40:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002a44:	30 38       	mov	r8,3
80002a46:	f0 06 18 00 	cp.b	r6,r8
80002a4a:	e0 8b 00 5e 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80002a4e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a52:	30 18       	mov	r8,1
80002a54:	f0 04 18 00 	cp.b	r4,r8
80002a58:	e0 8b 00 57 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002a5c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a60:	30 78       	mov	r8,7
80002a62:	f0 03 18 00 	cp.b	r3,r8
80002a66:	e0 88 00 50 	brls	80002b06 <spi_setupChipReg+0xce>
80002a6a:	31 08       	mov	r8,16
80002a6c:	f0 03 18 00 	cp.b	r3,r8
80002a70:	e0 8b 00 4b 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002a74:	14 9b       	mov	r11,r10
80002a76:	6e 1c       	ld.w	r12,r7[0x4]
80002a78:	f0 1f 00 26 	mcall	80002b10 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80002a7c:	c4 55       	brlt	80002b06 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002a7e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002a80:	ec 09 16 01 	lsr	r9,r6,0x1
80002a84:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002a88:	ec 16 00 01 	eorl	r6,0x1
80002a8c:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002a90:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002a94:	20 83       	sub	r3,8
80002a96:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002a9a:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002a9e:	ef 39 00 09 	ld.ub	r9,r7[9]
80002aa2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002aa6:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002aaa:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002aae:	0f 89       	ld.ub	r9,r7[0x0]
80002ab0:	30 1a       	mov	r10,1
80002ab2:	f4 09 18 00 	cp.b	r9,r10
80002ab6:	c0 d0       	breq	80002ad0 <spi_setupChipReg+0x98>
80002ab8:	c0 a3       	brcs	80002acc <spi_setupChipReg+0x94>
80002aba:	30 2a       	mov	r10,2
80002abc:	f4 09 18 00 	cp.b	r9,r10
80002ac0:	c0 a0       	breq	80002ad4 <spi_setupChipReg+0x9c>
80002ac2:	30 3a       	mov	r10,3
80002ac4:	f4 09 18 00 	cp.b	r9,r10
80002ac8:	c1 f1       	brne	80002b06 <spi_setupChipReg+0xce>
80002aca:	c0 78       	rjmp	80002ad8 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002acc:	8b c8       	st.w	r5[0x30],r8
		break;
80002ace:	c0 68       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002ad0:	8b d8       	st.w	r5[0x34],r8
		break;
80002ad2:	c0 48       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002ad4:	8b e8       	st.w	r5[0x38],r8
		break;
80002ad6:	c0 28       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002ad8:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80002ada:	48 f8       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002adc:	70 08       	ld.w	r8,r8[0x0]
80002ade:	58 08       	cp.w	r8,0
80002ae0:	c1 61       	brne	80002b0c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80002ae2:	30 0b       	mov	r11,0
80002ae4:	30 1c       	mov	r12,1
80002ae6:	f0 1f 00 0d 	mcall	80002b18 <spi_setupChipReg+0xe0>
80002aea:	48 b8       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002aec:	91 0c       	st.w	r8[0x0],r12
80002aee:	58 0c       	cp.w	r12,0
80002af0:	c0 a0       	breq	80002b04 <spi_setupChipReg+0xcc>
80002af2:	30 09       	mov	r9,0
80002af4:	12 9a       	mov	r10,r9
80002af6:	12 9b       	mov	r11,r9
80002af8:	f0 1f 00 09 	mcall	80002b1c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80002afc:	48 68       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002afe:	70 08       	ld.w	r8,r8[0x0]
80002b00:	58 08       	cp.w	r8,0
80002b02:	c0 51       	brne	80002b0c <spi_setupChipReg+0xd4>
80002b04:	c0 08       	rjmp	80002b04 <spi_setupChipReg+0xcc>
80002b06:	30 2c       	mov	r12,2
80002b08:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002b0c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	29 72       	sub	r2,-105
80002b14:	00 00       	add	r0,r0
80002b16:	07 8c       	ld.ub	r12,r3[0x0]
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	31 1c       	mov	r12,17
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	30 1c       	mov	r12,1

80002b20 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002b20:	d4 01       	pushm	lr
80002b22:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b26:	c0 58       	rjmp	80002b30 <spi_unselectChip+0x10>
		if (!timeout--) {
80002b28:	58 08       	cp.w	r8,0
80002b2a:	c0 21       	brne	80002b2e <spi_unselectChip+0xe>
80002b2c:	da 0a       	popm	pc,r12=1
80002b2e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b30:	78 49       	ld.w	r9,r12[0x10]
80002b32:	e2 19 02 00 	andl	r9,0x200,COH
80002b36:	cf 90       	breq	80002b28 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002b38:	78 18       	ld.w	r8,r12[0x4]
80002b3a:	ea 18 00 0f 	orh	r8,0xf
80002b3e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002b40:	fc 18 01 00 	movh	r8,0x100
80002b44:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80002b46:	30 09       	mov	r9,0
80002b48:	12 9a       	mov	r10,r9
80002b4a:	12 9b       	mov	r11,r9
80002b4c:	48 38       	lddpc	r8,80002b58 <spi_unselectChip+0x38>
80002b4e:	70 0c       	ld.w	r12,r8[0x0]
80002b50:	f0 1f 00 03 	mcall	80002b5c <spi_unselectChip+0x3c>
80002b54:	d8 0a       	popm	pc,r12=0
80002b56:	00 00       	add	r0,r0
80002b58:	00 00       	add	r0,r0
80002b5a:	07 8c       	ld.ub	r12,r3[0x0]
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	30 1c       	mov	r12,1

80002b60 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002b60:	eb cd 40 f8 	pushm	r3-r7,lr
80002b64:	18 94       	mov	r4,r12
80002b66:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80002b68:	49 a6       	lddpc	r6,80002bd0 <spi_selectChip+0x70>
80002b6a:	30 07       	mov	r7,0
80002b6c:	31 45       	mov	r5,20
80002b6e:	0e 99       	mov	r9,r7
80002b70:	0a 9a       	mov	r10,r5
80002b72:	0e 9b       	mov	r11,r7
80002b74:	6c 0c       	ld.w	r12,r6[0x0]
80002b76:	f0 1f 00 18 	mcall	80002bd4 <spi_selectChip+0x74>
80002b7a:	cf a0       	breq	80002b6e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002b7c:	68 18       	ld.w	r8,r4[0x4]
80002b7e:	ea 18 00 0f 	orh	r8,0xf
80002b82:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002b84:	68 18       	ld.w	r8,r4[0x4]
80002b86:	e2 18 00 04 	andl	r8,0x4,COH
80002b8a:	c1 10       	breq	80002bac <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002b8c:	30 e8       	mov	r8,14
80002b8e:	f0 03 18 00 	cp.b	r3,r8
80002b92:	e0 8b 00 1c 	brhi	80002bca <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002b96:	68 19       	ld.w	r9,r4[0x4]
80002b98:	e6 08 15 10 	lsl	r8,r3,0x10
80002b9c:	ea 18 ff f0 	orh	r8,0xfff0
80002ba0:	e8 18 ff ff 	orl	r8,0xffff
80002ba4:	12 68       	and	r8,r9
80002ba6:	89 18       	st.w	r4[0x4],r8
80002ba8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002bac:	30 38       	mov	r8,3
80002bae:	f0 03 18 00 	cp.b	r3,r8
80002bb2:	e0 8b 00 0c 	brhi	80002bca <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002bb6:	68 19       	ld.w	r9,r4[0x4]
80002bb8:	2f 03       	sub	r3,-16
80002bba:	30 18       	mov	r8,1
80002bbc:	f0 03 09 48 	lsl	r8,r8,r3
80002bc0:	5c d8       	com	r8
80002bc2:	12 68       	and	r8,r9
80002bc4:	89 18       	st.w	r4[0x4],r8
80002bc6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002bca:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002bcc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002bd0:	00 00       	add	r0,r0
80002bd2:	07 8c       	ld.ub	r12,r3[0x0]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 00       	sub	r0,-16

80002bd8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002bd8:	f8 c8 ff f8 	sub	r8,r12,-8
80002bdc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002bde:	3f f9       	mov	r9,-1
80002be0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002be2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002be4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002be6:	30 08       	mov	r8,0
80002be8:	99 08       	st.w	r12[0x0],r8
}
80002bea:	5e fc       	retal	r12

80002bec <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002bec:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80002bee:	70 19       	ld.w	r9,r8[0x4]
80002bf0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002bf2:	78 19       	ld.w	r9,r12[0x4]
80002bf4:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002bf6:	70 19       	ld.w	r9,r8[0x4]
80002bf8:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002bfa:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002bfc:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002bfe:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c00:	78 08       	ld.w	r8,r12[0x0]
80002c02:	2f f8       	sub	r8,-1
80002c04:	99 08       	st.w	r12[0x0],r8
}
80002c06:	5e fc       	retal	r12

80002c08 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002c08:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002c0a:	5b fa       	cp.w	r10,-1
80002c0c:	c0 31       	brne	80002c12 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002c0e:	78 48       	ld.w	r8,r12[0x10]
80002c10:	c0 c8       	rjmp	80002c28 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002c12:	f8 c8 ff f8 	sub	r8,r12,-8
80002c16:	70 19       	ld.w	r9,r8[0x4]
80002c18:	72 09       	ld.w	r9,r9[0x0]
80002c1a:	12 3a       	cp.w	r10,r9
80002c1c:	c0 63       	brcs	80002c28 <vListInsert+0x20>
80002c1e:	70 18       	ld.w	r8,r8[0x4]
80002c20:	70 19       	ld.w	r9,r8[0x4]
80002c22:	72 09       	ld.w	r9,r9[0x0]
80002c24:	12 3a       	cp.w	r10,r9
80002c26:	cf c2       	brcc	80002c1e <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002c28:	70 19       	ld.w	r9,r8[0x4]
80002c2a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002c2c:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80002c2e:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002c30:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002c32:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c34:	78 08       	ld.w	r8,r12[0x0]
80002c36:	2f f8       	sub	r8,-1
80002c38:	99 08       	st.w	r12[0x0],r8
}
80002c3a:	5e fc       	retal	r12

80002c3c <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002c3c:	78 18       	ld.w	r8,r12[0x4]
80002c3e:	78 29       	ld.w	r9,r12[0x8]
80002c40:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002c42:	78 28       	ld.w	r8,r12[0x8]
80002c44:	78 19       	ld.w	r9,r12[0x4]
80002c46:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002c48:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002c4a:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002c4c:	18 39       	cp.w	r9,r12
80002c4e:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80002c52:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002c56:	30 09       	mov	r9,0
80002c58:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80002c5a:	70 09       	ld.w	r9,r8[0x0]
80002c5c:	20 19       	sub	r9,1
80002c5e:	91 09       	st.w	r8[0x0],r9
}
80002c60:	5e fc       	retal	r12
80002c62:	d7 03       	nop

80002c64 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002c64:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002c66:	48 38       	lddpc	r8,80002c70 <vPortEnterCritical+0xc>
80002c68:	70 09       	ld.w	r9,r8[0x0]
80002c6a:	2f f9       	sub	r9,-1
80002c6c:	91 09       	st.w	r8[0x0],r9
}
80002c6e:	5e fc       	retal	r12
80002c70:	00 00       	add	r0,r0
80002c72:	00 20       	rsub	r0,r0

80002c74 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80002c74:	20 6d       	sub	sp,24
80002c76:	eb cd 00 ff 	pushm	r0-r7
80002c7a:	fa c7 ff c0 	sub	r7,sp,-64
80002c7e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80002c82:	ef 40 ff e0 	st.w	r7[-32],r0
80002c86:	ee f0 ff fc 	ld.w	r0,r7[-4]
80002c8a:	ef 40 ff e4 	st.w	r7[-28],r0
80002c8e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80002c92:	e0 68 00 20 	mov	r8,32
80002c96:	ea 18 00 00 	orh	r8,0x0
80002c9a:	70 00       	ld.w	r0,r8[0x0]
80002c9c:	1a d0       	st.w	--sp,r0
80002c9e:	f0 1f 00 1a 	mcall	80002d04 <LABEL_RET_SCALL_260+0x14>
80002ca2:	e0 68 07 0c 	mov	r8,1804
80002ca6:	ea 18 00 00 	orh	r8,0x0
80002caa:	70 00       	ld.w	r0,r8[0x0]
80002cac:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80002cae:	f0 1f 00 17 	mcall	80002d08 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80002cb2:	e0 68 07 0c 	mov	r8,1804
80002cb6:	ea 18 00 00 	orh	r8,0x0
80002cba:	70 00       	ld.w	r0,r8[0x0]
80002cbc:	60 0d       	ld.w	sp,r0[0x0]
80002cbe:	1b 00       	ld.w	r0,sp++
80002cc0:	e0 68 00 20 	mov	r8,32
80002cc4:	ea 18 00 00 	orh	r8,0x0
80002cc8:	91 00       	st.w	r8[0x0],r0
80002cca:	fa c7 ff d8 	sub	r7,sp,-40
80002cce:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80002cd2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80002cd6:	e0 61 00 20 	mov	r1,32
80002cda:	ea 11 00 00 	orh	r1,0x0
80002cde:	62 02       	ld.w	r2,r1[0x0]
80002ce0:	58 02       	cp.w	r2,0
80002ce2:	c0 70       	breq	80002cf0 <LABEL_RET_SCALL_260>
80002ce4:	e4 c2 00 01 	sub	r2,r2,1
80002ce8:	83 02       	st.w	r1[0x0],r2
80002cea:	58 02       	cp.w	r2,0
80002cec:	c0 21       	brne	80002cf0 <LABEL_RET_SCALL_260>
80002cee:	b1 c0       	cbr	r0,0x10

80002cf0 <LABEL_RET_SCALL_260>:
80002cf0:	ef 40 ff f8 	st.w	r7[-8],r0
80002cf4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80002cf8:	ef 40 ff fc 	st.w	r7[-4],r0
80002cfc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002d00:	2f ad       	sub	sp,-24
80002d02:	d6 13       	rets
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	2c 64       	sub	r4,-58
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	31 a0       	mov	r0,26

80002d0c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80002d0c:	48 78       	lddpc	r8,80002d28 <vPortExitCritical+0x1c>
80002d0e:	70 08       	ld.w	r8,r8[0x0]
80002d10:	58 08       	cp.w	r8,0
80002d12:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80002d14:	48 58       	lddpc	r8,80002d28 <vPortExitCritical+0x1c>
80002d16:	70 09       	ld.w	r9,r8[0x0]
80002d18:	20 19       	sub	r9,1
80002d1a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80002d1c:	70 08       	ld.w	r8,r8[0x0]
80002d1e:	58 08       	cp.w	r8,0
80002d20:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80002d22:	d5 03       	csrf	0x10
80002d24:	5e fc       	retal	r12
80002d26:	00 00       	add	r0,r0
80002d28:	00 00       	add	r0,r0
80002d2a:	00 20       	rsub	r0,r0

80002d2c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002d2c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80002d2e:	f0 1f 00 02 	mcall	80002d34 <__malloc_lock+0x8>
}
80002d32:	d8 02       	popm	pc
80002d34:	80 00       	ld.sh	r0,r0[0x0]
80002d36:	31 90       	mov	r0,25

80002d38 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002d38:	d4 01       	pushm	lr
	xTaskResumeAll();
80002d3a:	f0 1f 00 02 	mcall	80002d40 <__malloc_unlock+0x8>
}
80002d3e:	d8 02       	popm	pc
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	34 40       	mov	r0,68

80002d44 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002d44:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002d46:	48 a8       	lddpc	r8,80002d6c <_init_startup+0x28>
80002d48:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002d4c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002d4e:	f0 1f 00 09 	mcall	80002d70 <_init_startup+0x2c>

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002d52:	48 98       	lddpc	r8,80002d74 <_init_startup+0x30>
80002d54:	48 99       	lddpc	r9,80002d78 <_init_startup+0x34>
80002d56:	12 38       	cp.w	r8,r9
80002d58:	c0 82       	brcc	80002d68 <_init_startup+0x24>
		{
			*pxMem++ = 0xA5A5A5A5;
80002d5a:	e0 6a a5 a5 	mov	r10,42405
80002d5e:	ea 1a a5 a5 	orh	r10,0xa5a5
80002d62:	10 aa       	st.w	r8++,r10
	INTC_init_interrupts();

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002d64:	12 38       	cp.w	r8,r9
80002d66:	cf e3       	brcs	80002d62 <_init_startup+0x1e>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80002d68:	da 0a       	popm	pc,r12=1
80002d6a:	00 00       	add	r0,r0
80002d6c:	80 00       	ld.sh	r0,r0[0x0]
80002d6e:	44 00       	lddsp	r0,sp[0x100]
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	27 68       	sub	r8,118
80002d74:	00 00       	add	r0,r0
80002d76:	07 98       	ld.ub	r8,r3[0x1]
80002d78:	00 00       	add	r0,r0
80002d7a:	f0 00       	*unknown*

80002d7c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80002d7c:	eb cd 40 80 	pushm	r7,lr
80002d80:	18 97       	mov	r7,r12
	if( pv )
80002d82:	58 0c       	cp.w	r12,0
80002d84:	c0 80       	breq	80002d94 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80002d86:	f0 1f 00 05 	mcall	80002d98 <vPortFree+0x1c>
		{
			free( pv );
80002d8a:	0e 9c       	mov	r12,r7
80002d8c:	f0 1f 00 04 	mcall	80002d9c <vPortFree+0x20>
		}
		xTaskResumeAll();
80002d90:	f0 1f 00 04 	mcall	80002da0 <vPortFree+0x24>
80002d94:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	31 90       	mov	r0,25
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	39 a8       	mov	r8,-102
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	34 40       	mov	r0,68

80002da4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002da4:	eb cd 40 80 	pushm	r7,lr
80002da8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80002daa:	f0 1f 00 06 	mcall	80002dc0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80002dae:	0e 9c       	mov	r12,r7
80002db0:	f0 1f 00 05 	mcall	80002dc4 <pvPortMalloc+0x20>
80002db4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80002db6:	f0 1f 00 05 	mcall	80002dc8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80002dba:	0e 9c       	mov	r12,r7
80002dbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	31 90       	mov	r0,25
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	39 b8       	mov	r8,-101
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	34 40       	mov	r0,68

80002dcc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80002dcc:	d4 01       	pushm	lr
80002dce:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002dd0:	78 09       	ld.w	r9,r12[0x0]
80002dd2:	58 09       	cp.w	r9,0
80002dd4:	c1 10       	breq	80002df6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80002dd6:	78 3a       	ld.w	r10,r12[0xc]
80002dd8:	79 09       	ld.w	r9,r12[0x40]
80002dda:	f4 09 00 09 	add	r9,r10,r9
80002dde:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80002de0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80002de2:	14 39       	cp.w	r9,r10
80002de4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002de8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80002dec:	79 0a       	ld.w	r10,r12[0x40]
80002dee:	78 3b       	ld.w	r11,r12[0xc]
80002df0:	10 9c       	mov	r12,r8
80002df2:	f0 1f 00 02 	mcall	80002df8 <prvCopyDataFromQueue+0x2c>
80002df6:	d8 02       	popm	pc
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	3d fc       	mov	r12,-33

80002dfc <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002dfc:	eb cd 40 80 	pushm	r7,lr
80002e00:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002e02:	79 08       	ld.w	r8,r12[0x40]
80002e04:	58 08       	cp.w	r8,0
80002e06:	c2 50       	breq	80002e50 <prvCopyDataToQueue+0x54>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80002e08:	58 0a       	cp.w	r10,0
80002e0a:	c1 01       	brne	80002e2a <prvCopyDataToQueue+0x2e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e0c:	10 9a       	mov	r10,r8
80002e0e:	78 2c       	ld.w	r12,r12[0x8]
80002e10:	f0 1f 00 13 	mcall	80002e5c <prvCopyDataToQueue+0x60>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002e14:	6e 29       	ld.w	r9,r7[0x8]
80002e16:	6f 08       	ld.w	r8,r7[0x40]
80002e18:	f2 08 00 08 	add	r8,r9,r8
80002e1c:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80002e1e:	6e 19       	ld.w	r9,r7[0x4]
80002e20:	12 38       	cp.w	r8,r9
80002e22:	c1 73       	brcs	80002e50 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002e24:	6e 08       	ld.w	r8,r7[0x0]
80002e26:	8f 28       	st.w	r7[0x8],r8
80002e28:	c1 48       	rjmp	80002e50 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e2a:	10 9a       	mov	r10,r8
80002e2c:	78 3c       	ld.w	r12,r12[0xc]
80002e2e:	f0 1f 00 0c 	mcall	80002e5c <prvCopyDataToQueue+0x60>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80002e32:	6f 08       	ld.w	r8,r7[0x40]
80002e34:	6e 39       	ld.w	r9,r7[0xc]
80002e36:	f2 08 01 08 	sub	r8,r9,r8
80002e3a:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80002e3c:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002e3e:	12 38       	cp.w	r8,r9
80002e40:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002e44:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002e48:	f3 d8 e3 19 	subcs	r9,r9,r8
80002e4c:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002e50:	6e e8       	ld.w	r8,r7[0x38]
80002e52:	2f f8       	sub	r8,-1
80002e54:	8f e8       	st.w	r7[0x38],r8
}
80002e56:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e5a:	00 00       	add	r0,r0
80002e5c:	80 00       	ld.sh	r0,r0[0x0]
80002e5e:	3d fc       	mov	r12,-33

80002e60 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80002e60:	eb cd 40 c0 	pushm	r6-r7,lr
80002e64:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002e66:	f0 1f 00 23 	mcall	80002ef0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002e6a:	6f 28       	ld.w	r8,r7[0x48]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	e0 8a 00 18 	brle	80002e9e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002e72:	6e 98       	ld.w	r8,r7[0x24]
80002e74:	58 08       	cp.w	r8,0
80002e76:	c1 40       	breq	80002e9e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002e78:	ee c6 ff dc 	sub	r6,r7,-36
80002e7c:	c0 48       	rjmp	80002e84 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002e7e:	6e 98       	ld.w	r8,r7[0x24]
80002e80:	58 08       	cp.w	r8,0
80002e82:	c0 e0       	breq	80002e9e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002e84:	0c 9c       	mov	r12,r6
80002e86:	f0 1f 00 1c 	mcall	80002ef4 <prvUnlockQueue+0x94>
80002e8a:	c0 30       	breq	80002e90 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80002e8c:	f0 1f 00 1b 	mcall	80002ef8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80002e90:	6f 28       	ld.w	r8,r7[0x48]
80002e92:	20 18       	sub	r8,1
80002e94:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002e98:	58 08       	cp.w	r8,0
80002e9a:	fe 99 ff f2 	brgt	80002e7e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002e9e:	3f f8       	mov	r8,-1
80002ea0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002ea4:	f0 1f 00 16 	mcall	80002efc <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002ea8:	f0 1f 00 12 	mcall	80002ef0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002eac:	6f 18       	ld.w	r8,r7[0x44]
80002eae:	58 08       	cp.w	r8,0
80002eb0:	e0 8a 00 18 	brle	80002ee0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002eb4:	6e 48       	ld.w	r8,r7[0x10]
80002eb6:	58 08       	cp.w	r8,0
80002eb8:	c1 40       	breq	80002ee0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002eba:	ee c6 ff f0 	sub	r6,r7,-16
80002ebe:	c0 48       	rjmp	80002ec6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002ec0:	6e 48       	ld.w	r8,r7[0x10]
80002ec2:	58 08       	cp.w	r8,0
80002ec4:	c0 e0       	breq	80002ee0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002ec6:	0c 9c       	mov	r12,r6
80002ec8:	f0 1f 00 0b 	mcall	80002ef4 <prvUnlockQueue+0x94>
80002ecc:	c0 30       	breq	80002ed2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80002ece:	f0 1f 00 0b 	mcall	80002ef8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80002ed2:	6f 18       	ld.w	r8,r7[0x44]
80002ed4:	20 18       	sub	r8,1
80002ed6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002eda:	58 08       	cp.w	r8,0
80002edc:	fe 99 ff f2 	brgt	80002ec0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002ee0:	3f f8       	mov	r8,-1
80002ee2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002ee6:	f0 1f 00 06 	mcall	80002efc <prvUnlockQueue+0x9c>
}
80002eea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eee:	00 00       	add	r0,r0
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	2c 64       	sub	r4,-58
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	32 b0       	mov	r0,43
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	32 34       	mov	r4,35
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2d 0c       	sub	r12,-48

80002f00 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002f00:	d4 31       	pushm	r0-r7,lr
80002f02:	20 5d       	sub	sp,20
80002f04:	18 97       	mov	r7,r12
80002f06:	50 0b       	stdsp	sp[0x0],r11
80002f08:	50 2a       	stdsp	sp[0x8],r10
80002f0a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002f0c:	f8 c1 ff dc 	sub	r1,r12,-36
80002f10:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f12:	fa c4 ff f4 	sub	r4,sp,-12
80002f16:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002f18:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002f1a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002f1e:	f0 1f 00 36 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002f22:	6e e8       	ld.w	r8,r7[0x38]
80002f24:	58 08       	cp.w	r8,0
80002f26:	c2 40       	breq	80002f6e <xQueueGenericReceive+0x6e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80002f28:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002f2a:	40 0b       	lddsp	r11,sp[0x0]
80002f2c:	0e 9c       	mov	r12,r7
80002f2e:	f0 1f 00 33 	mcall	80002ff8 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002f32:	40 18       	lddsp	r8,sp[0x4]
80002f34:	58 08       	cp.w	r8,0
80002f36:	c0 f1       	brne	80002f54 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80002f38:	6e e8       	ld.w	r8,r7[0x38]
80002f3a:	20 18       	sub	r8,1
80002f3c:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f3e:	6e 48       	ld.w	r8,r7[0x10]
80002f40:	58 08       	cp.w	r8,0
80002f42:	c1 20       	breq	80002f66 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002f44:	ee cc ff f0 	sub	r12,r7,-16
80002f48:	f0 1f 00 2d 	mcall	80002ffc <xQueueGenericReceive+0xfc>
80002f4c:	58 1c       	cp.w	r12,1
80002f4e:	c0 c1       	brne	80002f66 <xQueueGenericReceive+0x66>
						{
							portYIELD_WITHIN_API();
80002f50:	d7 33       	scall
80002f52:	c0 a8       	rjmp	80002f66 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80002f54:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002f56:	6e 98       	ld.w	r8,r7[0x24]
80002f58:	58 08       	cp.w	r8,0
80002f5a:	c0 60       	breq	80002f66 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002f5c:	02 9c       	mov	r12,r1
80002f5e:	f0 1f 00 28 	mcall	80002ffc <xQueueGenericReceive+0xfc>
80002f62:	c0 20       	breq	80002f66 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80002f64:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80002f66:	f0 1f 00 27 	mcall	80003000 <xQueueGenericReceive+0x100>
80002f6a:	30 1c       	mov	r12,1
				return pdPASS;
80002f6c:	c4 28       	rjmp	80002ff0 <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002f6e:	40 28       	lddsp	r8,sp[0x8]
80002f70:	58 08       	cp.w	r8,0
80002f72:	c0 51       	brne	80002f7c <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002f74:	f0 1f 00 23 	mcall	80003000 <xQueueGenericReceive+0x100>
80002f78:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002f7a:	c3 b8       	rjmp	80002ff0 <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002f7c:	58 05       	cp.w	r5,0
80002f7e:	c0 51       	brne	80002f88 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f80:	08 9c       	mov	r12,r4
80002f82:	f0 1f 00 21 	mcall	80003004 <xQueueGenericReceive+0x104>
80002f86:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80002f88:	f0 1f 00 1e 	mcall	80003000 <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002f8c:	f0 1f 00 1f 	mcall	80003008 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002f90:	f0 1f 00 19 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
80002f94:	6f 18       	ld.w	r8,r7[0x44]
80002f96:	5b f8       	cp.w	r8,-1
80002f98:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002f9c:	6f 28       	ld.w	r8,r7[0x48]
80002f9e:	5b f8       	cp.w	r8,-1
80002fa0:	ef f2 0a 12 	st.weq	r7[0x48],r2
80002fa4:	f0 1f 00 17 	mcall	80003000 <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002fa8:	06 9b       	mov	r11,r3
80002faa:	08 9c       	mov	r12,r4
80002fac:	f0 1f 00 18 	mcall	8000300c <xQueueGenericReceive+0x10c>
80002fb0:	c1 a1       	brne	80002fe4 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002fb2:	f0 1f 00 11 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80002fb6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80002fb8:	f0 1f 00 12 	mcall	80003000 <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80002fbc:	58 06       	cp.w	r6,0
80002fbe:	c0 d1       	brne	80002fd8 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002fc0:	40 2b       	lddsp	r11,sp[0x8]
80002fc2:	02 9c       	mov	r12,r1
80002fc4:	f0 1f 00 13 	mcall	80003010 <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80002fc8:	0e 9c       	mov	r12,r7
80002fca:	f0 1f 00 13 	mcall	80003014 <xQueueGenericReceive+0x114>
				if( !xTaskResumeAll() )
80002fce:	f0 1f 00 13 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fd2:	ca 61       	brne	80002f1e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80002fd4:	d7 33       	scall
80002fd6:	ca 4b       	rjmp	80002f1e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002fd8:	0e 9c       	mov	r12,r7
80002fda:	f0 1f 00 0f 	mcall	80003014 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
80002fde:	f0 1f 00 0f 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fe2:	c9 eb       	rjmp	80002f1e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80002fe4:	0e 9c       	mov	r12,r7
80002fe6:	f0 1f 00 0c 	mcall	80003014 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80002fea:	f0 1f 00 0c 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fee:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80002ff0:	2f bd       	sub	sp,-20
80002ff2:	d8 32       	popm	r0-r7,pc
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	2c 64       	sub	r4,-58
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	2d cc       	sub	r12,-36
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	32 b0       	mov	r0,43
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	2d 0c       	sub	r12,-48
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	32 1c       	mov	r12,33
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	31 90       	mov	r0,25
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	32 40       	mov	r0,36
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	35 84       	mov	r4,88
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	2e 60       	sub	r0,-26
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	34 40       	mov	r0,68

8000301c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000301c:	d4 31       	pushm	r0-r7,lr
8000301e:	20 5d       	sub	sp,20
80003020:	18 97       	mov	r7,r12
80003022:	50 0b       	stdsp	sp[0x0],r11
80003024:	50 2a       	stdsp	sp[0x8],r10
80003026:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003028:	f8 c0 ff f0 	sub	r0,r12,-16
8000302c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000302e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80003032:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003034:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80003038:	f0 1f 00 2f 	mcall	800030f4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000303c:	6e e9       	ld.w	r9,r7[0x38]
8000303e:	6e f8       	ld.w	r8,r7[0x3c]
80003040:	10 39       	cp.w	r9,r8
80003042:	c1 42       	brcc	8000306a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80003044:	40 1a       	lddsp	r10,sp[0x4]
80003046:	40 0b       	lddsp	r11,sp[0x0]
80003048:	0e 9c       	mov	r12,r7
8000304a:	f0 1f 00 2c 	mcall	800030f8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000304e:	6e 98       	ld.w	r8,r7[0x24]
80003050:	58 08       	cp.w	r8,0
80003052:	c0 80       	breq	80003062 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003054:	ee cc ff dc 	sub	r12,r7,-36
80003058:	f0 1f 00 29 	mcall	800030fc <xQueueGenericSend+0xe0>
8000305c:	58 1c       	cp.w	r12,1
8000305e:	c0 21       	brne	80003062 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80003060:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80003062:	f0 1f 00 28 	mcall	80003100 <xQueueGenericSend+0xe4>
80003066:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80003068:	c4 38       	rjmp	800030ee <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000306a:	40 28       	lddsp	r8,sp[0x8]
8000306c:	58 08       	cp.w	r8,0
8000306e:	c0 51       	brne	80003078 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003070:	f0 1f 00 24 	mcall	80003100 <xQueueGenericSend+0xe4>
80003074:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80003076:	c3 c8       	rjmp	800030ee <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80003078:	58 04       	cp.w	r4,0
8000307a:	c0 51       	brne	80003084 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000307c:	06 9c       	mov	r12,r3
8000307e:	f0 1f 00 22 	mcall	80003104 <xQueueGenericSend+0xe8>
80003082:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80003084:	f0 1f 00 1f 	mcall	80003100 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80003088:	f0 1f 00 20 	mcall	80003108 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000308c:	f0 1f 00 1a 	mcall	800030f4 <xQueueGenericSend+0xd8>
80003090:	6f 18       	ld.w	r8,r7[0x44]
80003092:	5b f8       	cp.w	r8,-1
80003094:	ef f1 0a 11 	st.weq	r7[0x44],r1
80003098:	6f 28       	ld.w	r8,r7[0x48]
8000309a:	5b f8       	cp.w	r8,-1
8000309c:	ef f1 0a 12 	st.weq	r7[0x48],r1
800030a0:	f0 1f 00 18 	mcall	80003100 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800030a4:	04 9b       	mov	r11,r2
800030a6:	06 9c       	mov	r12,r3
800030a8:	f0 1f 00 19 	mcall	8000310c <xQueueGenericSend+0xf0>
800030ac:	c1 b1       	brne	800030e2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800030ae:	f0 1f 00 12 	mcall	800030f4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800030b2:	6e e5       	ld.w	r5,r7[0x38]
800030b4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800030b6:	f0 1f 00 13 	mcall	80003100 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800030ba:	0c 35       	cp.w	r5,r6
800030bc:	c0 d1       	brne	800030d6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800030be:	40 2b       	lddsp	r11,sp[0x8]
800030c0:	00 9c       	mov	r12,r0
800030c2:	f0 1f 00 14 	mcall	80003110 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800030c6:	0e 9c       	mov	r12,r7
800030c8:	f0 1f 00 13 	mcall	80003114 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800030cc:	f0 1f 00 13 	mcall	80003118 <xQueueGenericSend+0xfc>
800030d0:	cb 41       	brne	80003038 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800030d2:	d7 33       	scall
800030d4:	cb 2b       	rjmp	80003038 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800030d6:	0e 9c       	mov	r12,r7
800030d8:	f0 1f 00 0f 	mcall	80003114 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800030dc:	f0 1f 00 0f 	mcall	80003118 <xQueueGenericSend+0xfc>
800030e0:	ca cb       	rjmp	80003038 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800030e2:	0e 9c       	mov	r12,r7
800030e4:	f0 1f 00 0c 	mcall	80003114 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800030e8:	f0 1f 00 0c 	mcall	80003118 <xQueueGenericSend+0xfc>
800030ec:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800030ee:	2f bd       	sub	sp,-20
800030f0:	d8 32       	popm	r0-r7,pc
800030f2:	00 00       	add	r0,r0
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	2c 64       	sub	r4,-58
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2d fc       	sub	r12,-33
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	32 b0       	mov	r0,43
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2d 0c       	sub	r12,-48
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	32 1c       	mov	r12,33
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	31 90       	mov	r0,25
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	32 40       	mov	r0,36
80003110:	80 00       	ld.sh	r0,r0[0x0]
80003112:	35 84       	mov	r4,88
80003114:	80 00       	ld.sh	r0,r0[0x0]
80003116:	2e 60       	sub	r0,-26
80003118:	80 00       	ld.sh	r0,r0[0x0]
8000311a:	34 40       	mov	r0,68

8000311c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000311c:	d4 21       	pushm	r4-r7,lr
8000311e:	18 97       	mov	r7,r12
80003120:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80003122:	58 0c       	cp.w	r12,0
80003124:	c2 f0       	breq	80003182 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003126:	34 cc       	mov	r12,76
80003128:	f0 1f 00 17 	mcall	80003184 <xQueueCreate+0x68>
8000312c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000312e:	c2 a0       	breq	80003182 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80003130:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80003134:	e8 cc ff ff 	sub	r12,r4,-1
80003138:	f0 1f 00 13 	mcall	80003184 <xQueueCreate+0x68>
8000313c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000313e:	c1 e0       	breq	8000317a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80003140:	f8 04 00 04 	add	r4,r12,r4
80003144:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80003146:	30 08       	mov	r8,0
80003148:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000314a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000314c:	ee c8 00 01 	sub	r8,r7,1
80003150:	ad 38       	mul	r8,r6
80003152:	10 0c       	add	r12,r8
80003154:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80003156:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80003158:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000315c:	3f f8       	mov	r8,-1
8000315e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80003162:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80003166:	ea cc ff f0 	sub	r12,r5,-16
8000316a:	f0 1f 00 08 	mcall	80003188 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000316e:	ea cc ff dc 	sub	r12,r5,-36
80003172:	f0 1f 00 06 	mcall	80003188 <xQueueCreate+0x6c>
80003176:	0a 9c       	mov	r12,r5
80003178:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000317a:	0a 9c       	mov	r12,r5
8000317c:	f0 1f 00 04 	mcall	8000318c <xQueueCreate+0x70>
80003180:	d8 2a       	popm	r4-r7,pc,r12=0
80003182:	d8 2a       	popm	r4-r7,pc,r12=0
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	2d a4       	sub	r4,-38
80003188:	80 00       	ld.sh	r0,r0[0x0]
8000318a:	2b d8       	sub	r8,-67
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	2d 7c       	sub	r12,-41

80003190 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80003190:	48 38       	lddpc	r8,8000319c <vTaskSuspendAll+0xc>
80003192:	70 09       	ld.w	r9,r8[0x0]
80003194:	2f f9       	sub	r9,-1
80003196:	91 09       	st.w	r8[0x0],r9
}
80003198:	5e fc       	retal	r12
8000319a:	00 00       	add	r0,r0
8000319c:	00 00       	add	r0,r0
8000319e:	07 28       	ld.uh	r8,r3++

800031a0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800031a0:	49 a8       	lddpc	r8,80003208 <vTaskSwitchContext+0x68>
800031a2:	70 08       	ld.w	r8,r8[0x0]
800031a4:	58 08       	cp.w	r8,0
800031a6:	c0 b1       	brne	800031bc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031a8:	49 98       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>
800031aa:	70 08       	ld.w	r8,r8[0x0]
800031ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800031b0:	49 89       	lddpc	r9,80003210 <vTaskSwitchContext+0x70>
800031b2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800031b6:	58 08       	cp.w	r8,0
800031b8:	c0 60       	breq	800031c4 <vTaskSwitchContext+0x24>
800031ba:	c1 18       	rjmp	800031dc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800031bc:	30 19       	mov	r9,1
800031be:	49 68       	lddpc	r8,80003214 <vTaskSwitchContext+0x74>
800031c0:	91 09       	st.w	r8[0x0],r9
800031c2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800031c4:	49 28       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031c6:	49 3a       	lddpc	r10,80003210 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800031c8:	70 09       	ld.w	r9,r8[0x0]
800031ca:	20 19       	sub	r9,1
800031cc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031ce:	70 09       	ld.w	r9,r8[0x0]
800031d0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800031d4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800031d8:	58 09       	cp.w	r9,0
800031da:	cf 70       	breq	800031c8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800031dc:	48 c8       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>
800031de:	70 08       	ld.w	r8,r8[0x0]
800031e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800031e4:	48 b9       	lddpc	r9,80003210 <vTaskSwitchContext+0x70>
800031e6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800031ea:	70 19       	ld.w	r9,r8[0x4]
800031ec:	72 19       	ld.w	r9,r9[0x4]
800031ee:	91 19       	st.w	r8[0x4],r9
800031f0:	f0 ca ff f8 	sub	r10,r8,-8
800031f4:	14 39       	cp.w	r9,r10
800031f6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800031fa:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800031fe:	70 18       	ld.w	r8,r8[0x4]
80003200:	70 39       	ld.w	r9,r8[0xc]
80003202:	48 68       	lddpc	r8,80003218 <vTaskSwitchContext+0x78>
80003204:	91 09       	st.w	r8[0x0],r9
80003206:	5e fc       	retal	r12
80003208:	00 00       	add	r0,r0
8000320a:	07 28       	ld.uh	r8,r3++
8000320c:	00 00       	add	r0,r0
8000320e:	07 48       	ld.w	r8,--r3
80003210:	00 00       	add	r0,r0
80003212:	06 6c       	and	r12,r3
80003214:	00 00       	add	r0,r0
80003216:	07 30       	ld.ub	r0,r3++
80003218:	00 00       	add	r0,r0
8000321a:	07 0c       	ld.w	r12,r3++

8000321c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000321c:	48 48       	lddpc	r8,8000322c <vTaskSetTimeOutState+0x10>
8000321e:	70 08       	ld.w	r8,r8[0x0]
80003220:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80003222:	48 48       	lddpc	r8,80003230 <vTaskSetTimeOutState+0x14>
80003224:	70 08       	ld.w	r8,r8[0x0]
80003226:	99 18       	st.w	r12[0x4],r8
}
80003228:	5e fc       	retal	r12
8000322a:	00 00       	add	r0,r0
8000322c:	00 00       	add	r0,r0
8000322e:	06 64       	and	r4,r3
80003230:	00 00       	add	r0,r0
80003232:	07 24       	ld.uh	r4,r3++

80003234 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80003234:	30 19       	mov	r9,1
80003236:	48 28       	lddpc	r8,8000323c <vTaskMissedYield+0x8>
80003238:	91 09       	st.w	r8[0x0],r9
}
8000323a:	5e fc       	retal	r12
8000323c:	00 00       	add	r0,r0
8000323e:	07 30       	ld.ub	r0,r3++

80003240 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80003240:	eb cd 40 c0 	pushm	r6-r7,lr
80003244:	18 97       	mov	r7,r12
80003246:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80003248:	f0 1f 00 15 	mcall	8000329c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000324c:	6c 08       	ld.w	r8,r6[0x0]
8000324e:	5b f8       	cp.w	r8,-1
80003250:	c0 31       	brne	80003256 <xTaskCheckForTimeOut+0x16>
80003252:	30 07       	mov	r7,0
80003254:	c1 f8       	rjmp	80003292 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80003256:	49 39       	lddpc	r9,800032a0 <xTaskCheckForTimeOut+0x60>
80003258:	72 09       	ld.w	r9,r9[0x0]
8000325a:	6e 0a       	ld.w	r10,r7[0x0]
8000325c:	12 3a       	cp.w	r10,r9
8000325e:	c0 70       	breq	8000326c <xTaskCheckForTimeOut+0x2c>
80003260:	49 19       	lddpc	r9,800032a4 <xTaskCheckForTimeOut+0x64>
80003262:	72 09       	ld.w	r9,r9[0x0]
80003264:	6e 1a       	ld.w	r10,r7[0x4]
80003266:	12 3a       	cp.w	r10,r9
80003268:	e0 88 00 14 	brls	80003290 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000326c:	48 e9       	lddpc	r9,800032a4 <xTaskCheckForTimeOut+0x64>
8000326e:	72 0a       	ld.w	r10,r9[0x0]
80003270:	6e 19       	ld.w	r9,r7[0x4]
80003272:	12 1a       	sub	r10,r9
80003274:	14 38       	cp.w	r8,r10
80003276:	e0 88 00 0d 	brls	80003290 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000327a:	48 ba       	lddpc	r10,800032a4 <xTaskCheckForTimeOut+0x64>
8000327c:	74 0a       	ld.w	r10,r10[0x0]
8000327e:	14 19       	sub	r9,r10
80003280:	f2 08 00 08 	add	r8,r9,r8
80003284:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80003286:	0e 9c       	mov	r12,r7
80003288:	f0 1f 00 08 	mcall	800032a8 <xTaskCheckForTimeOut+0x68>
8000328c:	30 07       	mov	r7,0
8000328e:	c0 28       	rjmp	80003292 <xTaskCheckForTimeOut+0x52>
80003290:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80003292:	f0 1f 00 07 	mcall	800032ac <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80003296:	0e 9c       	mov	r12,r7
80003298:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	2c 64       	sub	r4,-58
800032a0:	00 00       	add	r0,r0
800032a2:	06 64       	and	r4,r3
800032a4:	00 00       	add	r0,r0
800032a6:	07 24       	ld.uh	r4,r3++
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	32 1c       	mov	r12,33
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	2d 0c       	sub	r12,-48

800032b0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800032b0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800032b4:	78 38       	ld.w	r8,r12[0xc]
800032b6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800032b8:	ee c6 ff e8 	sub	r6,r7,-24
800032bc:	0c 9c       	mov	r12,r6
800032be:	f0 1f 00 15 	mcall	80003310 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800032c2:	49 58       	lddpc	r8,80003314 <xTaskRemoveFromEventList+0x64>
800032c4:	70 08       	ld.w	r8,r8[0x0]
800032c6:	58 08       	cp.w	r8,0
800032c8:	c1 71       	brne	800032f6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800032ca:	ee c6 ff fc 	sub	r6,r7,-4
800032ce:	0c 9c       	mov	r12,r6
800032d0:	f0 1f 00 10 	mcall	80003310 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800032d4:	6e bc       	ld.w	r12,r7[0x2c]
800032d6:	49 18       	lddpc	r8,80003318 <xTaskRemoveFromEventList+0x68>
800032d8:	70 08       	ld.w	r8,r8[0x0]
800032da:	10 3c       	cp.w	r12,r8
800032dc:	e0 88 00 04 	brls	800032e4 <xTaskRemoveFromEventList+0x34>
800032e0:	48 e8       	lddpc	r8,80003318 <xTaskRemoveFromEventList+0x68>
800032e2:	91 0c       	st.w	r8[0x0],r12
800032e4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800032e8:	0c 9b       	mov	r11,r6
800032ea:	48 d8       	lddpc	r8,8000331c <xTaskRemoveFromEventList+0x6c>
800032ec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800032f0:	f0 1f 00 0c 	mcall	80003320 <xTaskRemoveFromEventList+0x70>
800032f4:	c0 58       	rjmp	800032fe <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800032f6:	0c 9b       	mov	r11,r6
800032f8:	48 bc       	lddpc	r12,80003324 <xTaskRemoveFromEventList+0x74>
800032fa:	f0 1f 00 0a 	mcall	80003320 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800032fe:	48 b8       	lddpc	r8,80003328 <xTaskRemoveFromEventList+0x78>
80003300:	70 08       	ld.w	r8,r8[0x0]
80003302:	6e b9       	ld.w	r9,r7[0x2c]
80003304:	70 b8       	ld.w	r8,r8[0x2c]
80003306:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80003308:	5f 2c       	srhs	r12
8000330a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000330e:	00 00       	add	r0,r0
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	2c 3c       	sub	r12,-61
80003314:	00 00       	add	r0,r0
80003316:	07 28       	ld.uh	r8,r3++
80003318:	00 00       	add	r0,r0
8000331a:	07 48       	ld.w	r8,--r3
8000331c:	00 00       	add	r0,r0
8000331e:	06 6c       	and	r12,r3
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	2b ec       	sub	r12,-66
80003324:	00 00       	add	r0,r0
80003326:	07 10       	ld.sh	r0,r3++
80003328:	00 00       	add	r0,r0
8000332a:	07 0c       	ld.w	r12,r3++

8000332c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000332c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003330:	4b 98       	lddpc	r8,80003414 <vTaskIncrementTick+0xe8>
80003332:	70 08       	ld.w	r8,r8[0x0]
80003334:	58 08       	cp.w	r8,0
80003336:	c6 91       	brne	80003408 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80003338:	4b 88       	lddpc	r8,80003418 <vTaskIncrementTick+0xec>
8000333a:	70 09       	ld.w	r9,r8[0x0]
8000333c:	2f f9       	sub	r9,-1
8000333e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80003340:	70 08       	ld.w	r8,r8[0x0]
80003342:	58 08       	cp.w	r8,0
80003344:	c1 a1       	brne	80003378 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80003346:	4b 68       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003348:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000334a:	4b 69       	lddpc	r9,80003420 <vTaskIncrementTick+0xf4>
8000334c:	72 0b       	ld.w	r11,r9[0x0]
8000334e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80003350:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80003352:	4b 59       	lddpc	r9,80003424 <vTaskIncrementTick+0xf8>
80003354:	72 0a       	ld.w	r10,r9[0x0]
80003356:	2f fa       	sub	r10,-1
80003358:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000335a:	70 08       	ld.w	r8,r8[0x0]
8000335c:	70 08       	ld.w	r8,r8[0x0]
8000335e:	58 08       	cp.w	r8,0
80003360:	c0 51       	brne	8000336a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80003362:	3f f9       	mov	r9,-1
80003364:	4b 18       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
80003366:	91 09       	st.w	r8[0x0],r9
80003368:	c0 88       	rjmp	80003378 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000336a:	4a d8       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
8000336c:	70 08       	ld.w	r8,r8[0x0]
8000336e:	70 38       	ld.w	r8,r8[0xc]
80003370:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80003372:	70 19       	ld.w	r9,r8[0x4]
80003374:	4a d8       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
80003376:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80003378:	4a 88       	lddpc	r8,80003418 <vTaskIncrementTick+0xec>
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	4a b8       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
8000337e:	70 08       	ld.w	r8,r8[0x0]
80003380:	10 39       	cp.w	r9,r8
80003382:	c4 73       	brcs	80003410 <vTaskIncrementTick+0xe4>
80003384:	4a 68       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003386:	70 08       	ld.w	r8,r8[0x0]
80003388:	70 08       	ld.w	r8,r8[0x0]
8000338a:	58 08       	cp.w	r8,0
8000338c:	c0 c0       	breq	800033a4 <vTaskIncrementTick+0x78>
8000338e:	4a 48       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003390:	70 08       	ld.w	r8,r8[0x0]
80003392:	70 38       	ld.w	r8,r8[0xc]
80003394:	70 37       	ld.w	r7,r8[0xc]
80003396:	6e 18       	ld.w	r8,r7[0x4]
80003398:	4a 09       	lddpc	r9,80003418 <vTaskIncrementTick+0xec>
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	12 38       	cp.w	r8,r9
8000339e:	e0 88 00 14 	brls	800033c6 <vTaskIncrementTick+0x9a>
800033a2:	c0 e8       	rjmp	800033be <vTaskIncrementTick+0x92>
800033a4:	3f f9       	mov	r9,-1
800033a6:	4a 18       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
800033a8:	91 09       	st.w	r8[0x0],r9
800033aa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800033ae:	6a 08       	ld.w	r8,r5[0x0]
800033b0:	70 38       	ld.w	r8,r8[0xc]
800033b2:	70 37       	ld.w	r7,r8[0xc]
800033b4:	6e 18       	ld.w	r8,r7[0x4]
800033b6:	64 09       	ld.w	r9,r2[0x0]
800033b8:	12 38       	cp.w	r8,r9
800033ba:	e0 88 00 0a 	brls	800033ce <vTaskIncrementTick+0xa2>
800033be:	49 b9       	lddpc	r9,80003428 <vTaskIncrementTick+0xfc>
800033c0:	93 08       	st.w	r9[0x0],r8
800033c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800033c6:	49 a4       	lddpc	r4,8000342c <vTaskIncrementTick+0x100>
800033c8:	49 a3       	lddpc	r3,80003430 <vTaskIncrementTick+0x104>
800033ca:	49 55       	lddpc	r5,8000341c <vTaskIncrementTick+0xf0>
800033cc:	49 32       	lddpc	r2,80003418 <vTaskIncrementTick+0xec>
800033ce:	ee c6 ff fc 	sub	r6,r7,-4
800033d2:	0c 9c       	mov	r12,r6
800033d4:	f0 1f 00 18 	mcall	80003434 <vTaskIncrementTick+0x108>
800033d8:	6e a8       	ld.w	r8,r7[0x28]
800033da:	58 08       	cp.w	r8,0
800033dc:	c0 50       	breq	800033e6 <vTaskIncrementTick+0xba>
800033de:	ee cc ff e8 	sub	r12,r7,-24
800033e2:	f0 1f 00 15 	mcall	80003434 <vTaskIncrementTick+0x108>
800033e6:	6e bc       	ld.w	r12,r7[0x2c]
800033e8:	68 08       	ld.w	r8,r4[0x0]
800033ea:	10 3c       	cp.w	r12,r8
800033ec:	e9 fc ba 00 	st.whi	r4[0x0],r12
800033f0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800033f4:	0c 9b       	mov	r11,r6
800033f6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800033fa:	f0 1f 00 10 	mcall	80003438 <vTaskIncrementTick+0x10c>
800033fe:	6a 08       	ld.w	r8,r5[0x0]
80003400:	70 08       	ld.w	r8,r8[0x0]
80003402:	58 08       	cp.w	r8,0
80003404:	cd 51       	brne	800033ae <vTaskIncrementTick+0x82>
80003406:	cc fb       	rjmp	800033a4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80003408:	48 d8       	lddpc	r8,8000343c <vTaskIncrementTick+0x110>
8000340a:	70 09       	ld.w	r9,r8[0x0]
8000340c:	2f f9       	sub	r9,-1
8000340e:	91 09       	st.w	r8[0x0],r9
80003410:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003414:	00 00       	add	r0,r0
80003416:	07 28       	ld.uh	r8,r3++
80003418:	00 00       	add	r0,r0
8000341a:	07 24       	ld.uh	r4,r3++
8000341c:	00 00       	add	r0,r0
8000341e:	06 60       	and	r0,r3
80003420:	00 00       	add	r0,r0
80003422:	06 68       	and	r8,r3
80003424:	00 00       	add	r0,r0
80003426:	06 64       	and	r4,r3
80003428:	00 00       	add	r0,r0
8000342a:	00 24       	rsub	r4,r0
8000342c:	00 00       	add	r0,r0
8000342e:	07 48       	ld.w	r8,--r3
80003430:	00 00       	add	r0,r0
80003432:	06 6c       	and	r12,r3
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	2c 3c       	sub	r12,-61
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	2b ec       	sub	r12,-66
8000343c:	00 00       	add	r0,r0
8000343e:	06 5c       	eor	r12,r3

80003440 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80003440:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80003444:	f0 1f 00 2c 	mcall	800034f4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80003448:	4a c8       	lddpc	r8,800034f8 <xTaskResumeAll+0xb8>
8000344a:	70 09       	ld.w	r9,r8[0x0]
8000344c:	20 19       	sub	r9,1
8000344e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003450:	70 08       	ld.w	r8,r8[0x0]
80003452:	58 08       	cp.w	r8,0
80003454:	c4 91       	brne	800034e6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80003456:	4a a8       	lddpc	r8,800034fc <xTaskResumeAll+0xbc>
80003458:	70 08       	ld.w	r8,r8[0x0]
8000345a:	58 08       	cp.w	r8,0
8000345c:	c4 50       	breq	800034e6 <xTaskResumeAll+0xa6>
8000345e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003460:	4a 85       	lddpc	r5,80003500 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80003462:	4a 93       	lddpc	r3,80003504 <xTaskResumeAll+0xc4>
80003464:	4a 92       	lddpc	r2,80003508 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003466:	4a a1       	lddpc	r1,8000350c <xTaskResumeAll+0xcc>
80003468:	c1 e8       	rjmp	800034a4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000346a:	6a 38       	ld.w	r8,r5[0xc]
8000346c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000346e:	ee cc ff e8 	sub	r12,r7,-24
80003472:	f0 1f 00 28 	mcall	80003510 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80003476:	ee c6 ff fc 	sub	r6,r7,-4
8000347a:	0c 9c       	mov	r12,r6
8000347c:	f0 1f 00 25 	mcall	80003510 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80003480:	6e bc       	ld.w	r12,r7[0x2c]
80003482:	66 08       	ld.w	r8,r3[0x0]
80003484:	10 3c       	cp.w	r12,r8
80003486:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000348a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000348e:	0c 9b       	mov	r11,r6
80003490:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80003494:	f0 1f 00 20 	mcall	80003514 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003498:	62 08       	ld.w	r8,r1[0x0]
8000349a:	6e b9       	ld.w	r9,r7[0x2c]
8000349c:	70 b8       	ld.w	r8,r8[0x2c]
8000349e:	10 39       	cp.w	r9,r8
800034a0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800034a4:	6a 08       	ld.w	r8,r5[0x0]
800034a6:	58 08       	cp.w	r8,0
800034a8:	ce 11       	brne	8000346a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034aa:	49 c8       	lddpc	r8,80003518 <xTaskResumeAll+0xd8>
800034ac:	70 08       	ld.w	r8,r8[0x0]
800034ae:	58 08       	cp.w	r8,0
800034b0:	c0 f0       	breq	800034ce <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034b2:	49 a8       	lddpc	r8,80003518 <xTaskResumeAll+0xd8>
800034b4:	70 08       	ld.w	r8,r8[0x0]
800034b6:	58 08       	cp.w	r8,0
800034b8:	c1 10       	breq	800034da <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800034ba:	49 87       	lddpc	r7,80003518 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800034bc:	f0 1f 00 18 	mcall	8000351c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800034c0:	6e 08       	ld.w	r8,r7[0x0]
800034c2:	20 18       	sub	r8,1
800034c4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034c6:	6e 08       	ld.w	r8,r7[0x0]
800034c8:	58 08       	cp.w	r8,0
800034ca:	cf 91       	brne	800034bc <xTaskResumeAll+0x7c>
800034cc:	c0 78       	rjmp	800034da <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800034ce:	58 14       	cp.w	r4,1
800034d0:	c0 50       	breq	800034da <xTaskResumeAll+0x9a>
800034d2:	49 48       	lddpc	r8,80003520 <xTaskResumeAll+0xe0>
800034d4:	70 08       	ld.w	r8,r8[0x0]
800034d6:	58 18       	cp.w	r8,1
800034d8:	c0 71       	brne	800034e6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800034da:	30 09       	mov	r9,0
800034dc:	49 18       	lddpc	r8,80003520 <xTaskResumeAll+0xe0>
800034de:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800034e0:	d7 33       	scall
800034e2:	30 17       	mov	r7,1
800034e4:	c0 28       	rjmp	800034e8 <xTaskResumeAll+0xa8>
800034e6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800034e8:	f0 1f 00 0f 	mcall	80003524 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800034ec:	0e 9c       	mov	r12,r7
800034ee:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800034f2:	00 00       	add	r0,r0
800034f4:	80 00       	ld.sh	r0,r0[0x0]
800034f6:	2c 64       	sub	r4,-58
800034f8:	00 00       	add	r0,r0
800034fa:	07 28       	ld.uh	r8,r3++
800034fc:	00 00       	add	r0,r0
800034fe:	07 2c       	ld.uh	r12,r3++
80003500:	00 00       	add	r0,r0
80003502:	07 10       	ld.sh	r0,r3++
80003504:	00 00       	add	r0,r0
80003506:	07 48       	ld.w	r8,--r3
80003508:	00 00       	add	r0,r0
8000350a:	06 6c       	and	r12,r3
8000350c:	00 00       	add	r0,r0
8000350e:	07 0c       	ld.w	r12,r3++
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	2c 3c       	sub	r12,-61
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	2b ec       	sub	r12,-66
80003518:	00 00       	add	r0,r0
8000351a:	06 5c       	eor	r12,r3
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	33 2c       	mov	r12,50
80003520:	00 00       	add	r0,r0
80003522:	07 30       	ld.ub	r0,r3++
80003524:	80 00       	ld.sh	r0,r0[0x0]
80003526:	2d 0c       	sub	r12,-48

80003528 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80003528:	eb cd 40 80 	pushm	r7,lr
8000352c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000352e:	49 08       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
80003530:	70 08       	ld.w	r8,r8[0x0]
80003532:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80003534:	48 f8       	lddpc	r8,80003570 <prvAddCurrentTaskToDelayedList+0x48>
80003536:	70 08       	ld.w	r8,r8[0x0]
80003538:	10 3c       	cp.w	r12,r8
8000353a:	c0 a2       	brcc	8000354e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000353c:	48 c8       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
8000353e:	70 0b       	ld.w	r11,r8[0x0]
80003540:	48 d8       	lddpc	r8,80003574 <prvAddCurrentTaskToDelayedList+0x4c>
80003542:	70 0c       	ld.w	r12,r8[0x0]
80003544:	2f cb       	sub	r11,-4
80003546:	f0 1f 00 0d 	mcall	80003578 <prvAddCurrentTaskToDelayedList+0x50>
8000354a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000354e:	48 88       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
80003550:	70 0b       	ld.w	r11,r8[0x0]
80003552:	48 b8       	lddpc	r8,8000357c <prvAddCurrentTaskToDelayedList+0x54>
80003554:	70 0c       	ld.w	r12,r8[0x0]
80003556:	2f cb       	sub	r11,-4
80003558:	f0 1f 00 08 	mcall	80003578 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000355c:	48 98       	lddpc	r8,80003580 <prvAddCurrentTaskToDelayedList+0x58>
8000355e:	70 08       	ld.w	r8,r8[0x0]
80003560:	10 37       	cp.w	r7,r8
80003562:	c0 32       	brcc	80003568 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80003564:	48 78       	lddpc	r8,80003580 <prvAddCurrentTaskToDelayedList+0x58>
80003566:	91 07       	st.w	r8[0x0],r7
80003568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000356c:	00 00       	add	r0,r0
8000356e:	07 0c       	ld.w	r12,r3++
80003570:	00 00       	add	r0,r0
80003572:	07 24       	ld.uh	r4,r3++
80003574:	00 00       	add	r0,r0
80003576:	06 68       	and	r8,r3
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	2c 08       	sub	r8,-64
8000357c:	00 00       	add	r0,r0
8000357e:	06 60       	and	r0,r3
80003580:	00 00       	add	r0,r0
80003582:	00 24       	rsub	r4,r0

80003584 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80003584:	eb cd 40 c0 	pushm	r6-r7,lr
80003588:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000358a:	48 e7       	lddpc	r7,800035c0 <vTaskPlaceOnEventList+0x3c>
8000358c:	6e 0b       	ld.w	r11,r7[0x0]
8000358e:	2e 8b       	sub	r11,-24
80003590:	f0 1f 00 0d 	mcall	800035c4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003594:	6e 0c       	ld.w	r12,r7[0x0]
80003596:	2f cc       	sub	r12,-4
80003598:	f0 1f 00 0c 	mcall	800035c8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000359c:	5b f6       	cp.w	r6,-1
8000359e:	c0 81       	brne	800035ae <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800035a0:	6e 0b       	ld.w	r11,r7[0x0]
800035a2:	2f cb       	sub	r11,-4
800035a4:	48 ac       	lddpc	r12,800035cc <vTaskPlaceOnEventList+0x48>
800035a6:	f0 1f 00 0b 	mcall	800035d0 <vTaskPlaceOnEventList+0x4c>
800035aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800035ae:	48 a8       	lddpc	r8,800035d4 <vTaskPlaceOnEventList+0x50>
800035b0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800035b2:	ec 0c 00 0c 	add	r12,r6,r12
800035b6:	f0 1f 00 09 	mcall	800035d8 <vTaskPlaceOnEventList+0x54>
800035ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035be:	00 00       	add	r0,r0
800035c0:	00 00       	add	r0,r0
800035c2:	07 0c       	ld.w	r12,r3++
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	2c 08       	sub	r8,-64
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	2c 3c       	sub	r12,-61
800035cc:	00 00       	add	r0,r0
800035ce:	07 34       	ld.ub	r4,r3++
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	2b ec       	sub	r12,-66
800035d4:	00 00       	add	r0,r0
800035d6:	07 24       	ld.uh	r4,r3++
800035d8:	80 00       	ld.sh	r0,r0[0x0]
800035da:	35 28       	mov	r8,82

800035dc <dip204_example_configure_joystick_IT>:
	Enable_global_interrupt();
}


void dip204_example_configure_joystick_IT(void)
{
800035dc:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_UP , GPIO_FALLING_EDGE);
800035e0:	30 2b       	mov	r11,2
800035e2:	31 ac       	mov	r12,26
800035e4:	f0 1f 00 18 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_DOWN , GPIO_FALLING_EDGE);
800035e8:	30 2b       	mov	r11,2
800035ea:	31 bc       	mov	r12,27
800035ec:	f0 1f 00 16 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_RIGHT , GPIO_FALLING_EDGE);
800035f0:	30 2b       	mov	r11,2
800035f2:	31 cc       	mov	r12,28
800035f4:	f0 1f 00 14 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_PUSH , GPIO_FALLING_EDGE);
800035f8:	30 2b       	mov	r11,2
800035fa:	31 4c       	mov	r12,20
800035fc:	f0 1f 00 12 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_LEFT , GPIO_FALLING_EDGE);
80003600:	30 2b       	mov	r11,2
80003602:	31 9c       	mov	r12,25
80003604:	f0 1f 00 10 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>

	/* Disable all interrupts */
	Disable_global_interrupt();
80003608:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_UP/8), AVR32_INTC_INT1);
8000360a:	49 07       	lddpc	r7,80003648 <dip204_example_configure_joystick_IT+0x6c>
8000360c:	30 1a       	mov	r10,1
8000360e:	34 3b       	mov	r11,67
80003610:	0e 9c       	mov	r12,r7
80003612:	f0 1f 00 0f 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_DOWN/8), AVR32_INTC_INT1);
80003616:	30 1a       	mov	r10,1
80003618:	34 3b       	mov	r11,67
8000361a:	0e 9c       	mov	r12,r7
8000361c:	f0 1f 00 0c 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_RIGHT/8), AVR32_INTC_INT1);
80003620:	30 1a       	mov	r10,1
80003622:	34 3b       	mov	r11,67
80003624:	0e 9c       	mov	r12,r7
80003626:	f0 1f 00 0a 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_LEFT/8), AVR32_INTC_INT1);
8000362a:	30 1a       	mov	r10,1
8000362c:	34 3b       	mov	r11,67
8000362e:	0e 9c       	mov	r12,r7
80003630:	f0 1f 00 07 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_PUSH/8), AVR32_INTC_INT1);
80003634:	30 1a       	mov	r10,1
80003636:	34 2b       	mov	r11,66
80003638:	0e 9c       	mov	r12,r7
8000363a:	f0 1f 00 05 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	/* Enable all interrupts */
	Enable_global_interrupt();
8000363e:	d5 03       	csrf	0x10
}
80003640:	e3 cd 80 80 	ldm	sp++,r7,pc
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	26 70       	sub	r0,103
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	37 e4       	mov	r4,126
8000364c:	80 00       	ld.sh	r0,r0[0x0]
8000364e:	26 e8       	sub	r8,110

80003650 <dip204_example_configure_push_buttons_IT>:
	}
}


void dip204_example_configure_push_buttons_IT(void)
{
80003650:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_CHARSET , GPIO_RISING_EDGE);
80003654:	30 1b       	mov	r11,1
80003656:	35 8c       	mov	r12,88
80003658:	f0 1f 00 0f 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_PLUS , GPIO_RISING_EDGE);
8000365c:	30 1b       	mov	r11,1
8000365e:	35 2c       	mov	r12,82
80003660:	f0 1f 00 0d 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_MINUS , GPIO_RISING_EDGE);
80003664:	30 1b       	mov	r11,1
80003666:	35 5c       	mov	r12,85
80003668:	f0 1f 00 0b 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	/* Disable all interrupts */
	Disable_global_interrupt();
8000366c:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_PLUS/8), AVR32_INTC_INT1);
8000366e:	48 b7       	lddpc	r7,80003698 <dip204_example_configure_push_buttons_IT+0x48>
80003670:	30 1a       	mov	r10,1
80003672:	34 ab       	mov	r11,74
80003674:	0e 9c       	mov	r12,r7
80003676:	f0 1f 00 0a 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_MINUS/8), AVR32_INTC_INT1);
8000367a:	30 1a       	mov	r10,1
8000367c:	34 ab       	mov	r11,74
8000367e:	0e 9c       	mov	r12,r7
80003680:	f0 1f 00 07 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_CHARSET/8), AVR32_INTC_INT1);
80003684:	30 1a       	mov	r10,1
80003686:	34 bb       	mov	r11,75
80003688:	0e 9c       	mov	r12,r7
8000368a:	f0 1f 00 05 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	/* Enable all interrupts */
	Enable_global_interrupt();
8000368e:	d5 03       	csrf	0x10
}
80003690:	e3 cd 80 80 	ldm	sp++,r7,pc
80003694:	80 00       	ld.sh	r0,r0[0x0]
80003696:	26 70       	sub	r0,103
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	38 c8       	mov	r8,-116
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	26 e8       	sub	r8,110

800036a0 <main>:


#include <asf.h>

int main(void)
{	
800036a0:	d4 31       	pushm	r0-r7,lr
800036a2:	20 5d       	sub	sp,20
	static volatile ioport_port_mask_t port_val;
	volatile int MainState = 0;
800036a4:	30 06       	mov	r6,0
800036a6:	50 46       	stdsp	sp[0x10],r6
		{DIP204_SPI_MOSI_PIN, DIP204_SPI_MOSI_FUNCTION},  // MOSI.
		{DIP204_SPI_NPCS_PIN, DIP204_SPI_NPCS_FUNCTION}   // Chip Select NPCS.
	};

	// Switch the CPU main clock to oscillator 0
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
800036a8:	30 3a       	mov	r10,3
800036aa:	e0 6b 1b 00 	mov	r11,6912
800036ae:	ea 1b 00 b7 	orh	r11,0xb7
800036b2:	fe 7c 0c 00 	mov	r12,-62464
800036b6:	f0 1f 00 38 	mcall	80003794 <main+0xf4>

	// Disable all interrupts.
	Disable_global_interrupt();
800036ba:	d3 03       	ssrf	0x10

	// init the interrupts
	INTC_init_interrupts();
800036bc:	f0 1f 00 37 	mcall	80003798 <main+0xf8>

	// Enable all interrupts.
	Enable_global_interrupt();
800036c0:	d5 03       	csrf	0x10
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800036c2:	4b 78       	lddpc	r8,8000379c <main+0xfc>
800036c4:	f0 ea 00 00 	ld.d	r10,r8[0]
800036c8:	fa eb 00 00 	st.d	sp[0],r10
800036cc:	f0 e8 00 08 	ld.d	r8,r8[8]
800036d0:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
800036d4:	30 4b       	mov	r11,4
800036d6:	4b 3c       	lddpc	r12,800037a0 <main+0x100>
800036d8:	f0 1f 00 33 	mcall	800037a4 <main+0x104>
	sizeof(DIP204_SPI_GPIO_MAP) / sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as master
	spi_initMaster(DIP204_SPI, &spiOptions);
800036dc:	1a 9b       	mov	r11,sp
800036de:	fe 7c 28 00 	mov	r12,-55296
800036e2:	f0 1f 00 32 	mcall	800037a8 <main+0x108>

	// Set selection mode: variable_ps, pcs_decode, delay
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
800036e6:	0c 99       	mov	r9,r6
800036e8:	0c 9a       	mov	r10,r6
800036ea:	0c 9b       	mov	r11,r6
800036ec:	fe 7c 28 00 	mov	r12,-55296
800036f0:	f0 1f 00 2f 	mcall	800037ac <main+0x10c>

	// Enable SPI
	spi_enable(DIP204_SPI);
800036f4:	fe 7c 28 00 	mov	r12,-55296
800036f8:	f0 1f 00 2e 	mcall	800037b0 <main+0x110>

	// setup chip registers
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800036fc:	e0 6a 1b 00 	mov	r10,6912
80003700:	ea 1a 00 b7 	orh	r10,0xb7
80003704:	1a 9b       	mov	r11,sp
80003706:	fe 7c 28 00 	mov	r12,-55296
8000370a:	f0 1f 00 2b 	mcall	800037b4 <main+0x114>

	// configure local push buttons
	dip204_example_configure_push_buttons_IT();
8000370e:	f0 1f 00 2b 	mcall	800037b8 <main+0x118>

	// configure local joystick
	dip204_example_configure_joystick_IT();
80003712:	f0 1f 00 2b 	mcall	800037bc <main+0x11c>

	// initialize delay driver
	delay_init( FOSC0 );

	// initialize LCD
	dip204_init(backlight_PWM, true);
80003716:	30 1b       	mov	r11,1
80003718:	16 9c       	mov	r12,r11
8000371a:	f0 1f 00 2a 	mcall	800037c0 <main+0x120>

	// reset marker
	current_char = 0x10;
8000371e:	31 09       	mov	r9,16
80003720:	4a 98       	lddpc	r8,800037c4 <main+0x124>
80003722:	b0 09       	st.h	r8[0x0],r9

	// berschrift
	dip204_set_cursor_position(4,1);
80003724:	30 1b       	mov	r11,1
80003726:	30 4c       	mov	r12,4
80003728:	f0 1f 00 28 	mcall	800037c8 <main+0x128>
	dip204_write_string("Ueberschrift");
8000372c:	4a 8c       	lddpc	r12,800037cc <main+0x12c>
8000372e:	f0 1f 00 29 	mcall	800037d0 <main+0x130>
	
	// kein Cursor mehr
	dip204_hide_cursor();
80003732:	f0 1f 00 29 	mcall	800037d4 <main+0x134>
}

__always_inline static ioport_port_mask_t arch_ioport_get_port_level(
		ioport_port_t port, ioport_port_mask_t mask)
{
	return arch_ioport_port_to_base(port)->pvr & mask;
80003736:	fe 76 12 00 	mov	r6,-60928
	
	/* do a loop */
	while (1)
	{
		// gesamten Port einlesen
		port_val = ioport_get_port_level(EXAMPLE_BUTTON_PORT, EXAMPLE_BUTTON_MASK);
8000373a:	4a 87       	lddpc	r7,800037d8 <main+0x138>
				}
				break;
			
			case 10:
				if (port_val != 0x0240000)
				{	dip204_set_cursor_position(1,2);
8000373c:	30 25       	mov	r5,2
8000373e:	30 14       	mov	r4,1
					dip204_write_string("Taste0 losgelassen");
80003740:	4a 73       	lddpc	r3,800037dc <main+0x13c>
					MainState = 0;
80003742:	30 02       	mov	r2,0
		switch (MainState)
		{
			case 0:
				if (port_val == 0x0240000)
				{	dip204_set_cursor_position(1,2);
					dip204_write_string("Taste0 gedrueckt");
80003744:	4a 71       	lddpc	r1,800037e0 <main+0x140>
					MainState = 10;
80003746:	30 a0       	mov	r0,10
80003748:	6d 88       	ld.w	r8,r6[0x60]
8000374a:	e6 18 01 24 	andh	r8,0x124,COH
	
	/* do a loop */
	while (1)
	{
		// gesamten Port einlesen
		port_val = ioport_get_port_level(EXAMPLE_BUTTON_PORT, EXAMPLE_BUTTON_MASK);
8000374e:	8f 08       	st.w	r7[0x0],r8

		switch (MainState)
80003750:	40 48       	lddsp	r8,sp[0x10]
80003752:	58 08       	cp.w	r8,0
80003754:	c0 40       	breq	8000375c <main+0xbc>
80003756:	58 a8       	cp.w	r8,10
80003758:	cf 81       	brne	80003748 <main+0xa8>
8000375a:	c0 f8       	rjmp	80003778 <main+0xd8>
		{
			case 0:
				if (port_val == 0x0240000)
8000375c:	6e 08       	ld.w	r8,r7[0x0]
8000375e:	fc 19 00 24 	movh	r9,0x24
80003762:	12 38       	cp.w	r8,r9
80003764:	cf 21       	brne	80003748 <main+0xa8>
				{	dip204_set_cursor_position(1,2);
80003766:	0a 9b       	mov	r11,r5
80003768:	08 9c       	mov	r12,r4
8000376a:	f0 1f 00 18 	mcall	800037c8 <main+0x128>
					dip204_write_string("Taste0 gedrueckt");
8000376e:	02 9c       	mov	r12,r1
80003770:	f0 1f 00 18 	mcall	800037d0 <main+0x130>
					MainState = 10;
80003774:	50 40       	stdsp	sp[0x10],r0
80003776:	ce 9b       	rjmp	80003748 <main+0xa8>
				}
				break;
			
			case 10:
				if (port_val != 0x0240000)
80003778:	6e 08       	ld.w	r8,r7[0x0]
8000377a:	fc 19 00 24 	movh	r9,0x24
8000377e:	12 38       	cp.w	r8,r9
80003780:	ce 40       	breq	80003748 <main+0xa8>
				{	dip204_set_cursor_position(1,2);
80003782:	0a 9b       	mov	r11,r5
80003784:	08 9c       	mov	r12,r4
80003786:	f0 1f 00 11 	mcall	800037c8 <main+0x128>
					dip204_write_string("Taste0 losgelassen");
8000378a:	06 9c       	mov	r12,r3
8000378c:	f0 1f 00 11 	mcall	800037d0 <main+0x130>
					MainState = 0;
80003790:	50 42       	stdsp	sp[0x10],r2
80003792:	cd bb       	rjmp	80003748 <main+0xa8>
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	28 80       	sub	r0,-120
80003798:	80 00       	ld.sh	r0,r0[0x0]
8000379a:	27 68       	sub	r8,118
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	47 30       	lddsp	r0,sp[0x1cc]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	46 b8       	lddsp	r8,sp[0x1ac]
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	26 08       	sub	r8,96
800037a8:	80 00       	ld.sh	r0,r0[0x0]
800037aa:	29 92       	sub	r2,-103
800037ac:	80 00       	ld.sh	r0,r0[0x0]
800037ae:	29 ca       	sub	r10,-100
800037b0:	80 00       	ld.sh	r0,r0[0x0]
800037b2:	29 f6       	sub	r6,-97
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	2a 38       	sub	r8,-93
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	36 50       	mov	r0,101
800037bc:	80 00       	ld.sh	r0,r0[0x0]
800037be:	35 dc       	mov	r12,93
800037c0:	80 00       	ld.sh	r0,r0[0x0]
800037c2:	23 70       	sub	r0,55
800037c4:	00 00       	add	r0,r0
800037c6:	07 4c       	ld.w	r12,--r3
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	22 24       	sub	r4,34
800037cc:	80 00       	ld.sh	r0,r0[0x0]
800037ce:	46 d8       	lddsp	r8,sp[0x1b4]
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	21 cc       	sub	r12,28
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	22 b4       	sub	r4,43
800037d8:	00 00       	add	r0,r0
800037da:	07 50       	ld.sh	r0,--r3
800037dc:	80 00       	ld.sh	r0,r0[0x0]
800037de:	46 fc       	lddsp	r12,sp[0x1bc]
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	46 e8       	lddsp	r8,sp[0x1b8]

800037e4 <dip204_example_Joy_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_Joy_int_handler(void)
{
800037e4:	d4 01       	pushm	lr
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_UP))
800037e6:	31 ac       	mov	r12,26
800037e8:	f0 1f 00 31 	mcall	800038ac <dip204_example_Joy_int_handler+0xc8>
800037ec:	c0 f0       	breq	8000380a <dip204_example_Joy_int_handler+0x26>
	{
		dip204_set_cursor_position(19,1);
800037ee:	30 1b       	mov	r11,1
800037f0:	31 3c       	mov	r12,19
800037f2:	f0 1f 00 30 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDE);
800037f6:	e0 6c 00 de 	mov	r12,222
800037fa:	f0 1f 00 2f 	mcall	800038b4 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
800037fe:	30 19       	mov	r9,1
80003800:	4a e8       	lddpc	r8,800038b8 <dip204_example_Joy_int_handler+0xd4>
80003802:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_UP);
80003804:	31 ac       	mov	r12,26
80003806:	f0 1f 00 2e 	mcall	800038bc <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_DOWN))
8000380a:	31 bc       	mov	r12,27
8000380c:	f0 1f 00 28 	mcall	800038ac <dip204_example_Joy_int_handler+0xc8>
80003810:	c0 f0       	breq	8000382e <dip204_example_Joy_int_handler+0x4a>
	{
		dip204_set_cursor_position(19,3);
80003812:	30 3b       	mov	r11,3
80003814:	31 3c       	mov	r12,19
80003816:	f0 1f 00 27 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE0);
8000381a:	e0 6c 00 e0 	mov	r12,224
8000381e:	f0 1f 00 26 	mcall	800038b4 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
80003822:	30 19       	mov	r9,1
80003824:	4a 58       	lddpc	r8,800038b8 <dip204_example_Joy_int_handler+0xd4>
80003826:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_DOWN);
80003828:	31 bc       	mov	r12,27
8000382a:	f0 1f 00 25 	mcall	800038bc <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_LEFT))
8000382e:	31 9c       	mov	r12,25
80003830:	f0 1f 00 1f 	mcall	800038ac <dip204_example_Joy_int_handler+0xc8>
80003834:	c0 f0       	breq	80003852 <dip204_example_Joy_int_handler+0x6e>
	{
		dip204_set_cursor_position(18,2);
80003836:	30 2b       	mov	r11,2
80003838:	31 2c       	mov	r12,18
8000383a:	f0 1f 00 1e 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE1);
8000383e:	e0 6c 00 e1 	mov	r12,225
80003842:	f0 1f 00 1d 	mcall	800038b4 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
80003846:	30 19       	mov	r9,1
80003848:	49 c8       	lddpc	r8,800038b8 <dip204_example_Joy_int_handler+0xd4>
8000384a:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_LEFT);
8000384c:	31 9c       	mov	r12,25
8000384e:	f0 1f 00 1c 	mcall	800038bc <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT))
80003852:	31 cc       	mov	r12,28
80003854:	f0 1f 00 16 	mcall	800038ac <dip204_example_Joy_int_handler+0xc8>
80003858:	c0 f0       	breq	80003876 <dip204_example_Joy_int_handler+0x92>
	{
		dip204_set_cursor_position(20,2);
8000385a:	30 2b       	mov	r11,2
8000385c:	31 4c       	mov	r12,20
8000385e:	f0 1f 00 15 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDF);
80003862:	e0 6c 00 df 	mov	r12,223
80003866:	f0 1f 00 14 	mcall	800038b4 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
8000386a:	30 19       	mov	r9,1
8000386c:	49 38       	lddpc	r8,800038b8 <dip204_example_Joy_int_handler+0xd4>
8000386e:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT);
80003870:	31 cc       	mov	r12,28
80003872:	f0 1f 00 13 	mcall	800038bc <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_PUSH))
80003876:	31 4c       	mov	r12,20
80003878:	f0 1f 00 0d 	mcall	800038ac <dip204_example_Joy_int_handler+0xc8>
8000387c:	c1 60       	breq	800038a8 <dip204_example_Joy_int_handler+0xc4>
	{
		dip204_set_cursor_position(19,2);
8000387e:	30 2b       	mov	r11,2
80003880:	31 3c       	mov	r12,19
80003882:	f0 1f 00 0c 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xBB);
80003886:	e0 6c 00 bb 	mov	r12,187
8000388a:	f0 1f 00 0b 	mcall	800038b4 <dip204_example_Joy_int_handler+0xd0>
		dip204_set_cursor_position(1,4);
8000388e:	30 4b       	mov	r11,4
80003890:	30 1c       	mov	r12,1
80003892:	f0 1f 00 08 	mcall	800038b0 <dip204_example_Joy_int_handler+0xcc>
		dip204_write_string("  AT32UC3A Series   ");
80003896:	48 bc       	lddpc	r12,800038c0 <dip204_example_Joy_int_handler+0xdc>
80003898:	f0 1f 00 0b 	mcall	800038c4 <dip204_example_Joy_int_handler+0xe0>
		display = 1;
8000389c:	30 19       	mov	r9,1
8000389e:	48 78       	lddpc	r8,800038b8 <dip204_example_Joy_int_handler+0xd4>
800038a0:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_PUSH);
800038a2:	31 4c       	mov	r12,20
800038a4:	f0 1f 00 06 	mcall	800038bc <dip204_example_Joy_int_handler+0xd8>
	}
}
800038a8:	d4 02       	popm	lr
800038aa:	d6 03       	rete
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	26 b6       	sub	r6,107
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	22 24       	sub	r4,34
800038b4:	80 00       	ld.sh	r0,r0[0x0]
800038b6:	22 80       	sub	r0,40
800038b8:	00 00       	add	r0,r0
800038ba:	07 90       	ld.ub	r0,r3[0x1]
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	26 ce       	sub	lr,108
800038c0:	80 00       	ld.sh	r0,r0[0x0]
800038c2:	47 10       	lddsp	r0,sp[0x1c4]
800038c4:	80 00       	ld.sh	r0,r0[0x0]
800038c6:	21 cc       	sub	r12,28

800038c8 <dip204_example_PB_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_PB_int_handler(void)
{
800038c8:	eb cd 40 c0 	pushm	r6-r7,lr
	unsigned short i;

	/* display all available chars */
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
800038cc:	35 8c       	mov	r12,88
800038ce:	f0 1f 00 23 	mcall	80003958 <dip204_example_PB_int_handler+0x90>
800038d2:	c2 b0       	breq	80003928 <dip204_example_PB_int_handler+0x60>
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
800038d4:	30 4b       	mov	r11,4
800038d6:	30 1c       	mov	r12,1
800038d8:	f0 1f 00 21 	mcall	8000395c <dip204_example_PB_int_handler+0x94>
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
800038dc:	4a 18       	lddpc	r8,80003960 <dip204_example_PB_int_handler+0x98>
800038de:	90 07       	ld.sh	r7,r8[0x0]
800038e0:	0e 98       	mov	r8,r7
800038e2:	5c 78       	castu.h	r8
800038e4:	f0 c9 ff f0 	sub	r9,r8,-16
800038e8:	12 38       	cp.w	r8,r9
800038ea:	c0 e4       	brge	80003906 <dip204_example_PB_int_handler+0x3e>
800038ec:	49 d6       	lddpc	r6,80003960 <dip204_example_PB_int_handler+0x98>
		{
			dip204_write_data(i);
800038ee:	0e 9c       	mov	r12,r7
800038f0:	5c 5c       	castu.b	r12
800038f2:	f0 1f 00 1d 	mcall	80003964 <dip204_example_PB_int_handler+0x9c>
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
800038f6:	2f f7       	sub	r7,-1
800038f8:	5c 87       	casts.h	r7
800038fa:	0e 99       	mov	r9,r7
800038fc:	5c 79       	castu.h	r9
800038fe:	8c 88       	ld.uh	r8,r6[0x0]
80003900:	2f 08       	sub	r8,-16
80003902:	10 39       	cp.w	r9,r8
80003904:	cf 55       	brlt	800038ee <dip204_example_PB_int_handler+0x26>
		{
			dip204_write_data(i);
		}
		dip204_write_string("    ");
80003906:	49 9c       	lddpc	r12,80003968 <dip204_example_PB_int_handler+0xa0>
80003908:	f0 1f 00 19 	mcall	8000396c <dip204_example_PB_int_handler+0xa4>
		/* mark position in charmap */
		current_char = i;
8000390c:	49 58       	lddpc	r8,80003960 <dip204_example_PB_int_handler+0x98>
8000390e:	b0 07       	st.h	r8[0x0],r7
		/* reset marker */
		if (current_char >= 0xFF)
80003910:	e0 68 00 fe 	mov	r8,254
80003914:	f0 07 19 00 	cp.h	r7,r8
80003918:	e0 88 00 05 	brls	80003922 <dip204_example_PB_int_handler+0x5a>
		{
			current_char = 0x10;
8000391c:	31 09       	mov	r9,16
8000391e:	49 18       	lddpc	r8,80003960 <dip204_example_PB_int_handler+0x98>
80003920:	b0 09       	st.h	r8[0x0],r9
		}
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_CHARSET);
80003922:	35 8c       	mov	r12,88
80003924:	f0 1f 00 13 	mcall	80003970 <dip204_example_PB_int_handler+0xa8>
	}
	/* increase backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS))
80003928:	35 2c       	mov	r12,82
8000392a:	f0 1f 00 0c 	mcall	80003958 <dip204_example_PB_int_handler+0x90>
8000392e:	c0 70       	breq	8000393c <dip204_example_PB_int_handler+0x74>
	{
		dip204_set_backlight(backlight_power_increase);
80003930:	30 0c       	mov	r12,0
80003932:	f0 1f 00 11 	mcall	80003974 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS);
80003936:	35 2c       	mov	r12,82
80003938:	f0 1f 00 0e 	mcall	80003970 <dip204_example_PB_int_handler+0xa8>
	}
	/* decrease backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS))
8000393c:	35 5c       	mov	r12,85
8000393e:	f0 1f 00 07 	mcall	80003958 <dip204_example_PB_int_handler+0x90>
80003942:	c0 70       	breq	80003950 <dip204_example_PB_int_handler+0x88>
	{
		dip204_set_backlight(backlight_power_decrease);
80003944:	30 1c       	mov	r12,1
80003946:	f0 1f 00 0c 	mcall	80003974 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS);
8000394a:	35 5c       	mov	r12,85
8000394c:	f0 1f 00 09 	mcall	80003970 <dip204_example_PB_int_handler+0xa8>
	}
}
80003950:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
80003954:	d6 03       	rete
80003956:	00 00       	add	r0,r0
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	26 b6       	sub	r6,107
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	22 24       	sub	r4,34
80003960:	00 00       	add	r0,r0
80003962:	07 4c       	ld.w	r12,--r3
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	22 80       	sub	r0,40
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	47 28       	lddsp	r8,sp[0x1c8]
8000396c:	80 00       	ld.sh	r0,r0[0x0]
8000396e:	21 cc       	sub	r12,28
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	26 ce       	sub	lr,108
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	22 e4       	sub	r4,46

80003978 <atexit>:
80003978:	d4 01       	pushm	lr
8000397a:	30 09       	mov	r9,0
8000397c:	18 9b       	mov	r11,r12
8000397e:	12 9a       	mov	r10,r9
80003980:	12 9c       	mov	r12,r9
80003982:	e0 a0 03 17 	rcall	80003fb0 <__register_exitproc>
80003986:	d8 02       	popm	pc

80003988 <exit>:
80003988:	d4 21       	pushm	r4-r7,lr
8000398a:	30 0b       	mov	r11,0
8000398c:	18 97       	mov	r7,r12
8000398e:	e0 a0 03 63 	rcall	80004054 <__call_exitprocs>
80003992:	fe c8 f2 4e 	sub	r8,pc,-3506
80003996:	70 0c       	ld.w	r12,r8[0x0]
80003998:	78 a8       	ld.w	r8,r12[0x28]
8000399a:	58 08       	cp.w	r8,0
8000399c:	c0 20       	breq	800039a0 <exit+0x18>
8000399e:	5d 18       	icall	r8
800039a0:	0e 9c       	mov	r12,r7
800039a2:	e0 a0 02 e6 	rcall	80003f6e <_exit>
800039a6:	d7 03       	nop

800039a8 <free>:
800039a8:	d4 01       	pushm	lr
800039aa:	e0 68 01 18 	mov	r8,280
800039ae:	18 9b       	mov	r11,r12
800039b0:	70 0c       	ld.w	r12,r8[0x0]
800039b2:	e0 a0 04 05 	rcall	800041bc <_free_r>
800039b6:	d8 02       	popm	pc

800039b8 <malloc>:
800039b8:	d4 01       	pushm	lr
800039ba:	e0 68 01 18 	mov	r8,280
800039be:	18 9b       	mov	r11,r12
800039c0:	70 0c       	ld.w	r12,r8[0x0]
800039c2:	c0 3c       	rcall	800039c8 <_malloc_r>
800039c4:	d8 02       	popm	pc
800039c6:	d7 03       	nop

800039c8 <_malloc_r>:
800039c8:	d4 31       	pushm	r0-r7,lr
800039ca:	f6 c8 ff f5 	sub	r8,r11,-11
800039ce:	18 95       	mov	r5,r12
800039d0:	10 97       	mov	r7,r8
800039d2:	e0 17 ff f8 	andl	r7,0xfff8
800039d6:	59 68       	cp.w	r8,22
800039d8:	f9 b7 08 10 	movls	r7,16
800039dc:	16 37       	cp.w	r7,r11
800039de:	5f 38       	srlo	r8
800039e0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800039e4:	c0 50       	breq	800039ee <_malloc_r+0x26>
800039e6:	30 c8       	mov	r8,12
800039e8:	99 38       	st.w	r12[0xc],r8
800039ea:	e0 8f 01 f8 	bral	80003dda <_malloc_r+0x412>
800039ee:	fe b0 f9 9f 	rcall	80002d2c <__malloc_lock>
800039f2:	e0 47 01 f7 	cp.w	r7,503
800039f6:	e0 8b 00 1d 	brhi	80003a30 <_malloc_r+0x68>
800039fa:	ee 03 16 03 	lsr	r3,r7,0x3
800039fe:	e0 68 01 1c 	mov	r8,284
80003a02:	f0 03 00 38 	add	r8,r8,r3<<0x3
80003a06:	70 36       	ld.w	r6,r8[0xc]
80003a08:	10 36       	cp.w	r6,r8
80003a0a:	c0 61       	brne	80003a16 <_malloc_r+0x4e>
80003a0c:	ec c8 ff f8 	sub	r8,r6,-8
80003a10:	70 36       	ld.w	r6,r8[0xc]
80003a12:	10 36       	cp.w	r6,r8
80003a14:	c0 c0       	breq	80003a2c <_malloc_r+0x64>
80003a16:	6c 18       	ld.w	r8,r6[0x4]
80003a18:	e0 18 ff fc 	andl	r8,0xfffc
80003a1c:	6c 3a       	ld.w	r10,r6[0xc]
80003a1e:	ec 08 00 09 	add	r9,r6,r8
80003a22:	0a 9c       	mov	r12,r5
80003a24:	6c 28       	ld.w	r8,r6[0x8]
80003a26:	95 28       	st.w	r10[0x8],r8
80003a28:	91 3a       	st.w	r8[0xc],r10
80003a2a:	c4 78       	rjmp	80003ab8 <_malloc_r+0xf0>
80003a2c:	2f e3       	sub	r3,-2
80003a2e:	c4 d8       	rjmp	80003ac8 <_malloc_r+0x100>
80003a30:	ee 03 16 09 	lsr	r3,r7,0x9
80003a34:	c0 41       	brne	80003a3c <_malloc_r+0x74>
80003a36:	ee 03 16 03 	lsr	r3,r7,0x3
80003a3a:	c2 68       	rjmp	80003a86 <_malloc_r+0xbe>
80003a3c:	58 43       	cp.w	r3,4
80003a3e:	e0 8b 00 06 	brhi	80003a4a <_malloc_r+0x82>
80003a42:	ee 03 16 06 	lsr	r3,r7,0x6
80003a46:	2c 83       	sub	r3,-56
80003a48:	c1 f8       	rjmp	80003a86 <_malloc_r+0xbe>
80003a4a:	59 43       	cp.w	r3,20
80003a4c:	e0 8b 00 04 	brhi	80003a54 <_malloc_r+0x8c>
80003a50:	2a 53       	sub	r3,-91
80003a52:	c1 a8       	rjmp	80003a86 <_malloc_r+0xbe>
80003a54:	e0 43 00 54 	cp.w	r3,84
80003a58:	e0 8b 00 06 	brhi	80003a64 <_malloc_r+0x9c>
80003a5c:	ee 03 16 0c 	lsr	r3,r7,0xc
80003a60:	29 23       	sub	r3,-110
80003a62:	c1 28       	rjmp	80003a86 <_malloc_r+0xbe>
80003a64:	e0 43 01 54 	cp.w	r3,340
80003a68:	e0 8b 00 06 	brhi	80003a74 <_malloc_r+0xac>
80003a6c:	ee 03 16 0f 	lsr	r3,r7,0xf
80003a70:	28 93       	sub	r3,-119
80003a72:	c0 a8       	rjmp	80003a86 <_malloc_r+0xbe>
80003a74:	e0 43 05 54 	cp.w	r3,1364
80003a78:	e0 88 00 04 	brls	80003a80 <_malloc_r+0xb8>
80003a7c:	37 e3       	mov	r3,126
80003a7e:	c0 48       	rjmp	80003a86 <_malloc_r+0xbe>
80003a80:	ee 03 16 12 	lsr	r3,r7,0x12
80003a84:	28 43       	sub	r3,-124
80003a86:	e0 6a 01 1c 	mov	r10,284
80003a8a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80003a8e:	74 36       	ld.w	r6,r10[0xc]
80003a90:	c1 98       	rjmp	80003ac2 <_malloc_r+0xfa>
80003a92:	6c 19       	ld.w	r9,r6[0x4]
80003a94:	e0 19 ff fc 	andl	r9,0xfffc
80003a98:	f2 07 01 0b 	sub	r11,r9,r7
80003a9c:	58 fb       	cp.w	r11,15
80003a9e:	e0 8a 00 04 	brle	80003aa6 <_malloc_r+0xde>
80003aa2:	20 13       	sub	r3,1
80003aa4:	c1 18       	rjmp	80003ac6 <_malloc_r+0xfe>
80003aa6:	6c 38       	ld.w	r8,r6[0xc]
80003aa8:	58 0b       	cp.w	r11,0
80003aaa:	c0 b5       	brlt	80003ac0 <_malloc_r+0xf8>
80003aac:	6c 2a       	ld.w	r10,r6[0x8]
80003aae:	ec 09 00 09 	add	r9,r6,r9
80003ab2:	0a 9c       	mov	r12,r5
80003ab4:	91 2a       	st.w	r8[0x8],r10
80003ab6:	95 38       	st.w	r10[0xc],r8
80003ab8:	72 18       	ld.w	r8,r9[0x4]
80003aba:	a1 a8       	sbr	r8,0x0
80003abc:	93 18       	st.w	r9[0x4],r8
80003abe:	cb c8       	rjmp	80003c36 <_malloc_r+0x26e>
80003ac0:	10 96       	mov	r6,r8
80003ac2:	14 36       	cp.w	r6,r10
80003ac4:	ce 71       	brne	80003a92 <_malloc_r+0xca>
80003ac6:	2f f3       	sub	r3,-1
80003ac8:	e0 6a 01 1c 	mov	r10,284
80003acc:	f4 cc ff f8 	sub	r12,r10,-8
80003ad0:	78 26       	ld.w	r6,r12[0x8]
80003ad2:	18 36       	cp.w	r6,r12
80003ad4:	c6 c0       	breq	80003bac <_malloc_r+0x1e4>
80003ad6:	6c 19       	ld.w	r9,r6[0x4]
80003ad8:	e0 19 ff fc 	andl	r9,0xfffc
80003adc:	f2 07 01 08 	sub	r8,r9,r7
80003ae0:	58 f8       	cp.w	r8,15
80003ae2:	e0 89 00 8f 	brgt	80003c00 <_malloc_r+0x238>
80003ae6:	99 3c       	st.w	r12[0xc],r12
80003ae8:	99 2c       	st.w	r12[0x8],r12
80003aea:	58 08       	cp.w	r8,0
80003aec:	c0 55       	brlt	80003af6 <_malloc_r+0x12e>
80003aee:	ec 09 00 09 	add	r9,r6,r9
80003af2:	0a 9c       	mov	r12,r5
80003af4:	ce 2b       	rjmp	80003ab8 <_malloc_r+0xf0>
80003af6:	e0 49 01 ff 	cp.w	r9,511
80003afa:	e0 8b 00 13 	brhi	80003b20 <_malloc_r+0x158>
80003afe:	a3 99       	lsr	r9,0x3
80003b00:	f4 09 00 38 	add	r8,r10,r9<<0x3
80003b04:	70 2b       	ld.w	r11,r8[0x8]
80003b06:	8d 38       	st.w	r6[0xc],r8
80003b08:	8d 2b       	st.w	r6[0x8],r11
80003b0a:	97 36       	st.w	r11[0xc],r6
80003b0c:	91 26       	st.w	r8[0x8],r6
80003b0e:	a3 49       	asr	r9,0x2
80003b10:	74 18       	ld.w	r8,r10[0x4]
80003b12:	30 1b       	mov	r11,1
80003b14:	f6 09 09 49 	lsl	r9,r11,r9
80003b18:	f1 e9 10 09 	or	r9,r8,r9
80003b1c:	95 19       	st.w	r10[0x4],r9
80003b1e:	c4 78       	rjmp	80003bac <_malloc_r+0x1e4>
80003b20:	f2 0a 16 09 	lsr	r10,r9,0x9
80003b24:	58 4a       	cp.w	r10,4
80003b26:	e0 8b 00 07 	brhi	80003b34 <_malloc_r+0x16c>
80003b2a:	f2 0a 16 06 	lsr	r10,r9,0x6
80003b2e:	2c 8a       	sub	r10,-56
80003b30:	c2 08       	rjmp	80003b70 <_malloc_r+0x1a8>
80003b32:	d7 03       	nop
80003b34:	59 4a       	cp.w	r10,20
80003b36:	e0 8b 00 04 	brhi	80003b3e <_malloc_r+0x176>
80003b3a:	2a 5a       	sub	r10,-91
80003b3c:	c1 a8       	rjmp	80003b70 <_malloc_r+0x1a8>
80003b3e:	e0 4a 00 54 	cp.w	r10,84
80003b42:	e0 8b 00 06 	brhi	80003b4e <_malloc_r+0x186>
80003b46:	f2 0a 16 0c 	lsr	r10,r9,0xc
80003b4a:	29 2a       	sub	r10,-110
80003b4c:	c1 28       	rjmp	80003b70 <_malloc_r+0x1a8>
80003b4e:	e0 4a 01 54 	cp.w	r10,340
80003b52:	e0 8b 00 06 	brhi	80003b5e <_malloc_r+0x196>
80003b56:	f2 0a 16 0f 	lsr	r10,r9,0xf
80003b5a:	28 9a       	sub	r10,-119
80003b5c:	c0 a8       	rjmp	80003b70 <_malloc_r+0x1a8>
80003b5e:	e0 4a 05 54 	cp.w	r10,1364
80003b62:	e0 88 00 04 	brls	80003b6a <_malloc_r+0x1a2>
80003b66:	37 ea       	mov	r10,126
80003b68:	c0 48       	rjmp	80003b70 <_malloc_r+0x1a8>
80003b6a:	f2 0a 16 12 	lsr	r10,r9,0x12
80003b6e:	28 4a       	sub	r10,-124
80003b70:	e0 6b 01 1c 	mov	r11,284
80003b74:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80003b78:	68 28       	ld.w	r8,r4[0x8]
80003b7a:	08 38       	cp.w	r8,r4
80003b7c:	c0 e1       	brne	80003b98 <_malloc_r+0x1d0>
80003b7e:	76 19       	ld.w	r9,r11[0x4]
80003b80:	a3 4a       	asr	r10,0x2
80003b82:	30 1e       	mov	lr,1
80003b84:	fc 0a 09 4a 	lsl	r10,lr,r10
80003b88:	f3 ea 10 0a 	or	r10,r9,r10
80003b8c:	10 99       	mov	r9,r8
80003b8e:	97 1a       	st.w	r11[0x4],r10
80003b90:	c0 a8       	rjmp	80003ba4 <_malloc_r+0x1dc>
80003b92:	70 28       	ld.w	r8,r8[0x8]
80003b94:	08 38       	cp.w	r8,r4
80003b96:	c0 60       	breq	80003ba2 <_malloc_r+0x1da>
80003b98:	70 1a       	ld.w	r10,r8[0x4]
80003b9a:	e0 1a ff fc 	andl	r10,0xfffc
80003b9e:	14 39       	cp.w	r9,r10
80003ba0:	cf 93       	brcs	80003b92 <_malloc_r+0x1ca>
80003ba2:	70 39       	ld.w	r9,r8[0xc]
80003ba4:	8d 39       	st.w	r6[0xc],r9
80003ba6:	8d 28       	st.w	r6[0x8],r8
80003ba8:	91 36       	st.w	r8[0xc],r6
80003baa:	93 26       	st.w	r9[0x8],r6
80003bac:	e6 08 14 02 	asr	r8,r3,0x2
80003bb0:	30 1b       	mov	r11,1
80003bb2:	e0 64 01 1c 	mov	r4,284
80003bb6:	f6 08 09 4b 	lsl	r11,r11,r8
80003bba:	68 18       	ld.w	r8,r4[0x4]
80003bbc:	10 3b       	cp.w	r11,r8
80003bbe:	e0 8b 00 6b 	brhi	80003c94 <_malloc_r+0x2cc>
80003bc2:	f7 e8 00 09 	and	r9,r11,r8
80003bc6:	c0 b1       	brne	80003bdc <_malloc_r+0x214>
80003bc8:	e0 13 ff fc 	andl	r3,0xfffc
80003bcc:	a1 7b       	lsl	r11,0x1
80003bce:	2f c3       	sub	r3,-4
80003bd0:	c0 38       	rjmp	80003bd6 <_malloc_r+0x20e>
80003bd2:	2f c3       	sub	r3,-4
80003bd4:	a1 7b       	lsl	r11,0x1
80003bd6:	f7 e8 00 09 	and	r9,r11,r8
80003bda:	cf c0       	breq	80003bd2 <_malloc_r+0x20a>
80003bdc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80003be0:	06 92       	mov	r2,r3
80003be2:	1c 91       	mov	r1,lr
80003be4:	62 36       	ld.w	r6,r1[0xc]
80003be6:	c2 e8       	rjmp	80003c42 <_malloc_r+0x27a>
80003be8:	6c 1a       	ld.w	r10,r6[0x4]
80003bea:	e0 1a ff fc 	andl	r10,0xfffc
80003bee:	f4 07 01 08 	sub	r8,r10,r7
80003bf2:	58 f8       	cp.w	r8,15
80003bf4:	e0 8a 00 15 	brle	80003c1e <_malloc_r+0x256>
80003bf8:	6c 3a       	ld.w	r10,r6[0xc]
80003bfa:	6c 29       	ld.w	r9,r6[0x8]
80003bfc:	95 29       	st.w	r10[0x8],r9
80003bfe:	93 3a       	st.w	r9[0xc],r10
80003c00:	0e 99       	mov	r9,r7
80003c02:	ec 07 00 07 	add	r7,r6,r7
80003c06:	a1 a9       	sbr	r9,0x0
80003c08:	99 37       	st.w	r12[0xc],r7
80003c0a:	99 27       	st.w	r12[0x8],r7
80003c0c:	8d 19       	st.w	r6[0x4],r9
80003c0e:	ee 08 09 08 	st.w	r7[r8],r8
80003c12:	8f 2c       	st.w	r7[0x8],r12
80003c14:	8f 3c       	st.w	r7[0xc],r12
80003c16:	a1 a8       	sbr	r8,0x0
80003c18:	0a 9c       	mov	r12,r5
80003c1a:	8f 18       	st.w	r7[0x4],r8
80003c1c:	c0 d8       	rjmp	80003c36 <_malloc_r+0x26e>
80003c1e:	6c 39       	ld.w	r9,r6[0xc]
80003c20:	58 08       	cp.w	r8,0
80003c22:	c0 f5       	brlt	80003c40 <_malloc_r+0x278>
80003c24:	ec 0a 00 0a 	add	r10,r6,r10
80003c28:	74 18       	ld.w	r8,r10[0x4]
80003c2a:	a1 a8       	sbr	r8,0x0
80003c2c:	0a 9c       	mov	r12,r5
80003c2e:	95 18       	st.w	r10[0x4],r8
80003c30:	6c 28       	ld.w	r8,r6[0x8]
80003c32:	93 28       	st.w	r9[0x8],r8
80003c34:	91 39       	st.w	r8[0xc],r9
80003c36:	fe b0 f8 81 	rcall	80002d38 <__malloc_unlock>
80003c3a:	ec cc ff f8 	sub	r12,r6,-8
80003c3e:	d8 32       	popm	r0-r7,pc
80003c40:	12 96       	mov	r6,r9
80003c42:	02 36       	cp.w	r6,r1
80003c44:	cd 21       	brne	80003be8 <_malloc_r+0x220>
80003c46:	2f f2       	sub	r2,-1
80003c48:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80003c4c:	c0 30       	breq	80003c52 <_malloc_r+0x28a>
80003c4e:	2f 81       	sub	r1,-8
80003c50:	cc ab       	rjmp	80003be4 <_malloc_r+0x21c>
80003c52:	1c 98       	mov	r8,lr
80003c54:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80003c58:	c0 81       	brne	80003c68 <_malloc_r+0x2a0>
80003c5a:	68 19       	ld.w	r9,r4[0x4]
80003c5c:	f6 08 11 ff 	rsub	r8,r11,-1
80003c60:	f3 e8 00 08 	and	r8,r9,r8
80003c64:	89 18       	st.w	r4[0x4],r8
80003c66:	c0 78       	rjmp	80003c74 <_malloc_r+0x2ac>
80003c68:	f0 c9 00 08 	sub	r9,r8,8
80003c6c:	20 13       	sub	r3,1
80003c6e:	70 08       	ld.w	r8,r8[0x0]
80003c70:	12 38       	cp.w	r8,r9
80003c72:	cf 10       	breq	80003c54 <_malloc_r+0x28c>
80003c74:	a1 7b       	lsl	r11,0x1
80003c76:	68 18       	ld.w	r8,r4[0x4]
80003c78:	10 3b       	cp.w	r11,r8
80003c7a:	e0 8b 00 0d 	brhi	80003c94 <_malloc_r+0x2cc>
80003c7e:	58 0b       	cp.w	r11,0
80003c80:	c0 a0       	breq	80003c94 <_malloc_r+0x2cc>
80003c82:	04 93       	mov	r3,r2
80003c84:	c0 38       	rjmp	80003c8a <_malloc_r+0x2c2>
80003c86:	2f c3       	sub	r3,-4
80003c88:	a1 7b       	lsl	r11,0x1
80003c8a:	f7 e8 00 09 	and	r9,r11,r8
80003c8e:	ca 71       	brne	80003bdc <_malloc_r+0x214>
80003c90:	cf bb       	rjmp	80003c86 <_malloc_r+0x2be>
80003c92:	d7 03       	nop
80003c94:	68 23       	ld.w	r3,r4[0x8]
80003c96:	66 12       	ld.w	r2,r3[0x4]
80003c98:	e0 12 ff fc 	andl	r2,0xfffc
80003c9c:	0e 32       	cp.w	r2,r7
80003c9e:	5f 39       	srlo	r9
80003ca0:	e4 07 01 08 	sub	r8,r2,r7
80003ca4:	58 f8       	cp.w	r8,15
80003ca6:	5f aa       	srle	r10
80003ca8:	f5 e9 10 09 	or	r9,r10,r9
80003cac:	e0 80 00 98 	breq	80003ddc <_malloc_r+0x414>
80003cb0:	e0 68 07 5c 	mov	r8,1884
80003cb4:	70 01       	ld.w	r1,r8[0x0]
80003cb6:	e0 68 05 28 	mov	r8,1320
80003cba:	2f 01       	sub	r1,-16
80003cbc:	70 08       	ld.w	r8,r8[0x0]
80003cbe:	0e 01       	add	r1,r7
80003cc0:	5b f8       	cp.w	r8,-1
80003cc2:	c0 40       	breq	80003cca <_malloc_r+0x302>
80003cc4:	28 11       	sub	r1,-127
80003cc6:	e0 11 ff 80 	andl	r1,0xff80
80003cca:	02 9b       	mov	r11,r1
80003ccc:	0a 9c       	mov	r12,r5
80003cce:	c3 bd       	rcall	80003f44 <_sbrk_r>
80003cd0:	18 96       	mov	r6,r12
80003cd2:	5b fc       	cp.w	r12,-1
80003cd4:	c7 40       	breq	80003dbc <_malloc_r+0x3f4>
80003cd6:	e6 02 00 08 	add	r8,r3,r2
80003cda:	10 3c       	cp.w	r12,r8
80003cdc:	c0 32       	brcc	80003ce2 <_malloc_r+0x31a>
80003cde:	08 33       	cp.w	r3,r4
80003ce0:	c6 e1       	brne	80003dbc <_malloc_r+0x3f4>
80003ce2:	e0 6a 07 60 	mov	r10,1888
80003ce6:	74 09       	ld.w	r9,r10[0x0]
80003ce8:	e2 09 00 09 	add	r9,r1,r9
80003cec:	95 09       	st.w	r10[0x0],r9
80003cee:	10 36       	cp.w	r6,r8
80003cf0:	c0 a1       	brne	80003d04 <_malloc_r+0x33c>
80003cf2:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80003cf6:	c0 71       	brne	80003d04 <_malloc_r+0x33c>
80003cf8:	e2 02 00 02 	add	r2,r1,r2
80003cfc:	68 28       	ld.w	r8,r4[0x8]
80003cfe:	a1 a2       	sbr	r2,0x0
80003d00:	91 12       	st.w	r8[0x4],r2
80003d02:	c4 e8       	rjmp	80003d9e <_malloc_r+0x3d6>
80003d04:	e0 6a 05 28 	mov	r10,1320
80003d08:	74 0b       	ld.w	r11,r10[0x0]
80003d0a:	5b fb       	cp.w	r11,-1
80003d0c:	c0 31       	brne	80003d12 <_malloc_r+0x34a>
80003d0e:	95 06       	st.w	r10[0x0],r6
80003d10:	c0 78       	rjmp	80003d1e <_malloc_r+0x356>
80003d12:	ec 09 00 09 	add	r9,r6,r9
80003d16:	e0 6a 07 60 	mov	r10,1888
80003d1a:	10 19       	sub	r9,r8
80003d1c:	95 09       	st.w	r10[0x0],r9
80003d1e:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80003d22:	f0 09 11 08 	rsub	r9,r8,8
80003d26:	58 08       	cp.w	r8,0
80003d28:	f2 08 17 10 	movne	r8,r9
80003d2c:	ed d8 e1 06 	addne	r6,r6,r8
80003d30:	28 08       	sub	r8,-128
80003d32:	ec 01 00 01 	add	r1,r6,r1
80003d36:	0a 9c       	mov	r12,r5
80003d38:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80003d3c:	f0 01 01 01 	sub	r1,r8,r1
80003d40:	02 9b       	mov	r11,r1
80003d42:	c0 1d       	rcall	80003f44 <_sbrk_r>
80003d44:	e0 68 07 60 	mov	r8,1888
80003d48:	5b fc       	cp.w	r12,-1
80003d4a:	ec 0c 17 00 	moveq	r12,r6
80003d4e:	f9 b1 00 00 	moveq	r1,0
80003d52:	70 09       	ld.w	r9,r8[0x0]
80003d54:	0c 1c       	sub	r12,r6
80003d56:	89 26       	st.w	r4[0x8],r6
80003d58:	02 0c       	add	r12,r1
80003d5a:	12 01       	add	r1,r9
80003d5c:	a1 ac       	sbr	r12,0x0
80003d5e:	91 01       	st.w	r8[0x0],r1
80003d60:	8d 1c       	st.w	r6[0x4],r12
80003d62:	08 33       	cp.w	r3,r4
80003d64:	c1 d0       	breq	80003d9e <_malloc_r+0x3d6>
80003d66:	58 f2       	cp.w	r2,15
80003d68:	e0 8b 00 05 	brhi	80003d72 <_malloc_r+0x3aa>
80003d6c:	30 18       	mov	r8,1
80003d6e:	8d 18       	st.w	r6[0x4],r8
80003d70:	c2 68       	rjmp	80003dbc <_malloc_r+0x3f4>
80003d72:	30 59       	mov	r9,5
80003d74:	20 c2       	sub	r2,12
80003d76:	e0 12 ff f8 	andl	r2,0xfff8
80003d7a:	e6 02 00 08 	add	r8,r3,r2
80003d7e:	91 29       	st.w	r8[0x8],r9
80003d80:	91 19       	st.w	r8[0x4],r9
80003d82:	66 18       	ld.w	r8,r3[0x4]
80003d84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003d88:	e5 e8 10 08 	or	r8,r2,r8
80003d8c:	87 18       	st.w	r3[0x4],r8
80003d8e:	58 f2       	cp.w	r2,15
80003d90:	e0 88 00 07 	brls	80003d9e <_malloc_r+0x3d6>
80003d94:	e6 cb ff f8 	sub	r11,r3,-8
80003d98:	0a 9c       	mov	r12,r5
80003d9a:	e0 a0 02 11 	rcall	800041bc <_free_r>
80003d9e:	e0 69 07 58 	mov	r9,1880
80003da2:	72 0a       	ld.w	r10,r9[0x0]
80003da4:	e0 68 07 60 	mov	r8,1888
80003da8:	70 08       	ld.w	r8,r8[0x0]
80003daa:	14 38       	cp.w	r8,r10
80003dac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003db0:	e0 69 07 54 	mov	r9,1876
80003db4:	72 0a       	ld.w	r10,r9[0x0]
80003db6:	14 38       	cp.w	r8,r10
80003db8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003dbc:	68 28       	ld.w	r8,r4[0x8]
80003dbe:	70 18       	ld.w	r8,r8[0x4]
80003dc0:	e0 18 ff fc 	andl	r8,0xfffc
80003dc4:	0e 38       	cp.w	r8,r7
80003dc6:	5f 39       	srlo	r9
80003dc8:	0e 18       	sub	r8,r7
80003dca:	58 f8       	cp.w	r8,15
80003dcc:	5f aa       	srle	r10
80003dce:	f5 e9 10 09 	or	r9,r10,r9
80003dd2:	c0 50       	breq	80003ddc <_malloc_r+0x414>
80003dd4:	0a 9c       	mov	r12,r5
80003dd6:	fe b0 f7 b1 	rcall	80002d38 <__malloc_unlock>
80003dda:	d8 3a       	popm	r0-r7,pc,r12=0
80003ddc:	68 26       	ld.w	r6,r4[0x8]
80003dde:	a1 a8       	sbr	r8,0x0
80003de0:	0e 99       	mov	r9,r7
80003de2:	a1 a9       	sbr	r9,0x0
80003de4:	8d 19       	st.w	r6[0x4],r9
80003de6:	ec 07 00 07 	add	r7,r6,r7
80003dea:	0a 9c       	mov	r12,r5
80003dec:	89 27       	st.w	r4[0x8],r7
80003dee:	8f 18       	st.w	r7[0x4],r8
80003df0:	fe b0 f7 a4 	rcall	80002d38 <__malloc_unlock>
80003df4:	ec cc ff f8 	sub	r12,r6,-8
80003df8:	d8 32       	popm	r0-r7,pc
80003dfa:	d7 03       	nop

80003dfc <memcpy>:
80003dfc:	58 8a       	cp.w	r10,8
80003dfe:	c2 f5       	brlt	80003e5c <memcpy+0x60>
80003e00:	f9 eb 10 09 	or	r9,r12,r11
80003e04:	e2 19 00 03 	andl	r9,0x3,COH
80003e08:	e0 81 00 97 	brne	80003f36 <memcpy+0x13a>
80003e0c:	e0 4a 00 20 	cp.w	r10,32
80003e10:	c3 b4       	brge	80003e86 <memcpy+0x8a>
80003e12:	f4 08 14 02 	asr	r8,r10,0x2
80003e16:	f0 09 11 08 	rsub	r9,r8,8
80003e1a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80003e1e:	76 69       	ld.w	r9,r11[0x18]
80003e20:	99 69       	st.w	r12[0x18],r9
80003e22:	76 59       	ld.w	r9,r11[0x14]
80003e24:	99 59       	st.w	r12[0x14],r9
80003e26:	76 49       	ld.w	r9,r11[0x10]
80003e28:	99 49       	st.w	r12[0x10],r9
80003e2a:	76 39       	ld.w	r9,r11[0xc]
80003e2c:	99 39       	st.w	r12[0xc],r9
80003e2e:	76 29       	ld.w	r9,r11[0x8]
80003e30:	99 29       	st.w	r12[0x8],r9
80003e32:	76 19       	ld.w	r9,r11[0x4]
80003e34:	99 19       	st.w	r12[0x4],r9
80003e36:	76 09       	ld.w	r9,r11[0x0]
80003e38:	99 09       	st.w	r12[0x0],r9
80003e3a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80003e3e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80003e42:	e0 1a 00 03 	andl	r10,0x3
80003e46:	f4 0a 11 04 	rsub	r10,r10,4
80003e4a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003e4e:	17 a9       	ld.ub	r9,r11[0x2]
80003e50:	b0 a9       	st.b	r8[0x2],r9
80003e52:	17 99       	ld.ub	r9,r11[0x1]
80003e54:	b0 99       	st.b	r8[0x1],r9
80003e56:	17 89       	ld.ub	r9,r11[0x0]
80003e58:	b0 89       	st.b	r8[0x0],r9
80003e5a:	5e fc       	retal	r12
80003e5c:	f4 0a 11 09 	rsub	r10,r10,9
80003e60:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003e64:	17 f9       	ld.ub	r9,r11[0x7]
80003e66:	b8 f9       	st.b	r12[0x7],r9
80003e68:	17 e9       	ld.ub	r9,r11[0x6]
80003e6a:	b8 e9       	st.b	r12[0x6],r9
80003e6c:	17 d9       	ld.ub	r9,r11[0x5]
80003e6e:	b8 d9       	st.b	r12[0x5],r9
80003e70:	17 c9       	ld.ub	r9,r11[0x4]
80003e72:	b8 c9       	st.b	r12[0x4],r9
80003e74:	17 b9       	ld.ub	r9,r11[0x3]
80003e76:	b8 b9       	st.b	r12[0x3],r9
80003e78:	17 a9       	ld.ub	r9,r11[0x2]
80003e7a:	b8 a9       	st.b	r12[0x2],r9
80003e7c:	17 99       	ld.ub	r9,r11[0x1]
80003e7e:	b8 99       	st.b	r12[0x1],r9
80003e80:	17 89       	ld.ub	r9,r11[0x0]
80003e82:	b8 89       	st.b	r12[0x0],r9
80003e84:	5e fc       	retal	r12
80003e86:	eb cd 40 c0 	pushm	r6-r7,lr
80003e8a:	18 99       	mov	r9,r12
80003e8c:	22 0a       	sub	r10,32
80003e8e:	b7 07       	ld.d	r6,r11++
80003e90:	b3 26       	st.d	r9++,r6
80003e92:	b7 07       	ld.d	r6,r11++
80003e94:	b3 26       	st.d	r9++,r6
80003e96:	b7 07       	ld.d	r6,r11++
80003e98:	b3 26       	st.d	r9++,r6
80003e9a:	b7 07       	ld.d	r6,r11++
80003e9c:	b3 26       	st.d	r9++,r6
80003e9e:	22 0a       	sub	r10,32
80003ea0:	cf 74       	brge	80003e8e <memcpy+0x92>
80003ea2:	2f 0a       	sub	r10,-16
80003ea4:	c0 65       	brlt	80003eb0 <memcpy+0xb4>
80003ea6:	b7 07       	ld.d	r6,r11++
80003ea8:	b3 26       	st.d	r9++,r6
80003eaa:	b7 07       	ld.d	r6,r11++
80003eac:	b3 26       	st.d	r9++,r6
80003eae:	21 0a       	sub	r10,16
80003eb0:	5c 3a       	neg	r10
80003eb2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80003eb6:	d7 03       	nop
80003eb8:	d7 03       	nop
80003eba:	f7 36 00 0e 	ld.ub	r6,r11[14]
80003ebe:	f3 66 00 0e 	st.b	r9[14],r6
80003ec2:	f7 36 00 0d 	ld.ub	r6,r11[13]
80003ec6:	f3 66 00 0d 	st.b	r9[13],r6
80003eca:	f7 36 00 0c 	ld.ub	r6,r11[12]
80003ece:	f3 66 00 0c 	st.b	r9[12],r6
80003ed2:	f7 36 00 0b 	ld.ub	r6,r11[11]
80003ed6:	f3 66 00 0b 	st.b	r9[11],r6
80003eda:	f7 36 00 0a 	ld.ub	r6,r11[10]
80003ede:	f3 66 00 0a 	st.b	r9[10],r6
80003ee2:	f7 36 00 09 	ld.ub	r6,r11[9]
80003ee6:	f3 66 00 09 	st.b	r9[9],r6
80003eea:	f7 36 00 08 	ld.ub	r6,r11[8]
80003eee:	f3 66 00 08 	st.b	r9[8],r6
80003ef2:	f7 36 00 07 	ld.ub	r6,r11[7]
80003ef6:	f3 66 00 07 	st.b	r9[7],r6
80003efa:	f7 36 00 06 	ld.ub	r6,r11[6]
80003efe:	f3 66 00 06 	st.b	r9[6],r6
80003f02:	f7 36 00 05 	ld.ub	r6,r11[5]
80003f06:	f3 66 00 05 	st.b	r9[5],r6
80003f0a:	f7 36 00 04 	ld.ub	r6,r11[4]
80003f0e:	f3 66 00 04 	st.b	r9[4],r6
80003f12:	f7 36 00 03 	ld.ub	r6,r11[3]
80003f16:	f3 66 00 03 	st.b	r9[3],r6
80003f1a:	f7 36 00 02 	ld.ub	r6,r11[2]
80003f1e:	f3 66 00 02 	st.b	r9[2],r6
80003f22:	f7 36 00 01 	ld.ub	r6,r11[1]
80003f26:	f3 66 00 01 	st.b	r9[1],r6
80003f2a:	f7 36 00 00 	ld.ub	r6,r11[0]
80003f2e:	f3 66 00 00 	st.b	r9[0],r6
80003f32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003f36:	20 1a       	sub	r10,1
80003f38:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80003f3c:	f8 0a 0b 09 	st.b	r12[r10],r9
80003f40:	cf b1       	brne	80003f36 <memcpy+0x13a>
80003f42:	5e fc       	retal	r12

80003f44 <_sbrk_r>:
80003f44:	d4 21       	pushm	r4-r7,lr
80003f46:	30 08       	mov	r8,0
80003f48:	18 97       	mov	r7,r12
80003f4a:	e0 66 07 94 	mov	r6,1940
80003f4e:	16 9c       	mov	r12,r11
80003f50:	8d 08       	st.w	r6[0x0],r8
80003f52:	c1 3c       	rcall	80003f78 <_sbrk>
80003f54:	5b fc       	cp.w	r12,-1
80003f56:	c0 51       	brne	80003f60 <_sbrk_r+0x1c>
80003f58:	6c 08       	ld.w	r8,r6[0x0]
80003f5a:	58 08       	cp.w	r8,0
80003f5c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80003f60:	d8 22       	popm	r4-r7,pc
80003f62:	d7 03       	nop

80003f64 <_init_argv>:
80003f64:	30 e8       	mov	r8,14
80003f66:	d6 73       	breakpoint
80003f68:	3f fc       	mov	r12,-1
80003f6a:	35 8b       	mov	r11,88
80003f6c:	5e fc       	retal	r12

80003f6e <_exit>:
80003f6e:	30 d8       	mov	r8,13
80003f70:	d6 73       	breakpoint
80003f72:	3f fc       	mov	r12,-1
80003f74:	35 8b       	mov	r11,88
80003f76:	c0 08       	rjmp	80003f76 <_exit+0x8>

80003f78 <_sbrk>:
80003f78:	d4 01       	pushm	lr
80003f7a:	e0 68 07 88 	mov	r8,1928
80003f7e:	70 09       	ld.w	r9,r8[0x0]
80003f80:	58 09       	cp.w	r9,0
80003f82:	c0 41       	brne	80003f8a <_sbrk+0x12>
80003f84:	e0 69 07 98 	mov	r9,1944
80003f88:	91 09       	st.w	r8[0x0],r9
80003f8a:	e0 69 07 88 	mov	r9,1928
80003f8e:	e0 6a f0 00 	mov	r10,61440
80003f92:	72 08       	ld.w	r8,r9[0x0]
80003f94:	f0 0c 00 0c 	add	r12,r8,r12
80003f98:	14 3c       	cp.w	r12,r10
80003f9a:	e0 8b 00 04 	brhi	80003fa2 <_sbrk+0x2a>
80003f9e:	93 0c       	st.w	r9[0x0],r12
80003fa0:	c0 58       	rjmp	80003faa <_sbrk+0x32>
80003fa2:	cb fc       	rcall	80004120 <__errno>
80003fa4:	30 c8       	mov	r8,12
80003fa6:	99 08       	st.w	r12[0x0],r8
80003fa8:	3f f8       	mov	r8,-1
80003faa:	10 9c       	mov	r12,r8
80003fac:	d8 02       	popm	pc
80003fae:	d7 03       	nop

80003fb0 <__register_exitproc>:
80003fb0:	d4 31       	pushm	r0-r7,lr
80003fb2:	fe c8 f8 6e 	sub	r8,pc,-1938
80003fb6:	70 03       	ld.w	r3,r8[0x0]
80003fb8:	67 24       	ld.w	r4,r3[0x48]
80003fba:	e6 c8 ff b4 	sub	r8,r3,-76
80003fbe:	58 04       	cp.w	r4,0
80003fc0:	f0 04 17 00 	moveq	r4,r8
80003fc4:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80003fc8:	18 97       	mov	r7,r12
80003fca:	16 96       	mov	r6,r11
80003fcc:	14 95       	mov	r5,r10
80003fce:	12 92       	mov	r2,r9
80003fd0:	68 18       	ld.w	r8,r4[0x4]
80003fd2:	59 f8       	cp.w	r8,31
80003fd4:	e0 8a 00 0e 	brle	80003ff0 <__register_exitproc+0x40>
80003fd8:	e0 6c 00 8c 	mov	r12,140
80003fdc:	fe b0 fc ee 	rcall	800039b8 <malloc>
80003fe0:	18 94       	mov	r4,r12
80003fe2:	c3 80       	breq	80004052 <__register_exitproc+0xa2>
80003fe4:	67 28       	ld.w	r8,r3[0x48]
80003fe6:	99 08       	st.w	r12[0x0],r8
80003fe8:	e7 4c 00 48 	st.w	r3[72],r12
80003fec:	30 08       	mov	r8,0
80003fee:	99 18       	st.w	r12[0x4],r8
80003ff0:	58 07       	cp.w	r7,0
80003ff2:	c2 70       	breq	80004040 <__register_exitproc+0x90>
80003ff4:	e8 fc 00 88 	ld.w	r12,r4[136]
80003ff8:	58 0c       	cp.w	r12,0
80003ffa:	c0 d1       	brne	80004014 <__register_exitproc+0x64>
80003ffc:	e0 6c 01 08 	mov	r12,264
80004000:	fe b0 fc dc 	rcall	800039b8 <malloc>
80004004:	c2 70       	breq	80004052 <__register_exitproc+0xa2>
80004006:	30 08       	mov	r8,0
80004008:	e9 4c 00 88 	st.w	r4[136],r12
8000400c:	f9 48 01 04 	st.w	r12[260],r8
80004010:	f9 48 01 00 	st.w	r12[256],r8
80004014:	68 18       	ld.w	r8,r4[0x4]
80004016:	f0 c9 ff e0 	sub	r9,r8,-32
8000401a:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000401e:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80004022:	30 1a       	mov	r10,1
80004024:	f8 f9 01 00 	ld.w	r9,r12[256]
80004028:	f4 08 09 48 	lsl	r8,r10,r8
8000402c:	10 49       	or	r9,r8
8000402e:	f9 49 01 00 	st.w	r12[256],r9
80004032:	58 27       	cp.w	r7,2
80004034:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004038:	f3 d8 e0 38 	oreq	r8,r9,r8
8000403c:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80004040:	68 18       	ld.w	r8,r4[0x4]
80004042:	30 0c       	mov	r12,0
80004044:	f0 c9 ff ff 	sub	r9,r8,-1
80004048:	2f e8       	sub	r8,-2
8000404a:	89 19       	st.w	r4[0x4],r9
8000404c:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80004050:	d8 32       	popm	r0-r7,pc
80004052:	dc 3a       	popm	r0-r7,pc,r12=-1

80004054 <__call_exitprocs>:
80004054:	d4 31       	pushm	r0-r7,lr
80004056:	20 3d       	sub	sp,12
80004058:	fe c8 f9 14 	sub	r8,pc,-1772
8000405c:	50 2c       	stdsp	sp[0x8],r12
8000405e:	70 08       	ld.w	r8,r8[0x0]
80004060:	16 91       	mov	r1,r11
80004062:	50 08       	stdsp	sp[0x0],r8
80004064:	2b 88       	sub	r8,-72
80004066:	50 18       	stdsp	sp[0x4],r8
80004068:	40 0a       	lddsp	r10,sp[0x0]
8000406a:	40 14       	lddsp	r4,sp[0x4]
8000406c:	75 27       	ld.w	r7,r10[0x48]
8000406e:	c5 58       	rjmp	80004118 <__call_exitprocs+0xc4>
80004070:	6e 15       	ld.w	r5,r7[0x4]
80004072:	ee f6 00 88 	ld.w	r6,r7[136]
80004076:	ea c2 ff ff 	sub	r2,r5,-1
8000407a:	20 15       	sub	r5,1
8000407c:	ee 02 00 22 	add	r2,r7,r2<<0x2
80004080:	ec 05 00 23 	add	r3,r6,r5<<0x2
80004084:	c3 58       	rjmp	800040ee <__call_exitprocs+0x9a>
80004086:	58 01       	cp.w	r1,0
80004088:	c0 70       	breq	80004096 <__call_exitprocs+0x42>
8000408a:	58 06       	cp.w	r6,0
8000408c:	c2 e0       	breq	800040e8 <__call_exitprocs+0x94>
8000408e:	e6 f8 00 80 	ld.w	r8,r3[128]
80004092:	02 38       	cp.w	r8,r1
80004094:	c2 a1       	brne	800040e8 <__call_exitprocs+0x94>
80004096:	6e 19       	ld.w	r9,r7[0x4]
80004098:	64 08       	ld.w	r8,r2[0x0]
8000409a:	20 19       	sub	r9,1
8000409c:	12 35       	cp.w	r5,r9
8000409e:	ef f5 0a 01 	st.weq	r7[0x4],r5
800040a2:	f9 b9 01 00 	movne	r9,0
800040a6:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800040aa:	58 08       	cp.w	r8,0
800040ac:	c1 e0       	breq	800040e8 <__call_exitprocs+0x94>
800040ae:	6e 10       	ld.w	r0,r7[0x4]
800040b0:	58 06       	cp.w	r6,0
800040b2:	c0 90       	breq	800040c4 <__call_exitprocs+0x70>
800040b4:	30 1a       	mov	r10,1
800040b6:	f4 05 09 49 	lsl	r9,r10,r5
800040ba:	ec fa 01 00 	ld.w	r10,r6[256]
800040be:	f3 ea 00 0a 	and	r10,r9,r10
800040c2:	c0 31       	brne	800040c8 <__call_exitprocs+0x74>
800040c4:	5d 18       	icall	r8
800040c6:	c0 b8       	rjmp	800040dc <__call_exitprocs+0x88>
800040c8:	ec fa 01 04 	ld.w	r10,r6[260]
800040cc:	66 0b       	ld.w	r11,r3[0x0]
800040ce:	14 69       	and	r9,r10
800040d0:	c0 41       	brne	800040d8 <__call_exitprocs+0x84>
800040d2:	40 2c       	lddsp	r12,sp[0x8]
800040d4:	5d 18       	icall	r8
800040d6:	c0 38       	rjmp	800040dc <__call_exitprocs+0x88>
800040d8:	16 9c       	mov	r12,r11
800040da:	5d 18       	icall	r8
800040dc:	6e 18       	ld.w	r8,r7[0x4]
800040de:	10 30       	cp.w	r0,r8
800040e0:	cc 41       	brne	80004068 <__call_exitprocs+0x14>
800040e2:	68 08       	ld.w	r8,r4[0x0]
800040e4:	0e 38       	cp.w	r8,r7
800040e6:	cc 11       	brne	80004068 <__call_exitprocs+0x14>
800040e8:	20 15       	sub	r5,1
800040ea:	20 43       	sub	r3,4
800040ec:	20 42       	sub	r2,4
800040ee:	58 05       	cp.w	r5,0
800040f0:	cc b4       	brge	80004086 <__call_exitprocs+0x32>
800040f2:	6e 18       	ld.w	r8,r7[0x4]
800040f4:	58 08       	cp.w	r8,0
800040f6:	c0 f1       	brne	80004114 <__call_exitprocs+0xc0>
800040f8:	6e 08       	ld.w	r8,r7[0x0]
800040fa:	58 08       	cp.w	r8,0
800040fc:	c0 c0       	breq	80004114 <__call_exitprocs+0xc0>
800040fe:	89 08       	st.w	r4[0x0],r8
80004100:	58 06       	cp.w	r6,0
80004102:	c0 40       	breq	8000410a <__call_exitprocs+0xb6>
80004104:	0c 9c       	mov	r12,r6
80004106:	fe b0 fc 51 	rcall	800039a8 <free>
8000410a:	0e 9c       	mov	r12,r7
8000410c:	fe b0 fc 4e 	rcall	800039a8 <free>
80004110:	68 07       	ld.w	r7,r4[0x0]
80004112:	c0 38       	rjmp	80004118 <__call_exitprocs+0xc4>
80004114:	0e 94       	mov	r4,r7
80004116:	6e 07       	ld.w	r7,r7[0x0]
80004118:	58 07       	cp.w	r7,0
8000411a:	ca b1       	brne	80004070 <__call_exitprocs+0x1c>
8000411c:	2f dd       	sub	sp,-12
8000411e:	d8 32       	popm	r0-r7,pc

80004120 <__errno>:
80004120:	e0 68 01 18 	mov	r8,280
80004124:	70 0c       	ld.w	r12,r8[0x0]
80004126:	2f 4c       	sub	r12,-12
80004128:	5e fc       	retal	r12
8000412a:	d7 03       	nop

8000412c <_malloc_trim_r>:
8000412c:	d4 21       	pushm	r4-r7,lr
8000412e:	16 95       	mov	r5,r11
80004130:	18 97       	mov	r7,r12
80004132:	fe b0 f5 fd 	rcall	80002d2c <__malloc_lock>
80004136:	e0 64 01 1c 	mov	r4,284
8000413a:	68 28       	ld.w	r8,r4[0x8]
8000413c:	70 16       	ld.w	r6,r8[0x4]
8000413e:	e0 16 ff fc 	andl	r6,0xfffc
80004142:	ec c8 ff 91 	sub	r8,r6,-111
80004146:	f0 05 01 05 	sub	r5,r8,r5
8000414a:	e0 15 ff 80 	andl	r5,0xff80
8000414e:	ea c5 00 80 	sub	r5,r5,128
80004152:	e0 45 00 7f 	cp.w	r5,127
80004156:	e0 8a 00 22 	brle	8000419a <_malloc_trim_r+0x6e>
8000415a:	30 0b       	mov	r11,0
8000415c:	0e 9c       	mov	r12,r7
8000415e:	cf 3e       	rcall	80003f44 <_sbrk_r>
80004160:	68 28       	ld.w	r8,r4[0x8]
80004162:	0c 08       	add	r8,r6
80004164:	10 3c       	cp.w	r12,r8
80004166:	c1 a1       	brne	8000419a <_malloc_trim_r+0x6e>
80004168:	ea 0b 11 00 	rsub	r11,r5,0
8000416c:	0e 9c       	mov	r12,r7
8000416e:	ce be       	rcall	80003f44 <_sbrk_r>
80004170:	5b fc       	cp.w	r12,-1
80004172:	c1 81       	brne	800041a2 <_malloc_trim_r+0x76>
80004174:	30 0b       	mov	r11,0
80004176:	0e 9c       	mov	r12,r7
80004178:	ce 6e       	rcall	80003f44 <_sbrk_r>
8000417a:	68 28       	ld.w	r8,r4[0x8]
8000417c:	f8 08 01 09 	sub	r9,r12,r8
80004180:	58 f9       	cp.w	r9,15
80004182:	e0 8a 00 0c 	brle	8000419a <_malloc_trim_r+0x6e>
80004186:	a1 a9       	sbr	r9,0x0
80004188:	91 19       	st.w	r8[0x4],r9
8000418a:	e0 68 05 28 	mov	r8,1320
8000418e:	70 09       	ld.w	r9,r8[0x0]
80004190:	e0 68 07 60 	mov	r8,1888
80004194:	f8 09 01 09 	sub	r9,r12,r9
80004198:	91 09       	st.w	r8[0x0],r9
8000419a:	0e 9c       	mov	r12,r7
8000419c:	fe b0 f5 ce 	rcall	80002d38 <__malloc_unlock>
800041a0:	d8 2a       	popm	r4-r7,pc,r12=0
800041a2:	68 28       	ld.w	r8,r4[0x8]
800041a4:	0a 16       	sub	r6,r5
800041a6:	a1 a6       	sbr	r6,0x0
800041a8:	91 16       	st.w	r8[0x4],r6
800041aa:	e0 68 07 60 	mov	r8,1888
800041ae:	70 09       	ld.w	r9,r8[0x0]
800041b0:	0a 19       	sub	r9,r5
800041b2:	0e 9c       	mov	r12,r7
800041b4:	91 09       	st.w	r8[0x0],r9
800041b6:	fe b0 f5 c1 	rcall	80002d38 <__malloc_unlock>
800041ba:	da 2a       	popm	r4-r7,pc,r12=1

800041bc <_free_r>:
800041bc:	d4 21       	pushm	r4-r7,lr
800041be:	16 96       	mov	r6,r11
800041c0:	18 97       	mov	r7,r12
800041c2:	58 0b       	cp.w	r11,0
800041c4:	e0 80 00 c0 	breq	80004344 <_free_r+0x188>
800041c8:	fe b0 f5 b2 	rcall	80002d2c <__malloc_lock>
800041cc:	20 86       	sub	r6,8
800041ce:	e0 6a 01 1c 	mov	r10,284
800041d2:	6c 18       	ld.w	r8,r6[0x4]
800041d4:	74 2e       	ld.w	lr,r10[0x8]
800041d6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800041da:	a1 c8       	cbr	r8,0x0
800041dc:	ec 08 00 09 	add	r9,r6,r8
800041e0:	72 1b       	ld.w	r11,r9[0x4]
800041e2:	e0 1b ff fc 	andl	r11,0xfffc
800041e6:	1c 39       	cp.w	r9,lr
800041e8:	c1 e1       	brne	80004224 <_free_r+0x68>
800041ea:	f6 08 00 08 	add	r8,r11,r8
800041ee:	58 0c       	cp.w	r12,0
800041f0:	c0 81       	brne	80004200 <_free_r+0x44>
800041f2:	6c 09       	ld.w	r9,r6[0x0]
800041f4:	12 16       	sub	r6,r9
800041f6:	12 08       	add	r8,r9
800041f8:	6c 3b       	ld.w	r11,r6[0xc]
800041fa:	6c 29       	ld.w	r9,r6[0x8]
800041fc:	97 29       	st.w	r11[0x8],r9
800041fe:	93 3b       	st.w	r9[0xc],r11
80004200:	10 99       	mov	r9,r8
80004202:	95 26       	st.w	r10[0x8],r6
80004204:	a1 a9       	sbr	r9,0x0
80004206:	8d 19       	st.w	r6[0x4],r9
80004208:	e0 69 05 24 	mov	r9,1316
8000420c:	72 09       	ld.w	r9,r9[0x0]
8000420e:	12 38       	cp.w	r8,r9
80004210:	c0 63       	brcs	8000421c <_free_r+0x60>
80004212:	e0 68 07 5c 	mov	r8,1884
80004216:	0e 9c       	mov	r12,r7
80004218:	70 0b       	ld.w	r11,r8[0x0]
8000421a:	c8 9f       	rcall	8000412c <_malloc_trim_r>
8000421c:	0e 9c       	mov	r12,r7
8000421e:	fe b0 f5 8d 	rcall	80002d38 <__malloc_unlock>
80004222:	d8 22       	popm	r4-r7,pc
80004224:	93 1b       	st.w	r9[0x4],r11
80004226:	58 0c       	cp.w	r12,0
80004228:	c0 30       	breq	8000422e <_free_r+0x72>
8000422a:	30 0c       	mov	r12,0
8000422c:	c1 08       	rjmp	8000424c <_free_r+0x90>
8000422e:	6c 0e       	ld.w	lr,r6[0x0]
80004230:	f4 c5 ff f8 	sub	r5,r10,-8
80004234:	1c 16       	sub	r6,lr
80004236:	1c 08       	add	r8,lr
80004238:	6c 2e       	ld.w	lr,r6[0x8]
8000423a:	0a 3e       	cp.w	lr,r5
8000423c:	f9 bc 00 01 	moveq	r12,1
80004240:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80004244:	eb fe 1a 02 	st.wne	r5[0x8],lr
80004248:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000424c:	f2 0b 00 0e 	add	lr,r9,r11
80004250:	7c 1e       	ld.w	lr,lr[0x4]
80004252:	ed be 00 00 	bld	lr,0x0
80004256:	c1 40       	breq	8000427e <_free_r+0xc2>
80004258:	16 08       	add	r8,r11
8000425a:	58 0c       	cp.w	r12,0
8000425c:	c0 d1       	brne	80004276 <_free_r+0xba>
8000425e:	e0 6e 01 1c 	mov	lr,284
80004262:	72 2b       	ld.w	r11,r9[0x8]
80004264:	2f 8e       	sub	lr,-8
80004266:	1c 3b       	cp.w	r11,lr
80004268:	c0 71       	brne	80004276 <_free_r+0xba>
8000426a:	97 36       	st.w	r11[0xc],r6
8000426c:	97 26       	st.w	r11[0x8],r6
8000426e:	8d 2b       	st.w	r6[0x8],r11
80004270:	8d 3b       	st.w	r6[0xc],r11
80004272:	30 1c       	mov	r12,1
80004274:	c0 58       	rjmp	8000427e <_free_r+0xc2>
80004276:	72 2b       	ld.w	r11,r9[0x8]
80004278:	72 39       	ld.w	r9,r9[0xc]
8000427a:	93 2b       	st.w	r9[0x8],r11
8000427c:	97 39       	st.w	r11[0xc],r9
8000427e:	10 99       	mov	r9,r8
80004280:	ec 08 09 08 	st.w	r6[r8],r8
80004284:	a1 a9       	sbr	r9,0x0
80004286:	8d 19       	st.w	r6[0x4],r9
80004288:	58 0c       	cp.w	r12,0
8000428a:	c5 a1       	brne	8000433e <_free_r+0x182>
8000428c:	e0 48 01 ff 	cp.w	r8,511
80004290:	e0 8b 00 13 	brhi	800042b6 <_free_r+0xfa>
80004294:	a3 98       	lsr	r8,0x3
80004296:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000429a:	72 2b       	ld.w	r11,r9[0x8]
8000429c:	8d 39       	st.w	r6[0xc],r9
8000429e:	8d 2b       	st.w	r6[0x8],r11
800042a0:	97 36       	st.w	r11[0xc],r6
800042a2:	93 26       	st.w	r9[0x8],r6
800042a4:	a3 48       	asr	r8,0x2
800042a6:	74 19       	ld.w	r9,r10[0x4]
800042a8:	30 1b       	mov	r11,1
800042aa:	f6 08 09 48 	lsl	r8,r11,r8
800042ae:	f3 e8 10 08 	or	r8,r9,r8
800042b2:	95 18       	st.w	r10[0x4],r8
800042b4:	c4 58       	rjmp	8000433e <_free_r+0x182>
800042b6:	f0 0b 16 09 	lsr	r11,r8,0x9
800042ba:	58 4b       	cp.w	r11,4
800042bc:	e0 8b 00 06 	brhi	800042c8 <_free_r+0x10c>
800042c0:	f0 0b 16 06 	lsr	r11,r8,0x6
800042c4:	2c 8b       	sub	r11,-56
800042c6:	c2 08       	rjmp	80004306 <_free_r+0x14a>
800042c8:	59 4b       	cp.w	r11,20
800042ca:	e0 8b 00 04 	brhi	800042d2 <_free_r+0x116>
800042ce:	2a 5b       	sub	r11,-91
800042d0:	c1 b8       	rjmp	80004306 <_free_r+0x14a>
800042d2:	e0 4b 00 54 	cp.w	r11,84
800042d6:	e0 8b 00 06 	brhi	800042e2 <_free_r+0x126>
800042da:	f0 0b 16 0c 	lsr	r11,r8,0xc
800042de:	29 2b       	sub	r11,-110
800042e0:	c1 38       	rjmp	80004306 <_free_r+0x14a>
800042e2:	e0 4b 01 54 	cp.w	r11,340
800042e6:	e0 8b 00 06 	brhi	800042f2 <_free_r+0x136>
800042ea:	f0 0b 16 0f 	lsr	r11,r8,0xf
800042ee:	28 9b       	sub	r11,-119
800042f0:	c0 b8       	rjmp	80004306 <_free_r+0x14a>
800042f2:	e0 4b 05 54 	cp.w	r11,1364
800042f6:	e0 88 00 05 	brls	80004300 <_free_r+0x144>
800042fa:	37 eb       	mov	r11,126
800042fc:	c0 58       	rjmp	80004306 <_free_r+0x14a>
800042fe:	d7 03       	nop
80004300:	f0 0b 16 12 	lsr	r11,r8,0x12
80004304:	28 4b       	sub	r11,-124
80004306:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000430a:	78 29       	ld.w	r9,r12[0x8]
8000430c:	18 39       	cp.w	r9,r12
8000430e:	c0 e1       	brne	8000432a <_free_r+0x16e>
80004310:	74 18       	ld.w	r8,r10[0x4]
80004312:	a3 4b       	asr	r11,0x2
80004314:	30 1c       	mov	r12,1
80004316:	f8 0b 09 4b 	lsl	r11,r12,r11
8000431a:	f1 eb 10 0b 	or	r11,r8,r11
8000431e:	12 98       	mov	r8,r9
80004320:	95 1b       	st.w	r10[0x4],r11
80004322:	c0 a8       	rjmp	80004336 <_free_r+0x17a>
80004324:	72 29       	ld.w	r9,r9[0x8]
80004326:	18 39       	cp.w	r9,r12
80004328:	c0 60       	breq	80004334 <_free_r+0x178>
8000432a:	72 1a       	ld.w	r10,r9[0x4]
8000432c:	e0 1a ff fc 	andl	r10,0xfffc
80004330:	14 38       	cp.w	r8,r10
80004332:	cf 93       	brcs	80004324 <_free_r+0x168>
80004334:	72 38       	ld.w	r8,r9[0xc]
80004336:	8d 38       	st.w	r6[0xc],r8
80004338:	8d 29       	st.w	r6[0x8],r9
8000433a:	93 36       	st.w	r9[0xc],r6
8000433c:	91 26       	st.w	r8[0x8],r6
8000433e:	0e 9c       	mov	r12,r7
80004340:	fe b0 f4 fc 	rcall	80002d38 <__malloc_unlock>
80004344:	d8 22       	popm	r4-r7,pc
80004346:	d7 03       	nop

80004348 <__do_global_ctors_aux>:
80004348:	d4 21       	pushm	r4-r7,lr
8000434a:	30 c7       	mov	r7,12
8000434c:	c0 28       	rjmp	80004350 <__do_global_ctors_aux+0x8>
8000434e:	5d 18       	icall	r8
80004350:	20 47       	sub	r7,4
80004352:	6e 08       	ld.w	r8,r7[0x0]
80004354:	5b f8       	cp.w	r8,-1
80004356:	cf c1       	brne	8000434e <__do_global_ctors_aux+0x6>
80004358:	d8 22       	popm	r4-r7,pc
8000435a:	d7 03       	nop

Disassembly of section .exception:

80004400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80004400:	c0 08       	rjmp	80004400 <_evba>
	...

80004404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80004404:	c0 08       	rjmp	80004404 <_handle_TLB_Multiple_Hit>
	...

80004408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80004408:	c0 08       	rjmp	80004408 <_handle_Bus_Error_Data_Fetch>
	...

8000440c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000440c:	c0 08       	rjmp	8000440c <_handle_Bus_Error_Instruction_Fetch>
	...

80004410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80004410:	c0 08       	rjmp	80004410 <_handle_NMI>
	...

80004414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80004414:	c0 08       	rjmp	80004414 <_handle_Instruction_Address>
	...

80004418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80004418:	c0 08       	rjmp	80004418 <_handle_ITLB_Protection>
	...

8000441c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000441c:	c0 08       	rjmp	8000441c <_handle_Breakpoint>
	...

80004420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80004420:	c0 08       	rjmp	80004420 <_handle_Illegal_Opcode>
	...

80004424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80004424:	c0 08       	rjmp	80004424 <_handle_Unimplemented_Instruction>
	...

80004428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80004428:	c0 08       	rjmp	80004428 <_handle_Privilege_Violation>
	...

8000442c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000442c:	c0 08       	rjmp	8000442c <_handle_Floating_Point>
	...

80004430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80004430:	c0 08       	rjmp	80004430 <_handle_Coprocessor_Absent>
	...

80004434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80004434:	c0 08       	rjmp	80004434 <_handle_Data_Address_Read>
	...

80004438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80004438:	c0 08       	rjmp	80004438 <_handle_Data_Address_Write>
	...

8000443c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000443c:	c0 08       	rjmp	8000443c <_handle_DTLB_Protection_Read>
	...

80004440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80004440:	c0 08       	rjmp	80004440 <_handle_DTLB_Protection_Write>
	...

80004444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80004444:	c0 08       	rjmp	80004444 <_handle_DTLB_Modified>
	...

80004450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80004450:	c0 08       	rjmp	80004450 <_handle_ITLB_Miss>
	...

80004460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80004460:	c0 08       	rjmp	80004460 <_handle_DTLB_Miss_Read>
	...

80004470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80004470:	c0 08       	rjmp	80004470 <_handle_DTLB_Miss_Write>
	...

80004500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80004500:	fe cf 18 8c 	sub	pc,pc,6284

80004504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80004504:	30 0c       	mov	r12,0
80004506:	fe b0 f1 5b 	rcall	800027bc <_get_interrupt_handler>
8000450a:	58 0c       	cp.w	r12,0
8000450c:	f8 0f 17 10 	movne	pc,r12
80004510:	d6 03       	rete

80004512 <_int1>:
80004512:	30 1c       	mov	r12,1
80004514:	fe b0 f1 54 	rcall	800027bc <_get_interrupt_handler>
80004518:	58 0c       	cp.w	r12,0
8000451a:	f8 0f 17 10 	movne	pc,r12
8000451e:	d6 03       	rete

80004520 <_int2>:
80004520:	30 2c       	mov	r12,2
80004522:	fe b0 f1 4d 	rcall	800027bc <_get_interrupt_handler>
80004526:	58 0c       	cp.w	r12,0
80004528:	f8 0f 17 10 	movne	pc,r12
8000452c:	d6 03       	rete

8000452e <_int3>:
8000452e:	30 3c       	mov	r12,3
80004530:	fe b0 f1 46 	rcall	800027bc <_get_interrupt_handler>
80004534:	58 0c       	cp.w	r12,0
80004536:	f8 0f 17 10 	movne	pc,r12
8000453a:	d6 03       	rete
8000453c:	d7 03       	nop
8000453e:	d7 03       	nop
80004540:	d7 03       	nop
80004542:	d7 03       	nop
80004544:	d7 03       	nop
80004546:	d7 03       	nop
80004548:	d7 03       	nop
8000454a:	d7 03       	nop
8000454c:	d7 03       	nop
8000454e:	d7 03       	nop
80004550:	d7 03       	nop
80004552:	d7 03       	nop
80004554:	d7 03       	nop
80004556:	d7 03       	nop
80004558:	d7 03       	nop
8000455a:	d7 03       	nop
8000455c:	d7 03       	nop
8000455e:	d7 03       	nop
80004560:	d7 03       	nop
80004562:	d7 03       	nop
80004564:	d7 03       	nop
80004566:	d7 03       	nop
80004568:	d7 03       	nop
8000456a:	d7 03       	nop
8000456c:	d7 03       	nop
8000456e:	d7 03       	nop
80004570:	d7 03       	nop
80004572:	d7 03       	nop
80004574:	d7 03       	nop
80004576:	d7 03       	nop
80004578:	d7 03       	nop
8000457a:	d7 03       	nop
8000457c:	d7 03       	nop
8000457e:	d7 03       	nop
80004580:	d7 03       	nop
80004582:	d7 03       	nop
80004584:	d7 03       	nop
80004586:	d7 03       	nop
80004588:	d7 03       	nop
8000458a:	d7 03       	nop
8000458c:	d7 03       	nop
8000458e:	d7 03       	nop
80004590:	d7 03       	nop
80004592:	d7 03       	nop
80004594:	d7 03       	nop
80004596:	d7 03       	nop
80004598:	d7 03       	nop
8000459a:	d7 03       	nop
8000459c:	d7 03       	nop
8000459e:	d7 03       	nop
800045a0:	d7 03       	nop
800045a2:	d7 03       	nop
800045a4:	d7 03       	nop
800045a6:	d7 03       	nop
800045a8:	d7 03       	nop
800045aa:	d7 03       	nop
800045ac:	d7 03       	nop
800045ae:	d7 03       	nop
800045b0:	d7 03       	nop
800045b2:	d7 03       	nop
800045b4:	d7 03       	nop
800045b6:	d7 03       	nop
800045b8:	d7 03       	nop
800045ba:	d7 03       	nop
800045bc:	d7 03       	nop
800045be:	d7 03       	nop
800045c0:	d7 03       	nop
800045c2:	d7 03       	nop
800045c4:	d7 03       	nop
800045c6:	d7 03       	nop
800045c8:	d7 03       	nop
800045ca:	d7 03       	nop
800045cc:	d7 03       	nop
800045ce:	d7 03       	nop
800045d0:	d7 03       	nop
800045d2:	d7 03       	nop
800045d4:	d7 03       	nop
800045d6:	d7 03       	nop
800045d8:	d7 03       	nop
800045da:	d7 03       	nop
800045dc:	d7 03       	nop
800045de:	d7 03       	nop
800045e0:	d7 03       	nop
800045e2:	d7 03       	nop
800045e4:	d7 03       	nop
800045e6:	d7 03       	nop
800045e8:	d7 03       	nop
800045ea:	d7 03       	nop
800045ec:	d7 03       	nop
800045ee:	d7 03       	nop
800045f0:	d7 03       	nop
800045f2:	d7 03       	nop
800045f4:	d7 03       	nop
800045f6:	d7 03       	nop
800045f8:	d7 03       	nop
800045fa:	d7 03       	nop
800045fc:	d7 03       	nop
800045fe:	d7 03       	nop

Disassembly of section .fini:

80004600 <_fini>:
80004600:	eb cd 40 40 	pushm	r6,lr
80004604:	48 26       	lddpc	r6,8000460c <_fini+0xc>
80004606:	1e 26       	rsub	r6,pc
80004608:	c0 48       	rjmp	80004610 <_fini+0x10>
8000460a:	d7 03       	nop
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	45 ea       	lddsp	r10,sp[0x178]
80004610:	fe b0 ed 3c 	rcall	80002088 <__do_global_dtors_aux>
80004614:	e3 cd 80 40 	ldm	sp++,r6,pc
