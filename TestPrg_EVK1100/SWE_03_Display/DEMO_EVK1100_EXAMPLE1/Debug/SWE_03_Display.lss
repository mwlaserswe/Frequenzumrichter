
SWE_03_Display.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002450  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80004600  80004600  00004a00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80004800  80004800  00004c00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000184  80004818  80004818  00004c18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .lalign       00000004  8000499c  8000499c  00004d9c  2**0
                  ALLOC
  8 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  9 .ctors        00000008  00000008  800049a0  00005008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  00000010  800049a8  00005010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .jcr          00000004  00000018  800049b0  00005018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .got          00000000  0000001c  800049b4  0000501c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .data         00000510  0000001c  800049b4  0000501c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          00000254  00000544  00000544  00000000  2**2
                  ALLOC
 15 .heap         0000e868  00000798  00000798  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  0000552c  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 000009f8  00000000  00000000  00005560  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 00001540  00000000  00000000  00005f58  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   000111e1  00000000  00000000  00007498  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002de2  00000000  00000000  00018679  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   000097cf  00000000  00000000  0001b45b  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  0000170c  00000000  00000000  00024c2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00003639  00000000  00000000  00026338  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    0000377d  00000000  00000000  00029971  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00b51e18  00000000  00000000  0002d0ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000be8  00000000  00000000  00b7ef06  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 12 23 	rcall	80004464 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb d6 94 	sub	r11,pc,-10604
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 30 	mov	r10,1328
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 98 	mov	r10,1944
8000204e:	e0 6c 05 30 	mov	r12,1328
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 06 a2 	rcall	80002da0 <_init_startup>
80002060:	fe cc d8 60 	sub	r12,pc,-10144
80002064:	e0 a0 0d 18 	rcall	80003a94 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 10 09 	rcall	80004080 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 0b 3f 	rcall	800036fc <main>
80002082:	e0 a0 0d 11 	rcall	80003aa4 <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 44 	mov	r8,1348
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 48 	mov	r7,1352
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 44 	mov	r8,1348
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
800020dc:	d4 01       	pushm	lr
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
800020de:	30 2b       	mov	r11,2
800020e0:	fe 7c 28 00 	mov	r12,-55296
800020e4:	f0 1f 00 02 	mcall	800020ec <dip204_select+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	2b bc       	sub	r12,-69

800020f0 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
  unsigned char reverse;

  switch (byte)
800020f4:	f8 c8 ff f8 	sub	r8,r12,-8
800020f8:	30 69       	mov	r9,6
800020fa:	f2 08 18 00 	cp.b	r8,r9
800020fe:	e0 8b 00 0f 	brhi	8000211c <dip204_write_byte+0x2c>
80002102:	30 19       	mov	r9,1
80002104:	f2 08 09 48 	lsl	r8,r9,r8
80002108:	e2 18 00 55 	andl	r8,0x55,COH
8000210c:	c0 80       	breq	8000211c <dip204_write_byte+0x2c>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
8000210e:	18 9b       	mov	r11,r12
80002110:	fe 7c 28 00 	mov	r12,-55296
80002114:	f0 1f 00 0c 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      break;
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
8000211c:	5c 9c       	brev	r12
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
8000211e:	f8 07 16 18 	lsr	r7,r12,0x18
80002122:	0e 9b       	mov	r11,r7
80002124:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002128:	fe 7c 28 00 	mov	r12,-55296
8000212c:	f0 1f 00 06 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002130:	ee 0b 15 04 	lsl	r11,r7,0x4
80002134:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002138:	fe 7c 28 00 	mov	r12,-55296
8000213c:	f0 1f 00 02 	mcall	80002144 <dip204_write_byte+0x54>
80002140:	e3 cd 80 80 	ldm	sp++,r7,pc
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	2a 58       	sub	r8,-91

80002148 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80002148:	eb cd 40 c0 	pushm	r6-r7,lr
8000214c:	20 1d       	sub	sp,4
8000214e:	18 96       	mov	r6,r12
  unsigned short reverse = 0x00;
80002150:	fa c7 ff fc 	sub	r7,sp,-4
80002154:	30 08       	mov	r8,0
80002156:	0e e8       	st.h	--r7,r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
80002158:	30 0b       	mov	r11,0
8000215a:	fe 7c 28 00 	mov	r12,-55296
8000215e:	f0 1f 00 08 	mcall	8000217c <dip204_read_byte+0x34>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80002162:	0e 9b       	mov	r11,r7
80002164:	fe 7c 28 00 	mov	r12,-55296
80002168:	f0 1f 00 06 	mcall	80002180 <dip204_read_byte+0x38>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
8000216c:	1b b8       	ld.ub	r8,sp[0x3]
8000216e:	5c 98       	brev	r8
80002170:	b9 88       	lsr	r8,0x18
80002172:	ac 88       	st.b	r6[0x0],r8
}
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	2a 58       	sub	r8,-91
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	2a 74       	sub	r4,-89

80002184 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80002184:	eb cd 40 c0 	pushm	r6-r7,lr
80002188:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000218a:	fa c7 ff fc 	sub	r7,sp,-4
8000218e:	30 08       	mov	r8,0
80002190:	0e f8       	st.b	--r7,r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80002192:	e0 6c 00 fc 	mov	r12,252
80002196:	f0 1f 00 07 	mcall	800021b0 <dip204_wait_busy+0x2c>
  /* read next byte */
  do {
  dip204_read_byte(&status);
  /* keep D7 to know status */
  }while (status & 0x80);
8000219a:	30 06       	mov	r6,0

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000219c:	0e 9c       	mov	r12,r7
8000219e:	f0 1f 00 06 	mcall	800021b4 <dip204_wait_busy+0x30>
  /* keep D7 to know status */
  }while (status & 0x80);
800021a2:	1b b8       	ld.ub	r8,sp[0x3]
800021a4:	ec 08 18 00 	cp.b	r8,r6
800021a8:	cf a5       	brlt	8000219c <dip204_wait_busy+0x18>
}
800021aa:	2f fd       	sub	sp,-4
800021ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	20 f0       	sub	r0,15
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	21 48       	sub	r8,20

800021b8 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
800021b8:	d4 01       	pushm	lr
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
800021ba:	30 2b       	mov	r11,2
800021bc:	fe 7c 28 00 	mov	r12,-55296
800021c0:	f0 1f 00 02 	mcall	800021c8 <dip204_unselect+0x10>
  Assert( SPI_OK==spi_status );
}
800021c4:	d8 02       	popm	pc
800021c6:	00 00       	add	r0,r0
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	2b 7c       	sub	r12,-73

800021cc <dip204_write_string>:
  dip204_unselect();
}


void dip204_write_string(const char *string)
{
800021cc:	eb cd 40 f8 	pushm	r3-r7,lr
800021d0:	18 94       	mov	r4,r12
  unsigned char i=0;

  dip204_select();
800021d2:	f0 1f 00 11 	mcall	80002214 <dip204_write_string+0x48>
  /* for all chars in string */
  while(string[i]!=0)
800021d6:	09 89       	ld.ub	r9,r4[0x0]
800021d8:	30 08       	mov	r8,0
800021da:	f0 09 18 00 	cp.b	r9,r8
800021de:	c1 60       	breq	8000220a <dip204_write_string+0x3e>
800021e0:	08 96       	mov	r6,r4
800021e2:	30 07       	mov	r7,0
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021e4:	e0 63 00 fa 	mov	r3,250
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021e8:	10 95       	mov	r5,r8
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 0b 	mcall	80002218 <dip204_write_string+0x4c>
    /* Send byte */
    dip204_write_byte(string[i]);
800021f0:	0d 8c       	ld.ub	r12,r6[0x0]
800021f2:	f0 1f 00 0a 	mcall	80002218 <dip204_write_string+0x4c>
    /* go to next char */
    i++;
800021f6:	2f f7       	sub	r7,-1
800021f8:	5c 57       	castu.b	r7
    dip204_wait_busy();
800021fa:	f0 1f 00 09 	mcall	8000221c <dip204_write_string+0x50>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021fe:	e8 07 00 06 	add	r6,r4,r7
80002202:	0d 88       	ld.ub	r8,r6[0x0]
80002204:	ea 08 18 00 	cp.b	r8,r5
80002208:	cf 11       	brne	800021ea <dip204_write_string+0x1e>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
8000220a:	f0 1f 00 06 	mcall	80002220 <dip204_write_string+0x54>
}
8000220e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002212:	00 00       	add	r0,r0
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	20 dc       	sub	r12,13
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	20 f0       	sub	r0,15
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	21 84       	sub	r4,24
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	21 b8       	sub	r8,27

80002224 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002224:	eb cd 40 c0 	pushm	r6-r7,lr
80002228:	18 96       	mov	r6,r12
8000222a:	16 97       	mov	r7,r11
  unsigned char address = 0;

  dip204_select();
8000222c:	f0 1f 00 11 	mcall	80002270 <dip204_set_cursor_position+0x4c>
  if ((column <= 20) && (line <= 4))
80002230:	31 48       	mov	r8,20
80002232:	f0 06 18 00 	cp.b	r6,r8
80002236:	5f 89       	srls	r9
80002238:	30 48       	mov	r8,4
8000223a:	f0 07 18 00 	cp.b	r7,r8
8000223e:	5f 88       	srls	r8
80002240:	f3 e8 00 08 	and	r8,r9,r8
80002244:	c0 31       	brne	8000224a <dip204_set_cursor_position+0x26>
80002246:	30 06       	mov	r6,0
80002248:	c0 68       	rjmp	80002254 <dip204_set_cursor_position+0x30>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
8000224a:	28 16       	sub	r6,-127
8000224c:	20 17       	sub	r7,1
8000224e:	a5 77       	lsl	r7,0x5
80002250:	0e 06       	add	r6,r7
80002252:	5c 56       	castu.b	r6
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002254:	e0 6c 00 f8 	mov	r12,248
80002258:	f0 1f 00 07 	mcall	80002274 <dip204_set_cursor_position+0x50>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
8000225c:	0c 9c       	mov	r12,r6
8000225e:	f0 1f 00 06 	mcall	80002274 <dip204_set_cursor_position+0x50>
  dip204_wait_busy();
80002262:	f0 1f 00 06 	mcall	80002278 <dip204_set_cursor_position+0x54>
  dip204_unselect();
80002266:	f0 1f 00 06 	mcall	8000227c <dip204_set_cursor_position+0x58>
}
8000226a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000226e:	00 00       	add	r0,r0
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	20 dc       	sub	r12,13
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	20 f0       	sub	r0,15
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	21 84       	sub	r4,24
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	21 b8       	sub	r8,27

80002280 <dip204_write_data>:
  dip204_unselect();
}


void dip204_write_data(unsigned char data)
{
80002280:	eb cd 40 80 	pushm	r7,lr
80002284:	18 97       	mov	r7,r12
  dip204_select();
80002286:	f0 1f 00 08 	mcall	800022a4 <dip204_write_data+0x24>
  /* Send Write Data Start-Byte */
  dip204_write_byte(DIP204_WRITE_DATA);
8000228a:	e0 6c 00 fa 	mov	r12,250
8000228e:	f0 1f 00 07 	mcall	800022a8 <dip204_write_data+0x28>
  /* send data */
  dip204_write_byte(data);
80002292:	0e 9c       	mov	r12,r7
80002294:	f0 1f 00 05 	mcall	800022a8 <dip204_write_data+0x28>
  dip204_wait_busy();
80002298:	f0 1f 00 05 	mcall	800022ac <dip204_write_data+0x2c>
  dip204_unselect();
8000229c:	f0 1f 00 05 	mcall	800022b0 <dip204_write_data+0x30>
}
800022a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	20 dc       	sub	r12,13
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	20 f0       	sub	r0,15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	21 84       	sub	r4,24
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	21 b8       	sub	r8,27

800022b4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
800022b4:	d4 01       	pushm	lr
  /* select the LCD chip */
  dip204_select();
800022b6:	f0 1f 00 08 	mcall	800022d4 <dip204_hide_cursor+0x20>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
800022ba:	e0 6c 00 f8 	mov	r12,248
800022be:	f0 1f 00 07 	mcall	800022d8 <dip204_hide_cursor+0x24>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
800022c2:	30 cc       	mov	r12,12
800022c4:	f0 1f 00 05 	mcall	800022d8 <dip204_hide_cursor+0x24>
  dip204_wait_busy();
800022c8:	f0 1f 00 05 	mcall	800022dc <dip204_hide_cursor+0x28>
  /* unselect chip */
  dip204_unselect();
800022cc:	f0 1f 00 05 	mcall	800022e0 <dip204_hide_cursor+0x2c>
}
800022d0:	d8 02       	popm	pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	20 dc       	sub	r12,13
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	20 f0       	sub	r0,15
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	21 84       	sub	r4,24
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	21 b8       	sub	r8,27

800022e4 <dip204_clear_display>:
  dip204_unselect();
}


void dip204_clear_display(void)
{
800022e4:	d4 01       	pushm	lr
  dip204_select();
800022e6:	f0 1f 00 13 	mcall	80002330 <dip204_clear_display+0x4c>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
800022ea:	e0 6c 00 f8 	mov	r12,248
800022ee:	f0 1f 00 12 	mcall	80002334 <dip204_clear_display+0x50>
  /* Send Display Clear Command */
  dip204_write_byte(0x01);
800022f2:	30 1c       	mov	r12,1
800022f4:	f0 1f 00 10 	mcall	80002334 <dip204_clear_display+0x50>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800022f8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800022fc:	e2 79 a9 80 	mov	r9,240000
80002300:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002304:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002308:	14 38       	cp.w	r8,r10
8000230a:	e0 88 00 08 	brls	8000231a <dip204_clear_display+0x36>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000230e:	12 38       	cp.w	r8,r9
80002310:	fe 98 ff fa 	brls	80002304 <dip204_clear_display+0x20>
80002314:	12 3a       	cp.w	r10,r9
80002316:	c0 73       	brcs	80002324 <dip204_clear_display+0x40>
80002318:	cf 6b       	rjmp	80002304 <dip204_clear_display+0x20>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000231a:	12 38       	cp.w	r8,r9
8000231c:	e0 8b 00 04 	brhi	80002324 <dip204_clear_display+0x40>
80002320:	12 3a       	cp.w	r10,r9
80002322:	cf 12       	brcc	80002304 <dip204_clear_display+0x20>
  /* Wait for command execution */
  delay_ms(4);
  dip204_wait_busy();
80002324:	f0 1f 00 05 	mcall	80002338 <dip204_clear_display+0x54>
  dip204_unselect();
80002328:	f0 1f 00 05 	mcall	8000233c <dip204_clear_display+0x58>
}
8000232c:	d8 02       	popm	pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	20 dc       	sub	r12,13
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	20 f0       	sub	r0,15
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	21 84       	sub	r4,24
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	21 b8       	sub	r8,27

80002340 <dip204_set_backlight>:
  dip204_unselect();
}


void dip204_set_backlight(backlight_power power)
{
80002340:	d4 01       	pushm	lr
  if (channel_id != -1)
80002342:	49 d8       	lddpc	r8,800023b4 <dip204_set_backlight+0x74>
80002344:	70 08       	ld.w	r8,r8[0x0]
80002346:	5b f8       	cp.w	r8,-1
80002348:	c2 a0       	breq	8000239c <dip204_set_backlight+0x5c>
  {
    if (power == backlight_power_decrease)
8000234a:	58 1c       	cp.w	r12,1
8000234c:	c1 41       	brne	80002374 <dip204_set_backlight+0x34>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Max(pwm_duty - (DIP204_PERIOD_MAX / 10), 1);
8000234e:	49 ba       	lddpc	r10,800023b8 <dip204_set_backlight+0x78>
80002350:	94 89       	ld.uh	r9,r10[0x0]
80002352:	20 59       	sub	r9,5
80002354:	30 1b       	mov	r11,1
80002356:	f2 0b 0c 49 	max	r9,r9,r11
8000235a:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
8000235c:	49 8b       	lddpc	r11,800023bc <dip204_set_backlight+0x7c>
8000235e:	76 0a       	ld.w	r10,r11[0x0]
80002360:	30 0c       	mov	r12,0
80002362:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
80002366:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
80002368:	5c 79       	castu.h	r9
8000236a:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
8000236c:	10 9c       	mov	r12,r8
8000236e:	f0 1f 00 15 	mcall	800023c0 <dip204_set_backlight+0x80>
80002372:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
80002374:	58 0c       	cp.w	r12,0
80002376:	c1 e1       	brne	800023b2 <dip204_set_backlight+0x72>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Min(pwm_duty + (DIP204_PERIOD_MAX / 10), DIP204_PERIOD_MAX - 1);
80002378:	49 0a       	lddpc	r10,800023b8 <dip204_set_backlight+0x78>
8000237a:	94 89       	ld.uh	r9,r10[0x0]
8000237c:	2f b9       	sub	r9,-5
8000237e:	33 1b       	mov	r11,49
80002380:	f2 0b 0d 49 	min	r9,r9,r11
80002384:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
80002386:	48 eb       	lddpc	r11,800023bc <dip204_set_backlight+0x7c>
80002388:	76 0a       	ld.w	r10,r11[0x0]
8000238a:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
8000238e:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
80002390:	5c 79       	castu.h	r9
80002392:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
80002394:	10 9c       	mov	r12,r8
80002396:	f0 1f 00 0b 	mcall	800023c0 <dip204_set_backlight+0x80>
8000239a:	d8 02       	popm	pc
    }
  }
  else
  {
    if (power == backlight_power_decrease)
8000239c:	58 1c       	cp.w	r12,1
8000239e:	c0 51       	brne	800023a8 <dip204_set_backlight+0x68>
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800023a0:	33 2c       	mov	r12,50
800023a2:	f0 1f 00 09 	mcall	800023c4 <dip204_set_backlight+0x84>
800023a6:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
800023a8:	58 0c       	cp.w	r12,0
800023aa:	c0 41       	brne	800023b2 <dip204_set_backlight+0x72>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800023ac:	33 2c       	mov	r12,50
800023ae:	f0 1f 00 07 	mcall	800023c8 <dip204_set_backlight+0x88>
800023b2:	d8 02       	popm	pc
800023b4:	00 00       	add	r0,r0
800023b6:	00 1c       	sub	r12,r0
800023b8:	00 00       	add	r0,r0
800023ba:	05 6c       	ld.uh	r12,--r2
800023bc:	00 00       	add	r0,r0
800023be:	05 4c       	ld.w	r12,--r2
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	29 50       	sub	r0,-107
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	26 94       	sub	r4,105
800023c8:	80 00       	ld.sh	r0,r0[0x0]
800023ca:	26 b0       	sub	r0,107

800023cc <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
800023d0:	20 4d       	sub	sp,16
800023d2:	16 97       	mov	r7,r11
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
800023d4:	58 1c       	cp.w	r12,1
800023d6:	c3 11       	brne	80002438 <dip204_init+0x6c>
  {
    channel_id = DIP204_PWM_CHANNEL;
800023d8:	30 69       	mov	r9,6
800023da:	fe f8 02 02 	ld.w	r8,pc[514]
800023de:	91 09       	st.w	r8[0x0],r9
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
800023e0:	30 2b       	mov	r11,2
800023e2:	33 2c       	mov	r12,50
800023e4:	f0 1f 00 7f 	mcall	800025e0 <dip204_init+0x214>

    // PWM controller configuration
    pwm_opt.diva=0;
800023e8:	30 08       	mov	r8,0
800023ea:	50 18       	stdsp	sp[0x4],r8
    pwm_opt.divb=0;
800023ec:	50 08       	stdsp	sp[0x0],r8
    pwm_opt.prea=0;
800023ee:	50 38       	stdsp	sp[0xc],r8
    pwm_opt.preb=0;
800023f0:	50 28       	stdsp	sp[0x8],r8

    pwm_init(&pwm_opt);
800023f2:	1a 9c       	mov	r12,sp
800023f4:	f0 1f 00 7c 	mcall	800025e4 <dip204_init+0x218>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
800023f8:	58 07       	cp.w	r7,0
800023fa:	f9 b7 01 31 	movne	r7,49
800023fe:	f9 b7 00 01 	moveq	r7,1
80002402:	4f a8       	lddpc	r8,800025e8 <dip204_init+0x21c>
80002404:	b0 07       	st.h	r8[0x0],r7
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
80002406:	4f ab       	lddpc	r11,800025ec <dip204_init+0x220>
80002408:	76 08       	ld.w	r8,r11[0x0]
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
8000240a:	e0 18 fc ff 	andl	r8,0xfcff
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
8000240e:	ab a8       	sbr	r8,0xa
80002410:	30 89       	mov	r9,8
80002412:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80002416:	97 08       	st.w	r11[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
80002418:	97 17       	st.w	r11[0x4],r7
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
8000241a:	33 28       	mov	r8,50
8000241c:	97 28       	st.w	r11[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
8000241e:	30 08       	mov	r8,0
80002420:	97 48       	st.w	r11[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
80002422:	4e f7       	lddpc	r7,800025dc <dip204_init+0x210>
80002424:	6e 0c       	ld.w	r12,r7[0x0]
80002426:	f0 1f 00 73 	mcall	800025f0 <dip204_init+0x224>
    // start PWM
    pwm_start_channels(1 << channel_id);
8000242a:	6e 08       	ld.w	r8,r7[0x0]
8000242c:	30 1c       	mov	r12,1
8000242e:	f8 08 09 4c 	lsl	r12,r12,r8
80002432:	f0 1f 00 71 	mcall	800025f4 <dip204_init+0x228>
80002436:	c0 a8       	rjmp	8000244a <dip204_init+0x7e>
  }
  else
  {
    if (backlight_on)
80002438:	58 0b       	cp.w	r11,0
8000243a:	c0 50       	breq	80002444 <dip204_init+0x78>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
8000243c:	33 2c       	mov	r12,50
8000243e:	f0 1f 00 6f 	mcall	800025f8 <dip204_init+0x22c>
80002442:	c0 48       	rjmp	8000244a <dip204_init+0x7e>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
80002444:	33 2c       	mov	r12,50
80002446:	f0 1f 00 6e 	mcall	800025fc <dip204_init+0x230>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000244a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000244e:	e0 6a 4f 80 	mov	r10,20352
80002452:	ea 1a 00 12 	orh	r10,0x12
80002456:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000245a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000245e:	14 38       	cp.w	r8,r10
80002460:	e0 88 00 08 	brls	80002470 <dip204_init+0xa4>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002464:	12 38       	cp.w	r8,r9
80002466:	fe 98 ff fa 	brls	8000245a <dip204_init+0x8e>
8000246a:	12 3a       	cp.w	r10,r9
8000246c:	c6 e3       	brcs	80002548 <dip204_init+0x17c>
8000246e:	cf 6b       	rjmp	8000245a <dip204_init+0x8e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002470:	12 38       	cp.w	r8,r9
80002472:	e0 8b 00 6b 	brhi	80002548 <dip204_init+0x17c>
80002476:	12 3a       	cp.w	r10,r9
80002478:	c6 83       	brcs	80002548 <dip204_init+0x17c>
8000247a:	cf 0b       	rjmp	8000245a <dip204_init+0x8e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000247c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002480:	14 38       	cp.w	r8,r10
80002482:	e0 88 00 08 	brls	80002492 <dip204_init+0xc6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002486:	12 38       	cp.w	r8,r9
80002488:	fe 98 ff fa 	brls	8000247c <dip204_init+0xb0>
8000248c:	12 3a       	cp.w	r10,r9
8000248e:	c6 d3       	brcs	80002568 <dip204_init+0x19c>
80002490:	cf 6b       	rjmp	8000247c <dip204_init+0xb0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002492:	12 38       	cp.w	r8,r9
80002494:	e0 8b 00 6a 	brhi	80002568 <dip204_init+0x19c>
80002498:	12 3a       	cp.w	r10,r9
8000249a:	c6 73       	brcs	80002568 <dip204_init+0x19c>
8000249c:	cf 0b       	rjmp	8000247c <dip204_init+0xb0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000249e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024a2:	14 38       	cp.w	r8,r10
800024a4:	e0 88 00 08 	brls	800024b4 <dip204_init+0xe8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024a8:	12 38       	cp.w	r8,r9
800024aa:	fe 98 ff fa 	brls	8000249e <dip204_init+0xd2>
800024ae:	12 3a       	cp.w	r10,r9
800024b0:	c6 63       	brcs	8000257c <dip204_init+0x1b0>
800024b2:	cf 6b       	rjmp	8000249e <dip204_init+0xd2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024b4:	12 38       	cp.w	r8,r9
800024b6:	e0 8b 00 63 	brhi	8000257c <dip204_init+0x1b0>
800024ba:	12 3a       	cp.w	r10,r9
800024bc:	c6 03       	brcs	8000257c <dip204_init+0x1b0>
800024be:	cf 0b       	rjmp	8000249e <dip204_init+0xd2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024c0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024c4:	14 38       	cp.w	r8,r10
800024c6:	e0 88 00 08 	brls	800024d6 <dip204_init+0x10a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024ca:	12 38       	cp.w	r8,r9
800024cc:	fe 98 ff fa 	brls	800024c0 <dip204_init+0xf4>
800024d0:	12 3a       	cp.w	r10,r9
800024d2:	c5 f3       	brcs	80002590 <dip204_init+0x1c4>
800024d4:	cf 6b       	rjmp	800024c0 <dip204_init+0xf4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024d6:	12 38       	cp.w	r8,r9
800024d8:	e0 8b 00 5c 	brhi	80002590 <dip204_init+0x1c4>
800024dc:	12 3a       	cp.w	r10,r9
800024de:	c5 93       	brcs	80002590 <dip204_init+0x1c4>
800024e0:	cf 0b       	rjmp	800024c0 <dip204_init+0xf4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024e2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024e6:	14 38       	cp.w	r8,r10
800024e8:	e0 88 00 08 	brls	800024f8 <dip204_init+0x12c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024ec:	12 38       	cp.w	r8,r9
800024ee:	fe 98 ff fa 	brls	800024e2 <dip204_init+0x116>
800024f2:	12 3a       	cp.w	r10,r9
800024f4:	c5 83       	brcs	800025a4 <dip204_init+0x1d8>
800024f6:	cf 6b       	rjmp	800024e2 <dip204_init+0x116>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024f8:	12 38       	cp.w	r8,r9
800024fa:	e0 8b 00 55 	brhi	800025a4 <dip204_init+0x1d8>
800024fe:	12 3a       	cp.w	r10,r9
80002500:	c5 23       	brcs	800025a4 <dip204_init+0x1d8>
80002502:	cf 0b       	rjmp	800024e2 <dip204_init+0x116>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002504:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002508:	14 38       	cp.w	r8,r10
8000250a:	e0 88 00 08 	brls	8000251a <dip204_init+0x14e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000250e:	12 38       	cp.w	r8,r9
80002510:	fe 98 ff fa 	brls	80002504 <dip204_init+0x138>
80002514:	12 3a       	cp.w	r10,r9
80002516:	c5 13       	brcs	800025b8 <dip204_init+0x1ec>
80002518:	cf 6b       	rjmp	80002504 <dip204_init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000251a:	12 38       	cp.w	r8,r9
8000251c:	e0 8b 00 4e 	brhi	800025b8 <dip204_init+0x1ec>
80002520:	12 3a       	cp.w	r10,r9
80002522:	c4 b3       	brcs	800025b8 <dip204_init+0x1ec>
80002524:	cf 0b       	rjmp	80002504 <dip204_init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002526:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000252a:	14 38       	cp.w	r8,r10
8000252c:	e0 88 00 08 	brls	8000253c <dip204_init+0x170>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002530:	12 38       	cp.w	r8,r9
80002532:	fe 98 ff fa 	brls	80002526 <dip204_init+0x15a>
80002536:	12 3a       	cp.w	r10,r9
80002538:	c4 a3       	brcs	800025cc <dip204_init+0x200>
8000253a:	cf 6b       	rjmp	80002526 <dip204_init+0x15a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000253c:	12 38       	cp.w	r8,r9
8000253e:	e0 8b 00 47 	brhi	800025cc <dip204_init+0x200>
80002542:	12 3a       	cp.w	r10,r9
80002544:	c4 43       	brcs	800025cc <dip204_init+0x200>
80002546:	cf 0b       	rjmp	80002526 <dip204_init+0x15a>
    }
  }
  // delay for power on
  delay_ms(20);
  // select the LCD chip
  dip204_select();
80002548:	f0 1f 00 2e 	mcall	80002600 <dip204_init+0x234>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
8000254c:	e0 6c 00 f8 	mov	r12,248
80002550:	f0 1f 00 2d 	mcall	80002604 <dip204_init+0x238>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
80002554:	33 4c       	mov	r12,52
80002556:	f0 1f 00 2c 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000255a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000255e:	e0 69 ea 60 	mov	r9,60000
80002562:	f0 09 00 0a 	add	r10,r8,r9
80002566:	c8 bb       	rjmp	8000247c <dip204_init+0xb0>
  // Wait for command execution
  delay_ms(1);
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
80002568:	30 9c       	mov	r12,9
8000256a:	f0 1f 00 27 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000256e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002572:	e0 69 ea 60 	mov	r9,60000
80002576:	f0 09 00 0a 	add	r10,r8,r9
8000257a:	c9 2b       	rjmp	8000249e <dip204_init+0xd2>
  // Wait for command execution
  delay_ms(1);
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
8000257c:	33 0c       	mov	r12,48
8000257e:	f0 1f 00 22 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002582:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002586:	e0 69 ea 60 	mov	r9,60000
8000258a:	f0 09 00 0a 	add	r10,r8,r9
8000258e:	c9 9b       	rjmp	800024c0 <dip204_init+0xf4>
  // Wait for command execution
  delay_ms(1);
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
80002590:	30 fc       	mov	r12,15
80002592:	f0 1f 00 1d 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002596:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000259a:	e0 69 ea 60 	mov	r9,60000
8000259e:	f0 09 00 0a 	add	r10,r8,r9
800025a2:	ca 0b       	rjmp	800024e2 <dip204_init+0x116>
  // Wait for command execution
  delay_ms(1);
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
800025a4:	30 1c       	mov	r12,1
800025a6:	f0 1f 00 18 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800025aa:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800025ae:	e4 69 93 e0 	mov	r9,300000
800025b2:	f0 09 00 0a 	add	r10,r8,r9
800025b6:	ca 7b       	rjmp	80002504 <dip204_init+0x138>
  // Wait for command execution
  delay_ms(5);
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
800025b8:	30 6c       	mov	r12,6
800025ba:	f0 1f 00 13 	mcall	80002604 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800025be:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800025c2:	e0 69 ea 60 	mov	r9,60000
800025c6:	f0 09 00 0a 	add	r10,r8,r9
800025ca:	ca eb       	rjmp	80002526 <dip204_init+0x15a>
  // Wait for command execution
  delay_ms(1);
  dip204_wait_busy();
800025cc:	f0 1f 00 0f 	mcall	80002608 <dip204_init+0x23c>
  // unselect chip
  dip204_unselect();
800025d0:	f0 1f 00 0f 	mcall	8000260c <dip204_init+0x240>
}
800025d4:	2f cd       	sub	sp,-16
800025d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800025da:	00 00       	add	r0,r0
800025dc:	00 00       	add	r0,r0
800025de:	00 1c       	sub	r12,r0
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	26 10       	sub	r0,97
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	29 88       	sub	r8,-104
800025e8:	00 00       	add	r0,r0
800025ea:	05 6c       	ld.uh	r12,--r2
800025ec:	00 00       	add	r0,r0
800025ee:	05 4c       	ld.w	r12,--r2
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	29 08       	sub	r8,-112
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	29 3e       	sub	lr,-109
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	26 b0       	sub	r0,107
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	26 94       	sub	r4,105
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	20 dc       	sub	r12,13
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	20 f0       	sub	r0,15
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	21 84       	sub	r4,24
8000260c:	80 00       	ld.sh	r0,r0[0x0]
8000260e:	21 b8       	sub	r8,27

80002610 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002610:	f8 08 16 05 	lsr	r8,r12,0x5
80002614:	a9 68       	lsl	r8,0x8
80002616:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000261a:	58 1b       	cp.w	r11,1
8000261c:	c0 d0       	breq	80002636 <gpio_enable_module_pin+0x26>
8000261e:	c0 63       	brcs	8000262a <gpio_enable_module_pin+0x1a>
80002620:	58 2b       	cp.w	r11,2
80002622:	c1 00       	breq	80002642 <gpio_enable_module_pin+0x32>
80002624:	58 3b       	cp.w	r11,3
80002626:	c1 40       	breq	8000264e <gpio_enable_module_pin+0x3e>
80002628:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000262a:	30 19       	mov	r9,1
8000262c:	f2 0c 09 49 	lsl	r9,r9,r12
80002630:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002632:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002634:	c1 28       	rjmp	80002658 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002636:	30 19       	mov	r9,1
80002638:	f2 0c 09 49 	lsl	r9,r9,r12
8000263c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000263e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002640:	c0 c8       	rjmp	80002658 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002642:	30 19       	mov	r9,1
80002644:	f2 0c 09 49 	lsl	r9,r9,r12
80002648:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000264a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000264c:	c0 68       	rjmp	80002658 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000264e:	30 19       	mov	r9,1
80002650:	f2 0c 09 49 	lsl	r9,r9,r12
80002654:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002656:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002658:	30 19       	mov	r9,1
8000265a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000265e:	91 2c       	st.w	r8[0x8],r12
80002660:	5e fd       	retal	0
80002662:	d7 03       	nop

80002664 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002664:	d4 21       	pushm	r4-r7,lr
80002666:	18 97       	mov	r7,r12
80002668:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000266a:	58 0b       	cp.w	r11,0
8000266c:	c0 31       	brne	80002672 <gpio_enable_module+0xe>
8000266e:	30 05       	mov	r5,0
80002670:	c0 d8       	rjmp	8000268a <gpio_enable_module+0x26>
80002672:	30 06       	mov	r6,0
80002674:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002676:	6e 1b       	ld.w	r11,r7[0x4]
80002678:	6e 0c       	ld.w	r12,r7[0x0]
8000267a:	f0 1f 00 06 	mcall	80002690 <gpio_enable_module+0x2c>
8000267e:	18 45       	or	r5,r12
		gpiomap++;
80002680:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002682:	2f f6       	sub	r6,-1
80002684:	0c 34       	cp.w	r4,r6
80002686:	fe 9b ff f8 	brhi	80002676 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000268a:	0a 9c       	mov	r12,r5
8000268c:	d8 22       	popm	r4-r7,pc
8000268e:	00 00       	add	r0,r0
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	26 10       	sub	r0,97

80002694 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002694:	f8 08 16 05 	lsr	r8,r12,0x5
80002698:	a9 68       	lsl	r8,0x8
8000269a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000269e:	30 19       	mov	r9,1
800026a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800026a4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800026a8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800026ac:	91 1c       	st.w	r8[0x4],r12
}
800026ae:	5e fc       	retal	r12

800026b0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026b0:	f8 08 16 05 	lsr	r8,r12,0x5
800026b4:	a9 68       	lsl	r8,0x8
800026b6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800026ba:	30 19       	mov	r9,1
800026bc:	f2 0c 09 4c 	lsl	r12,r9,r12
800026c0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800026c4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800026c8:	91 1c       	st.w	r8[0x4],r12
}
800026ca:	5e fc       	retal	r12

800026cc <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026cc:	f8 08 16 05 	lsr	r8,r12,0x5
800026d0:	a9 68       	lsl	r8,0x8
800026d2:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
800026d6:	30 19       	mov	r9,1
800026d8:	f2 0c 09 4c 	lsl	r12,r9,r12
800026dc:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
800026e0:	12 3b       	cp.w	r11,r9
800026e2:	c0 a0       	breq	800026f6 <gpio_enable_pin_interrupt+0x2a>
800026e4:	c0 43       	brcs	800026ec <gpio_enable_pin_interrupt+0x20>
800026e6:	58 2b       	cp.w	r11,2
800026e8:	c1 11       	brne	8000270a <gpio_enable_pin_interrupt+0x3e>
800026ea:	c0 b8       	rjmp	80002700 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800026ec:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800026f0:	f1 4c 00 b8 	st.w	r8[184],r12
800026f4:	c0 c8       	rjmp	8000270c <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
800026f6:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800026fa:	f1 4c 00 b8 	st.w	r8[184],r12
800026fe:	c0 78       	rjmp	8000270c <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002700:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80002704:	f1 4c 00 b4 	st.w	r8[180],r12
80002708:	c0 28       	rjmp	8000270c <gpio_enable_pin_interrupt+0x40>
8000270a:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
8000270c:	f1 4c 00 94 	st.w	r8[148],r12
80002710:	5e fd       	retal	0

80002712 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002712:	f8 08 16 05 	lsr	r8,r12,0x5
80002716:	a9 68       	lsl	r8,0x8
80002718:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
8000271c:	f0 f8 00 d0 	ld.w	r8,r8[208]
80002720:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80002724:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002728:	5e fc       	retal	r12

8000272a <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000272a:	f8 08 16 05 	lsr	r8,r12,0x5
8000272e:	a9 68       	lsl	r8,0x8
80002730:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80002734:	30 19       	mov	r9,1
80002736:	f2 0c 09 4c 	lsl	r12,r9,r12
8000273a:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
8000273e:	5e fc       	retal	r12

80002740 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002740:	c0 08       	rjmp	80002740 <_unhandled_interrupt>
80002742:	d7 03       	nop

80002744 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002744:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002748:	49 99       	lddpc	r9,800027ac <INTC_register_interrupt+0x68>
8000274a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000274e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80002752:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002754:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002758:	58 0a       	cp.w	r10,0
8000275a:	c0 91       	brne	8000276c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000275c:	49 59       	lddpc	r9,800027b0 <INTC_register_interrupt+0x6c>
8000275e:	49 6a       	lddpc	r10,800027b4 <INTC_register_interrupt+0x70>
80002760:	12 1a       	sub	r10,r9
80002762:	fe 79 08 00 	mov	r9,-63488
80002766:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000276a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000276c:	58 1a       	cp.w	r10,1
8000276e:	c0 a1       	brne	80002782 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002770:	49 09       	lddpc	r9,800027b0 <INTC_register_interrupt+0x6c>
80002772:	49 2a       	lddpc	r10,800027b8 <INTC_register_interrupt+0x74>
80002774:	12 1a       	sub	r10,r9
80002776:	bf aa       	sbr	r10,0x1e
80002778:	fe 79 08 00 	mov	r9,-63488
8000277c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002780:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80002782:	58 2a       	cp.w	r10,2
80002784:	c0 a1       	brne	80002798 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002786:	48 b9       	lddpc	r9,800027b0 <INTC_register_interrupt+0x6c>
80002788:	48 da       	lddpc	r10,800027bc <INTC_register_interrupt+0x78>
8000278a:	12 1a       	sub	r10,r9
8000278c:	bf ba       	sbr	r10,0x1f
8000278e:	fe 79 08 00 	mov	r9,-63488
80002792:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002796:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002798:	48 69       	lddpc	r9,800027b0 <INTC_register_interrupt+0x6c>
8000279a:	48 aa       	lddpc	r10,800027c0 <INTC_register_interrupt+0x7c>
8000279c:	12 1a       	sub	r10,r9
8000279e:	ea 1a c0 00 	orh	r10,0xc000
800027a2:	fe 79 08 00 	mov	r9,-63488
800027a6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800027aa:	5e fc       	retal	r12
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	48 18       	lddpc	r8,800027b0 <INTC_register_interrupt+0x6c>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	46 00       	lddsp	r0,sp[0x180]
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	47 04       	lddsp	r4,sp[0x1c0]
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	47 12       	lddsp	r2,sp[0x1c4]
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	47 20       	lddsp	r0,sp[0x1c8]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	47 2e       	lddsp	lr,sp[0x1c8]

800027c4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800027c4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800027c6:	49 18       	lddpc	r8,80002808 <INTC_init_interrupts+0x44>
800027c8:	e3 b8 00 01 	mtsr	0x4,r8
800027cc:	49 0e       	lddpc	lr,8000280c <INTC_init_interrupts+0x48>
800027ce:	30 07       	mov	r7,0
800027d0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800027d2:	49 0c       	lddpc	r12,80002810 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800027d4:	49 05       	lddpc	r5,80002814 <INTC_init_interrupts+0x50>
800027d6:	10 15       	sub	r5,r8
800027d8:	fe 76 08 00 	mov	r6,-63488
800027dc:	c1 08       	rjmp	800027fc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800027de:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800027e0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800027e2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800027e4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800027e8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800027ea:	10 3a       	cp.w	r10,r8
800027ec:	fe 9b ff fc 	brhi	800027e4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800027f0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800027f4:	2f f7       	sub	r7,-1
800027f6:	2f 8e       	sub	lr,-8
800027f8:	59 47       	cp.w	r7,20
800027fa:	c0 50       	breq	80002804 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800027fc:	7c 08       	ld.w	r8,lr[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	ce f1       	brne	800027de <INTC_init_interrupts+0x1a>
80002802:	cf 7b       	rjmp	800027f0 <INTC_init_interrupts+0x2c>
80002804:	d8 22       	popm	r4-r7,pc
80002806:	00 00       	add	r0,r0
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	46 00       	lddsp	r0,sp[0x180]
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	48 18       	lddpc	r8,80002810 <INTC_init_interrupts+0x4c>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	27 40       	sub	r0,116
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	47 04       	lddsp	r4,sp[0x1c0]

80002818 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002818:	fe 78 08 00 	mov	r8,-63488
8000281c:	e0 69 00 83 	mov	r9,131
80002820:	f2 0c 01 0c 	sub	r12,r9,r12
80002824:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002828:	f2 ca ff c0 	sub	r10,r9,-64
8000282c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002830:	58 08       	cp.w	r8,0
80002832:	c0 21       	brne	80002836 <_get_interrupt_handler+0x1e>
80002834:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
80002836:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000283a:	48 5a       	lddpc	r10,8000284c <_get_interrupt_handler+0x34>
8000283c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002840:	f0 08 11 1f 	rsub	r8,r8,31
80002844:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002846:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000284a:	5e fc       	retal	r12
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	48 18       	lddpc	r8,80002850 <pm_set_osc0_mode>

80002850 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002850:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002852:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002856:	99 a8       	st.w	r12[0x28],r8
}
80002858:	5e fc       	retal	r12
8000285a:	d7 03       	nop

8000285c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000285c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000285e:	ec 5b bb 9f 	cp.w	r11,899999
80002862:	e0 8b 00 04 	brhi	8000286a <pm_enable_osc0_crystal+0xe>
80002866:	30 4b       	mov	r11,4
80002868:	c1 38       	rjmp	8000288e <pm_enable_osc0_crystal+0x32>
8000286a:	e0 68 c6 bf 	mov	r8,50879
8000286e:	ea 18 00 2d 	orh	r8,0x2d
80002872:	10 3b       	cp.w	r11,r8
80002874:	e0 8b 00 04 	brhi	8000287c <pm_enable_osc0_crystal+0x20>
80002878:	30 5b       	mov	r11,5
8000287a:	c0 a8       	rjmp	8000288e <pm_enable_osc0_crystal+0x32>
8000287c:	e0 68 12 00 	mov	r8,4608
80002880:	ea 18 00 7a 	orh	r8,0x7a
80002884:	10 3b       	cp.w	r11,r8
80002886:	f9 bb 03 06 	movlo	r11,6
8000288a:	f9 bb 02 07 	movhs	r11,7
8000288e:	f0 1f 00 02 	mcall	80002894 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002892:	d8 02       	popm	pc
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	28 50       	sub	r0,-123

80002898 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002898:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000289a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000289e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800028a0:	78 08       	ld.w	r8,r12[0x0]
800028a2:	a3 a8       	sbr	r8,0x2
800028a4:	99 08       	st.w	r12[0x0],r8
}
800028a6:	5e fc       	retal	r12

800028a8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800028a8:	79 58       	ld.w	r8,r12[0x54]
800028aa:	e2 18 00 80 	andl	r8,0x80,COH
800028ae:	cf d0       	breq	800028a8 <pm_wait_for_clk0_ready>
}
800028b0:	5e fc       	retal	r12
800028b2:	d7 03       	nop

800028b4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800028b4:	eb cd 40 80 	pushm	r7,lr
800028b8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800028ba:	f0 1f 00 04 	mcall	800028c8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800028be:	0e 9c       	mov	r12,r7
800028c0:	f0 1f 00 03 	mcall	800028cc <pm_enable_clk0+0x18>
}
800028c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	28 98       	sub	r8,-119
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	28 a8       	sub	r8,-118

800028d0 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800028d0:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800028d2:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800028d6:	99 08       	st.w	r12[0x0],r8
}
800028d8:	5e fc       	retal	r12
800028da:	d7 03       	nop

800028dc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800028dc:	eb cd 40 c0 	pushm	r6-r7,lr
800028e0:	18 97       	mov	r7,r12
800028e2:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800028e4:	f0 1f 00 06 	mcall	800028fc <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800028e8:	0c 9b       	mov	r11,r6
800028ea:	0e 9c       	mov	r12,r7
800028ec:	f0 1f 00 05 	mcall	80002900 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800028f0:	30 1b       	mov	r11,1
800028f2:	0e 9c       	mov	r12,r7
800028f4:	f0 1f 00 04 	mcall	80002904 <pm_switch_to_osc0+0x28>
}
800028f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	28 5c       	sub	r12,-123
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	28 b4       	sub	r4,-117
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	28 d0       	sub	r0,-115

80002908 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80002908:	58 0b       	cp.w	r11,0
8000290a:	c1 90       	breq	8000293c <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
8000290c:	58 6c       	cp.w	r12,6
8000290e:	e0 8b 00 17 	brhi	8000293c <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80002912:	76 0a       	ld.w	r10,r11[0x0]
80002914:	fe 78 30 00 	mov	r8,-53248
80002918:	f8 c9 ff f0 	sub	r9,r12,-16
8000291c:	a5 79       	lsl	r9,0x5
8000291e:	f0 09 00 09 	add	r9,r8,r9
80002922:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80002924:	76 19       	ld.w	r9,r11[0x4]
80002926:	a5 7c       	lsl	r12,0x5
80002928:	f0 0c 00 0c 	add	r12,r8,r12
8000292c:	f8 c8 fd fc 	sub	r8,r12,-516
80002930:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80002932:	76 28       	ld.w	r8,r11[0x8]
80002934:	f8 cc fd f8 	sub	r12,r12,-520
80002938:	99 08       	st.w	r12[0x0],r8
8000293a:	5e fd       	retal	0

  return PWM_SUCCESS;
8000293c:	5e ff       	retal	1

8000293e <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000293e:	18 98       	mov	r8,r12
80002940:	e0 18 ff 80 	andl	r8,0xff80
80002944:	c0 20       	breq	80002948 <pwm_start_channels+0xa>
80002946:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80002948:	fe 78 30 00 	mov	r8,-53248
8000294c:	91 1c       	st.w	r8[0x4],r12
8000294e:	5e fd       	retal	0

80002950 <pwm_sync_update_channel>:

int pwm_sync_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80002950:	58 6c       	cp.w	r12,6
80002952:	e0 88 00 03 	brls	80002958 <pwm_sync_update_channel+0x8>
80002956:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  AVR32_PWM.isr;                                    // Acknowledgement and clear previous register state.
80002958:	fe 78 30 00 	mov	r8,-53248
8000295c:	70 79       	ld.w	r9,r8[0x1c]
  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
8000295e:	76 09       	ld.w	r9,r11[0x0]
80002960:	f8 ca ff f0 	sub	r10,r12,-16
80002964:	a5 7a       	lsl	r10,0x5
80002966:	14 08       	add	r8,r10
80002968:	91 09       	st.w	r8[0x0],r9
  while (!(AVR32_PWM.isr & (1 << channel_id)));     // Wait until the last write has been taken into account.
8000296a:	30 1a       	mov	r10,1
8000296c:	f4 0c 09 4a 	lsl	r10,r10,r12
80002970:	fe 79 30 00 	mov	r9,-53248
80002974:	72 78       	ld.w	r8,r9[0x1c]
80002976:	f5 e8 00 08 	and	r8,r10,r8
8000297a:	cf d0       	breq	80002974 <pwm_sync_update_channel+0x24>
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
8000297c:	76 48       	ld.w	r8,r11[0x10]
8000297e:	a5 7c       	lsl	r12,0x5
80002980:	e0 2c cd f0 	sub	r12,52720
80002984:	99 08       	st.w	r12[0x0],r8
80002986:	5e fd       	retal	0

80002988 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002988:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
8000298c:	58 0c       	cp.w	r12,0
8000298e:	c0 21       	brne	80002992 <pwm_init+0xa>
80002990:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002992:	e6 18 00 01 	andh	r8,0x1,COH
80002996:	c0 91       	brne	800029a8 <pwm_init+0x20>
80002998:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000299a:	fe 78 30 00 	mov	r8,-53248
8000299e:	37 f9       	mov	r9,127
800029a0:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800029a2:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800029a4:	d5 03       	csrf	0x10
800029a6:	c0 68       	rjmp	800029b2 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800029a8:	fe 78 30 00 	mov	r8,-53248
800029ac:	37 f9       	mov	r9,127
800029ae:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800029b0:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
800029b2:	78 08       	ld.w	r8,r12[0x0]
800029b4:	78 39       	ld.w	r9,r12[0xc]
800029b6:	a9 69       	lsl	r9,0x8
800029b8:	f3 e8 11 09 	or	r9,r9,r8<<0x10
800029bc:	78 18       	ld.w	r8,r12[0x4]
800029be:	10 49       	or	r9,r8
800029c0:	78 28       	ld.w	r8,r12[0x8]
800029c2:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
800029c6:	fe 78 30 00 	mov	r8,-53248
800029ca:	91 09       	st.w	r8[0x0],r9
800029cc:	5e fd       	retal	0

800029ce <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800029ce:	f8 c8 00 01 	sub	r8,r12,1
800029d2:	f0 0b 00 0b 	add	r11,r8,r11
800029d6:	f6 0c 0d 0a 	divu	r10,r11,r12
800029da:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800029dc:	f4 c8 00 01 	sub	r8,r10,1
800029e0:	e0 48 00 fe 	cp.w	r8,254
800029e4:	e0 88 00 03 	brls	800029ea <getBaudDiv+0x1c>
800029e8:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800029ea:	5c 8c       	casts.h	r12
}
800029ec:	5e fc       	retal	r12

800029ee <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800029ee:	f7 39 00 0d 	ld.ub	r9,r11[13]
800029f2:	30 18       	mov	r8,1
800029f4:	f0 09 18 00 	cp.b	r9,r8
800029f8:	e0 88 00 04 	brls	80002a00 <spi_initMaster+0x12>
800029fc:	30 2c       	mov	r12,2
800029fe:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80002a00:	e0 68 00 80 	mov	r8,128
80002a04:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002a06:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80002a08:	30 19       	mov	r9,1
80002a0a:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002a0e:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002a12:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002a16:	30 09       	mov	r9,0
80002a18:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002a1c:	30 fa       	mov	r10,15
80002a1e:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80002a22:	99 18       	st.w	r12[0x4],r8
80002a24:	5e f9       	retal	r9

80002a26 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002a26:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002a28:	30 18       	mov	r8,1
80002a2a:	f0 0b 18 00 	cp.b	r11,r8
80002a2e:	5f be       	srhi	lr
80002a30:	f0 0a 18 00 	cp.b	r10,r8
80002a34:	5f b8       	srhi	r8
80002a36:	fd e8 10 08 	or	r8,lr,r8
80002a3a:	c0 30       	breq	80002a40 <spi_selectionMode+0x1a>
80002a3c:	30 2c       	mov	r12,2
80002a3e:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002a40:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002a42:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002a46:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002a4a:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002a4e:	99 18       	st.w	r12[0x4],r8
80002a50:	d8 0a       	popm	pc,r12=0

80002a52 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002a52:	30 18       	mov	r8,1
80002a54:	99 08       	st.w	r12[0x0],r8
}
80002a56:	5e fc       	retal	r12

80002a58 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80002a58:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a5c:	c0 58       	rjmp	80002a66 <spi_write+0xe>
		if (!timeout--) {
80002a5e:	58 08       	cp.w	r8,0
80002a60:	c0 21       	brne	80002a64 <spi_write+0xc>
80002a62:	5e ff       	retal	1
80002a64:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a66:	78 49       	ld.w	r9,r12[0x10]
80002a68:	e2 19 00 02 	andl	r9,0x2,COH
80002a6c:	cf 90       	breq	80002a5e <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002a6e:	5c 7b       	castu.h	r11
80002a70:	99 3b       	st.w	r12[0xc],r11
80002a72:	5e fd       	retal	0

80002a74 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002a74:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a78:	c0 58       	rjmp	80002a82 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002a7a:	58 08       	cp.w	r8,0
80002a7c:	c0 21       	brne	80002a80 <spi_read+0xc>
80002a7e:	5e ff       	retal	1
80002a80:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a82:	78 49       	ld.w	r9,r12[0x10]
80002a84:	e2 19 02 01 	andl	r9,0x201,COH
80002a88:	e0 49 02 01 	cp.w	r9,513
80002a8c:	cf 71       	brne	80002a7a <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002a8e:	78 28       	ld.w	r8,r12[0x8]
80002a90:	b6 08       	st.h	r11[0x0],r8
80002a92:	5e fd       	retal	0

80002a94 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002a94:	eb cd 40 f8 	pushm	r3-r7,lr
80002a98:	18 95       	mov	r5,r12
80002a9a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a9c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002aa0:	30 38       	mov	r8,3
80002aa2:	f0 06 18 00 	cp.b	r6,r8
80002aa6:	e0 8b 00 5e 	brhi	80002b62 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80002aaa:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002aae:	30 18       	mov	r8,1
80002ab0:	f0 04 18 00 	cp.b	r4,r8
80002ab4:	e0 8b 00 57 	brhi	80002b62 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002ab8:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002abc:	30 78       	mov	r8,7
80002abe:	f0 03 18 00 	cp.b	r3,r8
80002ac2:	e0 88 00 50 	brls	80002b62 <spi_setupChipReg+0xce>
80002ac6:	31 08       	mov	r8,16
80002ac8:	f0 03 18 00 	cp.b	r3,r8
80002acc:	e0 8b 00 4b 	brhi	80002b62 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002ad0:	14 9b       	mov	r11,r10
80002ad2:	6e 1c       	ld.w	r12,r7[0x4]
80002ad4:	f0 1f 00 26 	mcall	80002b6c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80002ad8:	c4 55       	brlt	80002b62 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002ada:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002adc:	ec 09 16 01 	lsr	r9,r6,0x1
80002ae0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002ae4:	ec 16 00 01 	eorl	r6,0x1
80002ae8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002aec:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002af0:	20 83       	sub	r3,8
80002af2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002af6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002afa:	ef 39 00 09 	ld.ub	r9,r7[9]
80002afe:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002b02:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002b06:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002b0a:	0f 89       	ld.ub	r9,r7[0x0]
80002b0c:	30 1a       	mov	r10,1
80002b0e:	f4 09 18 00 	cp.b	r9,r10
80002b12:	c0 d0       	breq	80002b2c <spi_setupChipReg+0x98>
80002b14:	c0 a3       	brcs	80002b28 <spi_setupChipReg+0x94>
80002b16:	30 2a       	mov	r10,2
80002b18:	f4 09 18 00 	cp.b	r9,r10
80002b1c:	c0 a0       	breq	80002b30 <spi_setupChipReg+0x9c>
80002b1e:	30 3a       	mov	r10,3
80002b20:	f4 09 18 00 	cp.b	r9,r10
80002b24:	c1 f1       	brne	80002b62 <spi_setupChipReg+0xce>
80002b26:	c0 78       	rjmp	80002b34 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002b28:	8b c8       	st.w	r5[0x30],r8
		break;
80002b2a:	c0 68       	rjmp	80002b36 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002b2c:	8b d8       	st.w	r5[0x34],r8
		break;
80002b2e:	c0 48       	rjmp	80002b36 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002b30:	8b e8       	st.w	r5[0x38],r8
		break;
80002b32:	c0 28       	rjmp	80002b36 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002b34:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80002b36:	48 f8       	lddpc	r8,80002b70 <spi_setupChipReg+0xdc>
80002b38:	70 08       	ld.w	r8,r8[0x0]
80002b3a:	58 08       	cp.w	r8,0
80002b3c:	c1 61       	brne	80002b68 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80002b3e:	30 0b       	mov	r11,0
80002b40:	30 1c       	mov	r12,1
80002b42:	f0 1f 00 0d 	mcall	80002b74 <spi_setupChipReg+0xe0>
80002b46:	48 b8       	lddpc	r8,80002b70 <spi_setupChipReg+0xdc>
80002b48:	91 0c       	st.w	r8[0x0],r12
80002b4a:	58 0c       	cp.w	r12,0
80002b4c:	c0 a0       	breq	80002b60 <spi_setupChipReg+0xcc>
80002b4e:	30 09       	mov	r9,0
80002b50:	12 9a       	mov	r10,r9
80002b52:	12 9b       	mov	r11,r9
80002b54:	f0 1f 00 09 	mcall	80002b78 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80002b58:	48 68       	lddpc	r8,80002b70 <spi_setupChipReg+0xdc>
80002b5a:	70 08       	ld.w	r8,r8[0x0]
80002b5c:	58 08       	cp.w	r8,0
80002b5e:	c0 51       	brne	80002b68 <spi_setupChipReg+0xd4>
80002b60:	c0 08       	rjmp	80002b60 <spi_setupChipReg+0xcc>
80002b62:	30 2c       	mov	r12,2
80002b64:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002b68:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	29 ce       	sub	lr,-100
80002b70:	00 00       	add	r0,r0
80002b72:	07 88       	ld.ub	r8,r3[0x0]
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	31 78       	mov	r8,23
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	30 78       	mov	r8,7

80002b7c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002b7c:	d4 01       	pushm	lr
80002b7e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b82:	c0 58       	rjmp	80002b8c <spi_unselectChip+0x10>
		if (!timeout--) {
80002b84:	58 08       	cp.w	r8,0
80002b86:	c0 21       	brne	80002b8a <spi_unselectChip+0xe>
80002b88:	da 0a       	popm	pc,r12=1
80002b8a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b8c:	78 49       	ld.w	r9,r12[0x10]
80002b8e:	e2 19 02 00 	andl	r9,0x200,COH
80002b92:	cf 90       	breq	80002b84 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002b94:	78 18       	ld.w	r8,r12[0x4]
80002b96:	ea 18 00 0f 	orh	r8,0xf
80002b9a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002b9c:	fc 18 01 00 	movh	r8,0x100
80002ba0:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80002ba2:	30 09       	mov	r9,0
80002ba4:	12 9a       	mov	r10,r9
80002ba6:	12 9b       	mov	r11,r9
80002ba8:	48 38       	lddpc	r8,80002bb4 <spi_unselectChip+0x38>
80002baa:	70 0c       	ld.w	r12,r8[0x0]
80002bac:	f0 1f 00 03 	mcall	80002bb8 <spi_unselectChip+0x3c>
80002bb0:	d8 0a       	popm	pc,r12=0
80002bb2:	00 00       	add	r0,r0
80002bb4:	00 00       	add	r0,r0
80002bb6:	07 88       	ld.ub	r8,r3[0x0]
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	30 78       	mov	r8,7

80002bbc <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002bbc:	eb cd 40 f8 	pushm	r3-r7,lr
80002bc0:	18 94       	mov	r4,r12
80002bc2:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80002bc4:	49 a6       	lddpc	r6,80002c2c <spi_selectChip+0x70>
80002bc6:	30 07       	mov	r7,0
80002bc8:	31 45       	mov	r5,20
80002bca:	0e 99       	mov	r9,r7
80002bcc:	0a 9a       	mov	r10,r5
80002bce:	0e 9b       	mov	r11,r7
80002bd0:	6c 0c       	ld.w	r12,r6[0x0]
80002bd2:	f0 1f 00 18 	mcall	80002c30 <spi_selectChip+0x74>
80002bd6:	cf a0       	breq	80002bca <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002bd8:	68 18       	ld.w	r8,r4[0x4]
80002bda:	ea 18 00 0f 	orh	r8,0xf
80002bde:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002be0:	68 18       	ld.w	r8,r4[0x4]
80002be2:	e2 18 00 04 	andl	r8,0x4,COH
80002be6:	c1 10       	breq	80002c08 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002be8:	30 e8       	mov	r8,14
80002bea:	f0 03 18 00 	cp.b	r3,r8
80002bee:	e0 8b 00 1c 	brhi	80002c26 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002bf2:	68 19       	ld.w	r9,r4[0x4]
80002bf4:	e6 08 15 10 	lsl	r8,r3,0x10
80002bf8:	ea 18 ff f0 	orh	r8,0xfff0
80002bfc:	e8 18 ff ff 	orl	r8,0xffff
80002c00:	12 68       	and	r8,r9
80002c02:	89 18       	st.w	r4[0x4],r8
80002c04:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002c08:	30 38       	mov	r8,3
80002c0a:	f0 03 18 00 	cp.b	r3,r8
80002c0e:	e0 8b 00 0c 	brhi	80002c26 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002c12:	68 19       	ld.w	r9,r4[0x4]
80002c14:	2f 03       	sub	r3,-16
80002c16:	30 18       	mov	r8,1
80002c18:	f0 03 09 48 	lsl	r8,r8,r3
80002c1c:	5c d8       	com	r8
80002c1e:	12 68       	and	r8,r9
80002c20:	89 18       	st.w	r4[0x4],r8
80002c22:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002c26:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002c28:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002c2c:	00 00       	add	r0,r0
80002c2e:	07 88       	ld.ub	r8,r3[0x0]
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	2f 5c       	sub	r12,-11

80002c34 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002c34:	f8 c8 ff f8 	sub	r8,r12,-8
80002c38:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002c3a:	3f f9       	mov	r9,-1
80002c3c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002c3e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002c40:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002c42:	30 08       	mov	r8,0
80002c44:	99 08       	st.w	r12[0x0],r8
}
80002c46:	5e fc       	retal	r12

80002c48 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002c48:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80002c4a:	70 19       	ld.w	r9,r8[0x4]
80002c4c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002c4e:	78 19       	ld.w	r9,r12[0x4]
80002c50:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002c52:	70 19       	ld.w	r9,r8[0x4]
80002c54:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002c56:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002c58:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002c5a:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c5c:	78 08       	ld.w	r8,r12[0x0]
80002c5e:	2f f8       	sub	r8,-1
80002c60:	99 08       	st.w	r12[0x0],r8
}
80002c62:	5e fc       	retal	r12

80002c64 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002c64:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002c66:	5b fa       	cp.w	r10,-1
80002c68:	c0 31       	brne	80002c6e <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002c6a:	78 48       	ld.w	r8,r12[0x10]
80002c6c:	c0 c8       	rjmp	80002c84 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002c6e:	f8 c8 ff f8 	sub	r8,r12,-8
80002c72:	70 19       	ld.w	r9,r8[0x4]
80002c74:	72 09       	ld.w	r9,r9[0x0]
80002c76:	12 3a       	cp.w	r10,r9
80002c78:	c0 63       	brcs	80002c84 <vListInsert+0x20>
80002c7a:	70 18       	ld.w	r8,r8[0x4]
80002c7c:	70 19       	ld.w	r9,r8[0x4]
80002c7e:	72 09       	ld.w	r9,r9[0x0]
80002c80:	12 3a       	cp.w	r10,r9
80002c82:	cf c2       	brcc	80002c7a <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002c84:	70 19       	ld.w	r9,r8[0x4]
80002c86:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002c88:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80002c8a:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002c8c:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002c8e:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c90:	78 08       	ld.w	r8,r12[0x0]
80002c92:	2f f8       	sub	r8,-1
80002c94:	99 08       	st.w	r12[0x0],r8
}
80002c96:	5e fc       	retal	r12

80002c98 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002c98:	78 18       	ld.w	r8,r12[0x4]
80002c9a:	78 29       	ld.w	r9,r12[0x8]
80002c9c:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002c9e:	78 28       	ld.w	r8,r12[0x8]
80002ca0:	78 19       	ld.w	r9,r12[0x4]
80002ca2:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002ca4:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002ca6:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002ca8:	18 39       	cp.w	r9,r12
80002caa:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80002cae:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002cb2:	30 09       	mov	r9,0
80002cb4:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80002cb6:	70 09       	ld.w	r9,r8[0x0]
80002cb8:	20 19       	sub	r9,1
80002cba:	91 09       	st.w	r8[0x0],r9
}
80002cbc:	5e fc       	retal	r12
80002cbe:	d7 03       	nop

80002cc0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002cc0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002cc2:	48 38       	lddpc	r8,80002ccc <vPortEnterCritical+0xc>
80002cc4:	70 09       	ld.w	r9,r8[0x0]
80002cc6:	2f f9       	sub	r9,-1
80002cc8:	91 09       	st.w	r8[0x0],r9
}
80002cca:	5e fc       	retal	r12
80002ccc:	00 00       	add	r0,r0
80002cce:	00 20       	rsub	r0,r0

80002cd0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80002cd0:	20 6d       	sub	sp,24
80002cd2:	eb cd 00 ff 	pushm	r0-r7
80002cd6:	fa c7 ff c0 	sub	r7,sp,-64
80002cda:	ee f0 ff f8 	ld.w	r0,r7[-8]
80002cde:	ef 40 ff e0 	st.w	r7[-32],r0
80002ce2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80002ce6:	ef 40 ff e4 	st.w	r7[-28],r0
80002cea:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80002cee:	e0 68 00 20 	mov	r8,32
80002cf2:	ea 18 00 00 	orh	r8,0x0
80002cf6:	70 00       	ld.w	r0,r8[0x0]
80002cf8:	1a d0       	st.w	--sp,r0
80002cfa:	f0 1f 00 1a 	mcall	80002d60 <LABEL_RET_SCALL_260+0x14>
80002cfe:	e0 68 07 0c 	mov	r8,1804
80002d02:	ea 18 00 00 	orh	r8,0x0
80002d06:	70 00       	ld.w	r0,r8[0x0]
80002d08:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80002d0a:	f0 1f 00 17 	mcall	80002d64 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80002d0e:	e0 68 07 0c 	mov	r8,1804
80002d12:	ea 18 00 00 	orh	r8,0x0
80002d16:	70 00       	ld.w	r0,r8[0x0]
80002d18:	60 0d       	ld.w	sp,r0[0x0]
80002d1a:	1b 00       	ld.w	r0,sp++
80002d1c:	e0 68 00 20 	mov	r8,32
80002d20:	ea 18 00 00 	orh	r8,0x0
80002d24:	91 00       	st.w	r8[0x0],r0
80002d26:	fa c7 ff d8 	sub	r7,sp,-40
80002d2a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80002d2e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80002d32:	e0 61 00 20 	mov	r1,32
80002d36:	ea 11 00 00 	orh	r1,0x0
80002d3a:	62 02       	ld.w	r2,r1[0x0]
80002d3c:	58 02       	cp.w	r2,0
80002d3e:	c0 70       	breq	80002d4c <LABEL_RET_SCALL_260>
80002d40:	e4 c2 00 01 	sub	r2,r2,1
80002d44:	83 02       	st.w	r1[0x0],r2
80002d46:	58 02       	cp.w	r2,0
80002d48:	c0 21       	brne	80002d4c <LABEL_RET_SCALL_260>
80002d4a:	b1 c0       	cbr	r0,0x10

80002d4c <LABEL_RET_SCALL_260>:
80002d4c:	ef 40 ff f8 	st.w	r7[-8],r0
80002d50:	ee f0 ff e4 	ld.w	r0,r7[-28]
80002d54:	ef 40 ff fc 	st.w	r7[-4],r0
80002d58:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002d5c:	2f ad       	sub	sp,-24
80002d5e:	d6 13       	rets
80002d60:	80 00       	ld.sh	r0,r0[0x0]
80002d62:	2c c0       	sub	r0,-52
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	31 fc       	mov	r12,31

80002d68 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80002d68:	48 78       	lddpc	r8,80002d84 <vPortExitCritical+0x1c>
80002d6a:	70 08       	ld.w	r8,r8[0x0]
80002d6c:	58 08       	cp.w	r8,0
80002d6e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80002d70:	48 58       	lddpc	r8,80002d84 <vPortExitCritical+0x1c>
80002d72:	70 09       	ld.w	r9,r8[0x0]
80002d74:	20 19       	sub	r9,1
80002d76:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80002d78:	70 08       	ld.w	r8,r8[0x0]
80002d7a:	58 08       	cp.w	r8,0
80002d7c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80002d7e:	d5 03       	csrf	0x10
80002d80:	5e fc       	retal	r12
80002d82:	00 00       	add	r0,r0
80002d84:	00 00       	add	r0,r0
80002d86:	00 20       	rsub	r0,r0

80002d88 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002d88:	d4 01       	pushm	lr
	vTaskSuspendAll();
80002d8a:	f0 1f 00 02 	mcall	80002d90 <__malloc_lock+0x8>
}
80002d8e:	d8 02       	popm	pc
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	31 ec       	mov	r12,30

80002d94 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002d94:	d4 01       	pushm	lr
	xTaskResumeAll();
80002d96:	f0 1f 00 02 	mcall	80002d9c <__malloc_unlock+0x8>
}
80002d9a:	d8 02       	popm	pc
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	34 9c       	mov	r12,73

80002da0 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002da0:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002da2:	48 a8       	lddpc	r8,80002dc8 <_init_startup+0x28>
80002da4:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002da8:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002daa:	f0 1f 00 09 	mcall	80002dcc <_init_startup+0x2c>

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002dae:	48 98       	lddpc	r8,80002dd0 <_init_startup+0x30>
80002db0:	48 99       	lddpc	r9,80002dd4 <_init_startup+0x34>
80002db2:	12 38       	cp.w	r8,r9
80002db4:	c0 82       	brcc	80002dc4 <_init_startup+0x24>
		{
			*pxMem++ = 0xA5A5A5A5;
80002db6:	e0 6a a5 a5 	mov	r10,42405
80002dba:	ea 1a a5 a5 	orh	r10,0xa5a5
80002dbe:	10 aa       	st.w	r8++,r10
	INTC_init_interrupts();

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002dc0:	12 38       	cp.w	r8,r9
80002dc2:	cf e3       	brcs	80002dbe <_init_startup+0x1e>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80002dc4:	da 0a       	popm	pc,r12=1
80002dc6:	00 00       	add	r0,r0
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	46 00       	lddsp	r0,sp[0x180]
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	27 c4       	sub	r4,124
80002dd0:	00 00       	add	r0,r0
80002dd2:	07 98       	ld.ub	r8,r3[0x1]
80002dd4:	00 00       	add	r0,r0
80002dd6:	f0 00       	*unknown*

80002dd8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80002dd8:	eb cd 40 80 	pushm	r7,lr
80002ddc:	18 97       	mov	r7,r12
	if( pv )
80002dde:	58 0c       	cp.w	r12,0
80002de0:	c0 80       	breq	80002df0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80002de2:	f0 1f 00 05 	mcall	80002df4 <vPortFree+0x1c>
		{
			free( pv );
80002de6:	0e 9c       	mov	r12,r7
80002de8:	f0 1f 00 04 	mcall	80002df8 <vPortFree+0x20>
		}
		xTaskResumeAll();
80002dec:	f0 1f 00 04 	mcall	80002dfc <vPortFree+0x24>
80002df0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	31 ec       	mov	r12,30
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	3a c4       	mov	r4,-84
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	34 9c       	mov	r12,73

80002e00 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002e00:	eb cd 40 80 	pushm	r7,lr
80002e04:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80002e06:	f0 1f 00 06 	mcall	80002e1c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80002e0a:	0e 9c       	mov	r12,r7
80002e0c:	f0 1f 00 05 	mcall	80002e20 <pvPortMalloc+0x20>
80002e10:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80002e12:	f0 1f 00 05 	mcall	80002e24 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80002e16:	0e 9c       	mov	r12,r7
80002e18:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	31 ec       	mov	r12,30
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	3a d4       	mov	r4,-83
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	34 9c       	mov	r12,73

80002e28 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80002e28:	d4 01       	pushm	lr
80002e2a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002e2c:	78 09       	ld.w	r9,r12[0x0]
80002e2e:	58 09       	cp.w	r9,0
80002e30:	c1 10       	breq	80002e52 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80002e32:	78 3a       	ld.w	r10,r12[0xc]
80002e34:	79 09       	ld.w	r9,r12[0x40]
80002e36:	f4 09 00 09 	add	r9,r10,r9
80002e3a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80002e3c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80002e3e:	14 39       	cp.w	r9,r10
80002e40:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002e44:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80002e48:	79 0a       	ld.w	r10,r12[0x40]
80002e4a:	78 3b       	ld.w	r11,r12[0xc]
80002e4c:	10 9c       	mov	r12,r8
80002e4e:	f0 1f 00 02 	mcall	80002e54 <prvCopyDataFromQueue+0x2c>
80002e52:	d8 02       	popm	pc
80002e54:	80 00       	ld.sh	r0,r0[0x0]
80002e56:	3f 18       	mov	r8,-15

80002e58 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002e58:	eb cd 40 80 	pushm	r7,lr
80002e5c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002e5e:	79 08       	ld.w	r8,r12[0x40]
80002e60:	58 08       	cp.w	r8,0
80002e62:	c2 50       	breq	80002eac <prvCopyDataToQueue+0x54>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80002e64:	58 0a       	cp.w	r10,0
80002e66:	c1 01       	brne	80002e86 <prvCopyDataToQueue+0x2e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e68:	10 9a       	mov	r10,r8
80002e6a:	78 2c       	ld.w	r12,r12[0x8]
80002e6c:	f0 1f 00 13 	mcall	80002eb8 <prvCopyDataToQueue+0x60>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002e70:	6e 29       	ld.w	r9,r7[0x8]
80002e72:	6f 08       	ld.w	r8,r7[0x40]
80002e74:	f2 08 00 08 	add	r8,r9,r8
80002e78:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80002e7a:	6e 19       	ld.w	r9,r7[0x4]
80002e7c:	12 38       	cp.w	r8,r9
80002e7e:	c1 73       	brcs	80002eac <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002e80:	6e 08       	ld.w	r8,r7[0x0]
80002e82:	8f 28       	st.w	r7[0x8],r8
80002e84:	c1 48       	rjmp	80002eac <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e86:	10 9a       	mov	r10,r8
80002e88:	78 3c       	ld.w	r12,r12[0xc]
80002e8a:	f0 1f 00 0c 	mcall	80002eb8 <prvCopyDataToQueue+0x60>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80002e8e:	6f 08       	ld.w	r8,r7[0x40]
80002e90:	6e 39       	ld.w	r9,r7[0xc]
80002e92:	f2 08 01 08 	sub	r8,r9,r8
80002e96:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80002e98:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002e9a:	12 38       	cp.w	r8,r9
80002e9c:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002ea0:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002ea4:	f3 d8 e3 19 	subcs	r9,r9,r8
80002ea8:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002eac:	6e e8       	ld.w	r8,r7[0x38]
80002eae:	2f f8       	sub	r8,-1
80002eb0:	8f e8       	st.w	r7[0x38],r8
}
80002eb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80002eb6:	00 00       	add	r0,r0
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	3f 18       	mov	r8,-15

80002ebc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80002ebc:	eb cd 40 c0 	pushm	r6-r7,lr
80002ec0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002ec2:	f0 1f 00 23 	mcall	80002f4c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002ec6:	6f 28       	ld.w	r8,r7[0x48]
80002ec8:	58 08       	cp.w	r8,0
80002eca:	e0 8a 00 18 	brle	80002efa <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002ece:	6e 98       	ld.w	r8,r7[0x24]
80002ed0:	58 08       	cp.w	r8,0
80002ed2:	c1 40       	breq	80002efa <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002ed4:	ee c6 ff dc 	sub	r6,r7,-36
80002ed8:	c0 48       	rjmp	80002ee0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002eda:	6e 98       	ld.w	r8,r7[0x24]
80002edc:	58 08       	cp.w	r8,0
80002ede:	c0 e0       	breq	80002efa <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002ee0:	0c 9c       	mov	r12,r6
80002ee2:	f0 1f 00 1c 	mcall	80002f50 <prvUnlockQueue+0x94>
80002ee6:	c0 30       	breq	80002eec <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80002ee8:	f0 1f 00 1b 	mcall	80002f54 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80002eec:	6f 28       	ld.w	r8,r7[0x48]
80002eee:	20 18       	sub	r8,1
80002ef0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002ef4:	58 08       	cp.w	r8,0
80002ef6:	fe 99 ff f2 	brgt	80002eda <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002efa:	3f f8       	mov	r8,-1
80002efc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002f00:	f0 1f 00 16 	mcall	80002f58 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002f04:	f0 1f 00 12 	mcall	80002f4c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002f08:	6f 18       	ld.w	r8,r7[0x44]
80002f0a:	58 08       	cp.w	r8,0
80002f0c:	e0 8a 00 18 	brle	80002f3c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f10:	6e 48       	ld.w	r8,r7[0x10]
80002f12:	58 08       	cp.w	r8,0
80002f14:	c1 40       	breq	80002f3c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002f16:	ee c6 ff f0 	sub	r6,r7,-16
80002f1a:	c0 48       	rjmp	80002f22 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f1c:	6e 48       	ld.w	r8,r7[0x10]
80002f1e:	58 08       	cp.w	r8,0
80002f20:	c0 e0       	breq	80002f3c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002f22:	0c 9c       	mov	r12,r6
80002f24:	f0 1f 00 0b 	mcall	80002f50 <prvUnlockQueue+0x94>
80002f28:	c0 30       	breq	80002f2e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80002f2a:	f0 1f 00 0b 	mcall	80002f54 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80002f2e:	6f 18       	ld.w	r8,r7[0x44]
80002f30:	20 18       	sub	r8,1
80002f32:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002f36:	58 08       	cp.w	r8,0
80002f38:	fe 99 ff f2 	brgt	80002f1c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002f3c:	3f f8       	mov	r8,-1
80002f3e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002f42:	f0 1f 00 06 	mcall	80002f58 <prvUnlockQueue+0x9c>
}
80002f46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f4a:	00 00       	add	r0,r0
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	2c c0       	sub	r0,-52
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	33 0c       	mov	r12,48
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	32 90       	mov	r0,41
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	2d 68       	sub	r8,-42

80002f5c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002f5c:	d4 31       	pushm	r0-r7,lr
80002f5e:	20 5d       	sub	sp,20
80002f60:	18 97       	mov	r7,r12
80002f62:	50 0b       	stdsp	sp[0x0],r11
80002f64:	50 2a       	stdsp	sp[0x8],r10
80002f66:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002f68:	f8 c1 ff dc 	sub	r1,r12,-36
80002f6c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f6e:	fa c4 ff f4 	sub	r4,sp,-12
80002f72:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002f74:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002f76:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002f7a:	f0 1f 00 36 	mcall	80003050 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002f7e:	6e e8       	ld.w	r8,r7[0x38]
80002f80:	58 08       	cp.w	r8,0
80002f82:	c2 40       	breq	80002fca <xQueueGenericReceive+0x6e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80002f84:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002f86:	40 0b       	lddsp	r11,sp[0x0]
80002f88:	0e 9c       	mov	r12,r7
80002f8a:	f0 1f 00 33 	mcall	80003054 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002f8e:	40 18       	lddsp	r8,sp[0x4]
80002f90:	58 08       	cp.w	r8,0
80002f92:	c0 f1       	brne	80002fb0 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80002f94:	6e e8       	ld.w	r8,r7[0x38]
80002f96:	20 18       	sub	r8,1
80002f98:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f9a:	6e 48       	ld.w	r8,r7[0x10]
80002f9c:	58 08       	cp.w	r8,0
80002f9e:	c1 20       	breq	80002fc2 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002fa0:	ee cc ff f0 	sub	r12,r7,-16
80002fa4:	f0 1f 00 2d 	mcall	80003058 <xQueueGenericReceive+0xfc>
80002fa8:	58 1c       	cp.w	r12,1
80002faa:	c0 c1       	brne	80002fc2 <xQueueGenericReceive+0x66>
						{
							portYIELD_WITHIN_API();
80002fac:	d7 33       	scall
80002fae:	c0 a8       	rjmp	80002fc2 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80002fb0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002fb2:	6e 98       	ld.w	r8,r7[0x24]
80002fb4:	58 08       	cp.w	r8,0
80002fb6:	c0 60       	breq	80002fc2 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002fb8:	02 9c       	mov	r12,r1
80002fba:	f0 1f 00 28 	mcall	80003058 <xQueueGenericReceive+0xfc>
80002fbe:	c0 20       	breq	80002fc2 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80002fc0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80002fc2:	f0 1f 00 27 	mcall	8000305c <xQueueGenericReceive+0x100>
80002fc6:	30 1c       	mov	r12,1
				return pdPASS;
80002fc8:	c4 28       	rjmp	8000304c <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002fca:	40 28       	lddsp	r8,sp[0x8]
80002fcc:	58 08       	cp.w	r8,0
80002fce:	c0 51       	brne	80002fd8 <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002fd0:	f0 1f 00 23 	mcall	8000305c <xQueueGenericReceive+0x100>
80002fd4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002fd6:	c3 b8       	rjmp	8000304c <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002fd8:	58 05       	cp.w	r5,0
80002fda:	c0 51       	brne	80002fe4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002fdc:	08 9c       	mov	r12,r4
80002fde:	f0 1f 00 21 	mcall	80003060 <xQueueGenericReceive+0x104>
80002fe2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80002fe4:	f0 1f 00 1e 	mcall	8000305c <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002fe8:	f0 1f 00 1f 	mcall	80003064 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002fec:	f0 1f 00 19 	mcall	80003050 <xQueueGenericReceive+0xf4>
80002ff0:	6f 18       	ld.w	r8,r7[0x44]
80002ff2:	5b f8       	cp.w	r8,-1
80002ff4:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002ff8:	6f 28       	ld.w	r8,r7[0x48]
80002ffa:	5b f8       	cp.w	r8,-1
80002ffc:	ef f2 0a 12 	st.weq	r7[0x48],r2
80003000:	f0 1f 00 17 	mcall	8000305c <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003004:	06 9b       	mov	r11,r3
80003006:	08 9c       	mov	r12,r4
80003008:	f0 1f 00 18 	mcall	80003068 <xQueueGenericReceive+0x10c>
8000300c:	c1 a1       	brne	80003040 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000300e:	f0 1f 00 11 	mcall	80003050 <xQueueGenericReceive+0xf4>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80003012:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80003014:	f0 1f 00 12 	mcall	8000305c <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80003018:	58 06       	cp.w	r6,0
8000301a:	c0 d1       	brne	80003034 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000301c:	40 2b       	lddsp	r11,sp[0x8]
8000301e:	02 9c       	mov	r12,r1
80003020:	f0 1f 00 13 	mcall	8000306c <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80003024:	0e 9c       	mov	r12,r7
80003026:	f0 1f 00 13 	mcall	80003070 <xQueueGenericReceive+0x114>
				if( !xTaskResumeAll() )
8000302a:	f0 1f 00 13 	mcall	80003074 <xQueueGenericReceive+0x118>
8000302e:	ca 61       	brne	80002f7a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80003030:	d7 33       	scall
80003032:	ca 4b       	rjmp	80002f7a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80003034:	0e 9c       	mov	r12,r7
80003036:	f0 1f 00 0f 	mcall	80003070 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
8000303a:	f0 1f 00 0f 	mcall	80003074 <xQueueGenericReceive+0x118>
8000303e:	c9 eb       	rjmp	80002f7a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80003040:	0e 9c       	mov	r12,r7
80003042:	f0 1f 00 0c 	mcall	80003070 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80003046:	f0 1f 00 0c 	mcall	80003074 <xQueueGenericReceive+0x118>
8000304a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000304c:	2f bd       	sub	sp,-20
8000304e:	d8 32       	popm	r0-r7,pc
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	2c c0       	sub	r0,-52
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	2e 28       	sub	r8,-30
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	33 0c       	mov	r12,48
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	2d 68       	sub	r8,-42
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	32 78       	mov	r8,39
80003064:	80 00       	ld.sh	r0,r0[0x0]
80003066:	31 ec       	mov	r12,30
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	32 9c       	mov	r12,41
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	35 e0       	mov	r0,94
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	2e bc       	sub	r12,-21
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	34 9c       	mov	r12,73

80003078 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80003078:	d4 31       	pushm	r0-r7,lr
8000307a:	20 5d       	sub	sp,20
8000307c:	18 97       	mov	r7,r12
8000307e:	50 0b       	stdsp	sp[0x0],r11
80003080:	50 2a       	stdsp	sp[0x8],r10
80003082:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003084:	f8 c0 ff f0 	sub	r0,r12,-16
80003088:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000308a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000308e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003090:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80003094:	f0 1f 00 2f 	mcall	80003150 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80003098:	6e e9       	ld.w	r9,r7[0x38]
8000309a:	6e f8       	ld.w	r8,r7[0x3c]
8000309c:	10 39       	cp.w	r9,r8
8000309e:	c1 42       	brcc	800030c6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800030a0:	40 1a       	lddsp	r10,sp[0x4]
800030a2:	40 0b       	lddsp	r11,sp[0x0]
800030a4:	0e 9c       	mov	r12,r7
800030a6:	f0 1f 00 2c 	mcall	80003154 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800030aa:	6e 98       	ld.w	r8,r7[0x24]
800030ac:	58 08       	cp.w	r8,0
800030ae:	c0 80       	breq	800030be <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800030b0:	ee cc ff dc 	sub	r12,r7,-36
800030b4:	f0 1f 00 29 	mcall	80003158 <xQueueGenericSend+0xe0>
800030b8:	58 1c       	cp.w	r12,1
800030ba:	c0 21       	brne	800030be <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800030bc:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800030be:	f0 1f 00 28 	mcall	8000315c <xQueueGenericSend+0xe4>
800030c2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800030c4:	c4 38       	rjmp	8000314a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800030c6:	40 28       	lddsp	r8,sp[0x8]
800030c8:	58 08       	cp.w	r8,0
800030ca:	c0 51       	brne	800030d4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800030cc:	f0 1f 00 24 	mcall	8000315c <xQueueGenericSend+0xe4>
800030d0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800030d2:	c3 c8       	rjmp	8000314a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800030d4:	58 04       	cp.w	r4,0
800030d6:	c0 51       	brne	800030e0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800030d8:	06 9c       	mov	r12,r3
800030da:	f0 1f 00 22 	mcall	80003160 <xQueueGenericSend+0xe8>
800030de:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800030e0:	f0 1f 00 1f 	mcall	8000315c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800030e4:	f0 1f 00 20 	mcall	80003164 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800030e8:	f0 1f 00 1a 	mcall	80003150 <xQueueGenericSend+0xd8>
800030ec:	6f 18       	ld.w	r8,r7[0x44]
800030ee:	5b f8       	cp.w	r8,-1
800030f0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800030f4:	6f 28       	ld.w	r8,r7[0x48]
800030f6:	5b f8       	cp.w	r8,-1
800030f8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800030fc:	f0 1f 00 18 	mcall	8000315c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003100:	04 9b       	mov	r11,r2
80003102:	06 9c       	mov	r12,r3
80003104:	f0 1f 00 19 	mcall	80003168 <xQueueGenericSend+0xf0>
80003108:	c1 b1       	brne	8000313e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000310a:	f0 1f 00 12 	mcall	80003150 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000310e:	6e e5       	ld.w	r5,r7[0x38]
80003110:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80003112:	f0 1f 00 13 	mcall	8000315c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80003116:	0c 35       	cp.w	r5,r6
80003118:	c0 d1       	brne	80003132 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000311a:	40 2b       	lddsp	r11,sp[0x8]
8000311c:	00 9c       	mov	r12,r0
8000311e:	f0 1f 00 14 	mcall	8000316c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80003122:	0e 9c       	mov	r12,r7
80003124:	f0 1f 00 13 	mcall	80003170 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80003128:	f0 1f 00 13 	mcall	80003174 <xQueueGenericSend+0xfc>
8000312c:	cb 41       	brne	80003094 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000312e:	d7 33       	scall
80003130:	cb 2b       	rjmp	80003094 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80003132:	0e 9c       	mov	r12,r7
80003134:	f0 1f 00 0f 	mcall	80003170 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80003138:	f0 1f 00 0f 	mcall	80003174 <xQueueGenericSend+0xfc>
8000313c:	ca cb       	rjmp	80003094 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000313e:	0e 9c       	mov	r12,r7
80003140:	f0 1f 00 0c 	mcall	80003170 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80003144:	f0 1f 00 0c 	mcall	80003174 <xQueueGenericSend+0xfc>
80003148:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000314a:	2f bd       	sub	sp,-20
8000314c:	d8 32       	popm	r0-r7,pc
8000314e:	00 00       	add	r0,r0
80003150:	80 00       	ld.sh	r0,r0[0x0]
80003152:	2c c0       	sub	r0,-52
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	2e 58       	sub	r8,-27
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	33 0c       	mov	r12,48
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	2d 68       	sub	r8,-42
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	32 78       	mov	r8,39
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	31 ec       	mov	r12,30
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	32 9c       	mov	r12,41
8000316c:	80 00       	ld.sh	r0,r0[0x0]
8000316e:	35 e0       	mov	r0,94
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	2e bc       	sub	r12,-21
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	34 9c       	mov	r12,73

80003178 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80003178:	d4 21       	pushm	r4-r7,lr
8000317a:	18 97       	mov	r7,r12
8000317c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000317e:	58 0c       	cp.w	r12,0
80003180:	c2 f0       	breq	800031de <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003182:	34 cc       	mov	r12,76
80003184:	f0 1f 00 17 	mcall	800031e0 <xQueueCreate+0x68>
80003188:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000318a:	c2 a0       	breq	800031de <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000318c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80003190:	e8 cc ff ff 	sub	r12,r4,-1
80003194:	f0 1f 00 13 	mcall	800031e0 <xQueueCreate+0x68>
80003198:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000319a:	c1 e0       	breq	800031d6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000319c:	f8 04 00 04 	add	r4,r12,r4
800031a0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800031a2:	30 08       	mov	r8,0
800031a4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800031a6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800031a8:	ee c8 00 01 	sub	r8,r7,1
800031ac:	ad 38       	mul	r8,r6
800031ae:	10 0c       	add	r12,r8
800031b0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800031b2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800031b4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800031b8:	3f f8       	mov	r8,-1
800031ba:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800031be:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800031c2:	ea cc ff f0 	sub	r12,r5,-16
800031c6:	f0 1f 00 08 	mcall	800031e4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800031ca:	ea cc ff dc 	sub	r12,r5,-36
800031ce:	f0 1f 00 06 	mcall	800031e4 <xQueueCreate+0x6c>
800031d2:	0a 9c       	mov	r12,r5
800031d4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800031d6:	0a 9c       	mov	r12,r5
800031d8:	f0 1f 00 04 	mcall	800031e8 <xQueueCreate+0x70>
800031dc:	d8 2a       	popm	r4-r7,pc,r12=0
800031de:	d8 2a       	popm	r4-r7,pc,r12=0
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	2e 00       	sub	r0,-32
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	2c 34       	sub	r4,-61
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	2d d8       	sub	r8,-35

800031ec <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800031ec:	48 38       	lddpc	r8,800031f8 <vTaskSuspendAll+0xc>
800031ee:	70 09       	ld.w	r9,r8[0x0]
800031f0:	2f f9       	sub	r9,-1
800031f2:	91 09       	st.w	r8[0x0],r9
}
800031f4:	5e fc       	retal	r12
800031f6:	00 00       	add	r0,r0
800031f8:	00 00       	add	r0,r0
800031fa:	07 28       	ld.uh	r8,r3++

800031fc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800031fc:	49 a8       	lddpc	r8,80003264 <vTaskSwitchContext+0x68>
800031fe:	70 08       	ld.w	r8,r8[0x0]
80003200:	58 08       	cp.w	r8,0
80003202:	c0 b1       	brne	80003218 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80003204:	49 98       	lddpc	r8,80003268 <vTaskSwitchContext+0x6c>
80003206:	70 08       	ld.w	r8,r8[0x0]
80003208:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000320c:	49 89       	lddpc	r9,8000326c <vTaskSwitchContext+0x70>
8000320e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80003212:	58 08       	cp.w	r8,0
80003214:	c0 60       	breq	80003220 <vTaskSwitchContext+0x24>
80003216:	c1 18       	rjmp	80003238 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80003218:	30 19       	mov	r9,1
8000321a:	49 68       	lddpc	r8,80003270 <vTaskSwitchContext+0x74>
8000321c:	91 09       	st.w	r8[0x0],r9
8000321e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80003220:	49 28       	lddpc	r8,80003268 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80003222:	49 3a       	lddpc	r10,8000326c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80003224:	70 09       	ld.w	r9,r8[0x0]
80003226:	20 19       	sub	r9,1
80003228:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000322a:	70 09       	ld.w	r9,r8[0x0]
8000322c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003230:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80003234:	58 09       	cp.w	r9,0
80003236:	cf 70       	breq	80003224 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80003238:	48 c8       	lddpc	r8,80003268 <vTaskSwitchContext+0x6c>
8000323a:	70 08       	ld.w	r8,r8[0x0]
8000323c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003240:	48 b9       	lddpc	r9,8000326c <vTaskSwitchContext+0x70>
80003242:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003246:	70 19       	ld.w	r9,r8[0x4]
80003248:	72 19       	ld.w	r9,r9[0x4]
8000324a:	91 19       	st.w	r8[0x4],r9
8000324c:	f0 ca ff f8 	sub	r10,r8,-8
80003250:	14 39       	cp.w	r9,r10
80003252:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80003256:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000325a:	70 18       	ld.w	r8,r8[0x4]
8000325c:	70 39       	ld.w	r9,r8[0xc]
8000325e:	48 68       	lddpc	r8,80003274 <vTaskSwitchContext+0x78>
80003260:	91 09       	st.w	r8[0x0],r9
80003262:	5e fc       	retal	r12
80003264:	00 00       	add	r0,r0
80003266:	07 28       	ld.uh	r8,r3++
80003268:	00 00       	add	r0,r0
8000326a:	07 48       	ld.w	r8,--r3
8000326c:	00 00       	add	r0,r0
8000326e:	06 6c       	and	r12,r3
80003270:	00 00       	add	r0,r0
80003272:	07 30       	ld.ub	r0,r3++
80003274:	00 00       	add	r0,r0
80003276:	07 0c       	ld.w	r12,r3++

80003278 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80003278:	48 48       	lddpc	r8,80003288 <vTaskSetTimeOutState+0x10>
8000327a:	70 08       	ld.w	r8,r8[0x0]
8000327c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000327e:	48 48       	lddpc	r8,8000328c <vTaskSetTimeOutState+0x14>
80003280:	70 08       	ld.w	r8,r8[0x0]
80003282:	99 18       	st.w	r12[0x4],r8
}
80003284:	5e fc       	retal	r12
80003286:	00 00       	add	r0,r0
80003288:	00 00       	add	r0,r0
8000328a:	06 64       	and	r4,r3
8000328c:	00 00       	add	r0,r0
8000328e:	07 24       	ld.uh	r4,r3++

80003290 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80003290:	30 19       	mov	r9,1
80003292:	48 28       	lddpc	r8,80003298 <vTaskMissedYield+0x8>
80003294:	91 09       	st.w	r8[0x0],r9
}
80003296:	5e fc       	retal	r12
80003298:	00 00       	add	r0,r0
8000329a:	07 30       	ld.ub	r0,r3++

8000329c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000329c:	eb cd 40 c0 	pushm	r6-r7,lr
800032a0:	18 97       	mov	r7,r12
800032a2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800032a4:	f0 1f 00 15 	mcall	800032f8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800032a8:	6c 08       	ld.w	r8,r6[0x0]
800032aa:	5b f8       	cp.w	r8,-1
800032ac:	c0 31       	brne	800032b2 <xTaskCheckForTimeOut+0x16>
800032ae:	30 07       	mov	r7,0
800032b0:	c1 f8       	rjmp	800032ee <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800032b2:	49 39       	lddpc	r9,800032fc <xTaskCheckForTimeOut+0x60>
800032b4:	72 09       	ld.w	r9,r9[0x0]
800032b6:	6e 0a       	ld.w	r10,r7[0x0]
800032b8:	12 3a       	cp.w	r10,r9
800032ba:	c0 70       	breq	800032c8 <xTaskCheckForTimeOut+0x2c>
800032bc:	49 19       	lddpc	r9,80003300 <xTaskCheckForTimeOut+0x64>
800032be:	72 09       	ld.w	r9,r9[0x0]
800032c0:	6e 1a       	ld.w	r10,r7[0x4]
800032c2:	12 3a       	cp.w	r10,r9
800032c4:	e0 88 00 14 	brls	800032ec <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800032c8:	48 e9       	lddpc	r9,80003300 <xTaskCheckForTimeOut+0x64>
800032ca:	72 0a       	ld.w	r10,r9[0x0]
800032cc:	6e 19       	ld.w	r9,r7[0x4]
800032ce:	12 1a       	sub	r10,r9
800032d0:	14 38       	cp.w	r8,r10
800032d2:	e0 88 00 0d 	brls	800032ec <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800032d6:	48 ba       	lddpc	r10,80003300 <xTaskCheckForTimeOut+0x64>
800032d8:	74 0a       	ld.w	r10,r10[0x0]
800032da:	14 19       	sub	r9,r10
800032dc:	f2 08 00 08 	add	r8,r9,r8
800032e0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800032e2:	0e 9c       	mov	r12,r7
800032e4:	f0 1f 00 08 	mcall	80003304 <xTaskCheckForTimeOut+0x68>
800032e8:	30 07       	mov	r7,0
800032ea:	c0 28       	rjmp	800032ee <xTaskCheckForTimeOut+0x52>
800032ec:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800032ee:	f0 1f 00 07 	mcall	80003308 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800032f2:	0e 9c       	mov	r12,r7
800032f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	2c c0       	sub	r0,-52
800032fc:	00 00       	add	r0,r0
800032fe:	06 64       	and	r4,r3
80003300:	00 00       	add	r0,r0
80003302:	07 24       	ld.uh	r4,r3++
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	32 78       	mov	r8,39
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	2d 68       	sub	r8,-42

8000330c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000330c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80003310:	78 38       	ld.w	r8,r12[0xc]
80003312:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80003314:	ee c6 ff e8 	sub	r6,r7,-24
80003318:	0c 9c       	mov	r12,r6
8000331a:	f0 1f 00 15 	mcall	8000336c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000331e:	49 58       	lddpc	r8,80003370 <xTaskRemoveFromEventList+0x64>
80003320:	70 08       	ld.w	r8,r8[0x0]
80003322:	58 08       	cp.w	r8,0
80003324:	c1 71       	brne	80003352 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80003326:	ee c6 ff fc 	sub	r6,r7,-4
8000332a:	0c 9c       	mov	r12,r6
8000332c:	f0 1f 00 10 	mcall	8000336c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80003330:	6e bc       	ld.w	r12,r7[0x2c]
80003332:	49 18       	lddpc	r8,80003374 <xTaskRemoveFromEventList+0x68>
80003334:	70 08       	ld.w	r8,r8[0x0]
80003336:	10 3c       	cp.w	r12,r8
80003338:	e0 88 00 04 	brls	80003340 <xTaskRemoveFromEventList+0x34>
8000333c:	48 e8       	lddpc	r8,80003374 <xTaskRemoveFromEventList+0x68>
8000333e:	91 0c       	st.w	r8[0x0],r12
80003340:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003344:	0c 9b       	mov	r11,r6
80003346:	48 d8       	lddpc	r8,80003378 <xTaskRemoveFromEventList+0x6c>
80003348:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000334c:	f0 1f 00 0c 	mcall	8000337c <xTaskRemoveFromEventList+0x70>
80003350:	c0 58       	rjmp	8000335a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80003352:	0c 9b       	mov	r11,r6
80003354:	48 bc       	lddpc	r12,80003380 <xTaskRemoveFromEventList+0x74>
80003356:	f0 1f 00 0a 	mcall	8000337c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000335a:	48 b8       	lddpc	r8,80003384 <xTaskRemoveFromEventList+0x78>
8000335c:	70 08       	ld.w	r8,r8[0x0]
8000335e:	6e b9       	ld.w	r9,r7[0x2c]
80003360:	70 b8       	ld.w	r8,r8[0x2c]
80003362:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80003364:	5f 2c       	srhs	r12
80003366:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000336a:	00 00       	add	r0,r0
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	2c 98       	sub	r8,-55
80003370:	00 00       	add	r0,r0
80003372:	07 28       	ld.uh	r8,r3++
80003374:	00 00       	add	r0,r0
80003376:	07 48       	ld.w	r8,--r3
80003378:	00 00       	add	r0,r0
8000337a:	06 6c       	and	r12,r3
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	2c 48       	sub	r8,-60
80003380:	00 00       	add	r0,r0
80003382:	07 10       	ld.sh	r0,r3++
80003384:	00 00       	add	r0,r0
80003386:	07 0c       	ld.w	r12,r3++

80003388 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80003388:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000338c:	4b 98       	lddpc	r8,80003470 <vTaskIncrementTick+0xe8>
8000338e:	70 08       	ld.w	r8,r8[0x0]
80003390:	58 08       	cp.w	r8,0
80003392:	c6 91       	brne	80003464 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80003394:	4b 88       	lddpc	r8,80003474 <vTaskIncrementTick+0xec>
80003396:	70 09       	ld.w	r9,r8[0x0]
80003398:	2f f9       	sub	r9,-1
8000339a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000339c:	70 08       	ld.w	r8,r8[0x0]
8000339e:	58 08       	cp.w	r8,0
800033a0:	c1 a1       	brne	800033d4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800033a2:	4b 68       	lddpc	r8,80003478 <vTaskIncrementTick+0xf0>
800033a4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800033a6:	4b 69       	lddpc	r9,8000347c <vTaskIncrementTick+0xf4>
800033a8:	72 0b       	ld.w	r11,r9[0x0]
800033aa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800033ac:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800033ae:	4b 59       	lddpc	r9,80003480 <vTaskIncrementTick+0xf8>
800033b0:	72 0a       	ld.w	r10,r9[0x0]
800033b2:	2f fa       	sub	r10,-1
800033b4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800033b6:	70 08       	ld.w	r8,r8[0x0]
800033b8:	70 08       	ld.w	r8,r8[0x0]
800033ba:	58 08       	cp.w	r8,0
800033bc:	c0 51       	brne	800033c6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800033be:	3f f9       	mov	r9,-1
800033c0:	4b 18       	lddpc	r8,80003484 <vTaskIncrementTick+0xfc>
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	c0 88       	rjmp	800033d4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800033c6:	4a d8       	lddpc	r8,80003478 <vTaskIncrementTick+0xf0>
800033c8:	70 08       	ld.w	r8,r8[0x0]
800033ca:	70 38       	ld.w	r8,r8[0xc]
800033cc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800033ce:	70 19       	ld.w	r9,r8[0x4]
800033d0:	4a d8       	lddpc	r8,80003484 <vTaskIncrementTick+0xfc>
800033d2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800033d4:	4a 88       	lddpc	r8,80003474 <vTaskIncrementTick+0xec>
800033d6:	70 09       	ld.w	r9,r8[0x0]
800033d8:	4a b8       	lddpc	r8,80003484 <vTaskIncrementTick+0xfc>
800033da:	70 08       	ld.w	r8,r8[0x0]
800033dc:	10 39       	cp.w	r9,r8
800033de:	c4 73       	brcs	8000346c <vTaskIncrementTick+0xe4>
800033e0:	4a 68       	lddpc	r8,80003478 <vTaskIncrementTick+0xf0>
800033e2:	70 08       	ld.w	r8,r8[0x0]
800033e4:	70 08       	ld.w	r8,r8[0x0]
800033e6:	58 08       	cp.w	r8,0
800033e8:	c0 c0       	breq	80003400 <vTaskIncrementTick+0x78>
800033ea:	4a 48       	lddpc	r8,80003478 <vTaskIncrementTick+0xf0>
800033ec:	70 08       	ld.w	r8,r8[0x0]
800033ee:	70 38       	ld.w	r8,r8[0xc]
800033f0:	70 37       	ld.w	r7,r8[0xc]
800033f2:	6e 18       	ld.w	r8,r7[0x4]
800033f4:	4a 09       	lddpc	r9,80003474 <vTaskIncrementTick+0xec>
800033f6:	72 09       	ld.w	r9,r9[0x0]
800033f8:	12 38       	cp.w	r8,r9
800033fa:	e0 88 00 14 	brls	80003422 <vTaskIncrementTick+0x9a>
800033fe:	c0 e8       	rjmp	8000341a <vTaskIncrementTick+0x92>
80003400:	3f f9       	mov	r9,-1
80003402:	4a 18       	lddpc	r8,80003484 <vTaskIncrementTick+0xfc>
80003404:	91 09       	st.w	r8[0x0],r9
80003406:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000340a:	6a 08       	ld.w	r8,r5[0x0]
8000340c:	70 38       	ld.w	r8,r8[0xc]
8000340e:	70 37       	ld.w	r7,r8[0xc]
80003410:	6e 18       	ld.w	r8,r7[0x4]
80003412:	64 09       	ld.w	r9,r2[0x0]
80003414:	12 38       	cp.w	r8,r9
80003416:	e0 88 00 0a 	brls	8000342a <vTaskIncrementTick+0xa2>
8000341a:	49 b9       	lddpc	r9,80003484 <vTaskIncrementTick+0xfc>
8000341c:	93 08       	st.w	r9[0x0],r8
8000341e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003422:	49 a4       	lddpc	r4,80003488 <vTaskIncrementTick+0x100>
80003424:	49 a3       	lddpc	r3,8000348c <vTaskIncrementTick+0x104>
80003426:	49 55       	lddpc	r5,80003478 <vTaskIncrementTick+0xf0>
80003428:	49 32       	lddpc	r2,80003474 <vTaskIncrementTick+0xec>
8000342a:	ee c6 ff fc 	sub	r6,r7,-4
8000342e:	0c 9c       	mov	r12,r6
80003430:	f0 1f 00 18 	mcall	80003490 <vTaskIncrementTick+0x108>
80003434:	6e a8       	ld.w	r8,r7[0x28]
80003436:	58 08       	cp.w	r8,0
80003438:	c0 50       	breq	80003442 <vTaskIncrementTick+0xba>
8000343a:	ee cc ff e8 	sub	r12,r7,-24
8000343e:	f0 1f 00 15 	mcall	80003490 <vTaskIncrementTick+0x108>
80003442:	6e bc       	ld.w	r12,r7[0x2c]
80003444:	68 08       	ld.w	r8,r4[0x0]
80003446:	10 3c       	cp.w	r12,r8
80003448:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000344c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80003450:	0c 9b       	mov	r11,r6
80003452:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80003456:	f0 1f 00 10 	mcall	80003494 <vTaskIncrementTick+0x10c>
8000345a:	6a 08       	ld.w	r8,r5[0x0]
8000345c:	70 08       	ld.w	r8,r8[0x0]
8000345e:	58 08       	cp.w	r8,0
80003460:	cd 51       	brne	8000340a <vTaskIncrementTick+0x82>
80003462:	cc fb       	rjmp	80003400 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80003464:	48 d8       	lddpc	r8,80003498 <vTaskIncrementTick+0x110>
80003466:	70 09       	ld.w	r9,r8[0x0]
80003468:	2f f9       	sub	r9,-1
8000346a:	91 09       	st.w	r8[0x0],r9
8000346c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003470:	00 00       	add	r0,r0
80003472:	07 28       	ld.uh	r8,r3++
80003474:	00 00       	add	r0,r0
80003476:	07 24       	ld.uh	r4,r3++
80003478:	00 00       	add	r0,r0
8000347a:	06 60       	and	r0,r3
8000347c:	00 00       	add	r0,r0
8000347e:	06 68       	and	r8,r3
80003480:	00 00       	add	r0,r0
80003482:	06 64       	and	r4,r3
80003484:	00 00       	add	r0,r0
80003486:	00 24       	rsub	r4,r0
80003488:	00 00       	add	r0,r0
8000348a:	07 48       	ld.w	r8,--r3
8000348c:	00 00       	add	r0,r0
8000348e:	06 6c       	and	r12,r3
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	2c 98       	sub	r8,-55
80003494:	80 00       	ld.sh	r0,r0[0x0]
80003496:	2c 48       	sub	r8,-60
80003498:	00 00       	add	r0,r0
8000349a:	06 5c       	eor	r12,r3

8000349c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000349c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800034a0:	f0 1f 00 2c 	mcall	80003550 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800034a4:	4a c8       	lddpc	r8,80003554 <xTaskResumeAll+0xb8>
800034a6:	70 09       	ld.w	r9,r8[0x0]
800034a8:	20 19       	sub	r9,1
800034aa:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800034ac:	70 08       	ld.w	r8,r8[0x0]
800034ae:	58 08       	cp.w	r8,0
800034b0:	c4 91       	brne	80003542 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800034b2:	4a a8       	lddpc	r8,80003558 <xTaskResumeAll+0xbc>
800034b4:	70 08       	ld.w	r8,r8[0x0]
800034b6:	58 08       	cp.w	r8,0
800034b8:	c4 50       	breq	80003542 <xTaskResumeAll+0xa6>
800034ba:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800034bc:	4a 85       	lddpc	r5,8000355c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800034be:	4a 93       	lddpc	r3,80003560 <xTaskResumeAll+0xc4>
800034c0:	4a 92       	lddpc	r2,80003564 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800034c2:	4a a1       	lddpc	r1,80003568 <xTaskResumeAll+0xcc>
800034c4:	c1 e8       	rjmp	80003500 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800034c6:	6a 38       	ld.w	r8,r5[0xc]
800034c8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800034ca:	ee cc ff e8 	sub	r12,r7,-24
800034ce:	f0 1f 00 28 	mcall	8000356c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800034d2:	ee c6 ff fc 	sub	r6,r7,-4
800034d6:	0c 9c       	mov	r12,r6
800034d8:	f0 1f 00 25 	mcall	8000356c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800034dc:	6e bc       	ld.w	r12,r7[0x2c]
800034de:	66 08       	ld.w	r8,r3[0x0]
800034e0:	10 3c       	cp.w	r12,r8
800034e2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800034e6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800034ea:	0c 9b       	mov	r11,r6
800034ec:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800034f0:	f0 1f 00 20 	mcall	80003570 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800034f4:	62 08       	ld.w	r8,r1[0x0]
800034f6:	6e b9       	ld.w	r9,r7[0x2c]
800034f8:	70 b8       	ld.w	r8,r8[0x2c]
800034fa:	10 39       	cp.w	r9,r8
800034fc:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003500:	6a 08       	ld.w	r8,r5[0x0]
80003502:	58 08       	cp.w	r8,0
80003504:	ce 11       	brne	800034c6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003506:	49 c8       	lddpc	r8,80003574 <xTaskResumeAll+0xd8>
80003508:	70 08       	ld.w	r8,r8[0x0]
8000350a:	58 08       	cp.w	r8,0
8000350c:	c0 f0       	breq	8000352a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000350e:	49 a8       	lddpc	r8,80003574 <xTaskResumeAll+0xd8>
80003510:	70 08       	ld.w	r8,r8[0x0]
80003512:	58 08       	cp.w	r8,0
80003514:	c1 10       	breq	80003536 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80003516:	49 87       	lddpc	r7,80003574 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80003518:	f0 1f 00 18 	mcall	80003578 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000351c:	6e 08       	ld.w	r8,r7[0x0]
8000351e:	20 18       	sub	r8,1
80003520:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80003522:	6e 08       	ld.w	r8,r7[0x0]
80003524:	58 08       	cp.w	r8,0
80003526:	cf 91       	brne	80003518 <xTaskResumeAll+0x7c>
80003528:	c0 78       	rjmp	80003536 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000352a:	58 14       	cp.w	r4,1
8000352c:	c0 50       	breq	80003536 <xTaskResumeAll+0x9a>
8000352e:	49 48       	lddpc	r8,8000357c <xTaskResumeAll+0xe0>
80003530:	70 08       	ld.w	r8,r8[0x0]
80003532:	58 18       	cp.w	r8,1
80003534:	c0 71       	brne	80003542 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80003536:	30 09       	mov	r9,0
80003538:	49 18       	lddpc	r8,8000357c <xTaskResumeAll+0xe0>
8000353a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000353c:	d7 33       	scall
8000353e:	30 17       	mov	r7,1
80003540:	c0 28       	rjmp	80003544 <xTaskResumeAll+0xa8>
80003542:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80003544:	f0 1f 00 0f 	mcall	80003580 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80003548:	0e 9c       	mov	r12,r7
8000354a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000354e:	00 00       	add	r0,r0
80003550:	80 00       	ld.sh	r0,r0[0x0]
80003552:	2c c0       	sub	r0,-52
80003554:	00 00       	add	r0,r0
80003556:	07 28       	ld.uh	r8,r3++
80003558:	00 00       	add	r0,r0
8000355a:	07 2c       	ld.uh	r12,r3++
8000355c:	00 00       	add	r0,r0
8000355e:	07 10       	ld.sh	r0,r3++
80003560:	00 00       	add	r0,r0
80003562:	07 48       	ld.w	r8,--r3
80003564:	00 00       	add	r0,r0
80003566:	06 6c       	and	r12,r3
80003568:	00 00       	add	r0,r0
8000356a:	07 0c       	ld.w	r12,r3++
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	2c 98       	sub	r8,-55
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	2c 48       	sub	r8,-60
80003574:	00 00       	add	r0,r0
80003576:	06 5c       	eor	r12,r3
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	33 88       	mov	r8,56
8000357c:	00 00       	add	r0,r0
8000357e:	07 30       	ld.ub	r0,r3++
80003580:	80 00       	ld.sh	r0,r0[0x0]
80003582:	2d 68       	sub	r8,-42

80003584 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80003584:	eb cd 40 80 	pushm	r7,lr
80003588:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000358a:	49 08       	lddpc	r8,800035c8 <prvAddCurrentTaskToDelayedList+0x44>
8000358c:	70 08       	ld.w	r8,r8[0x0]
8000358e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80003590:	48 f8       	lddpc	r8,800035cc <prvAddCurrentTaskToDelayedList+0x48>
80003592:	70 08       	ld.w	r8,r8[0x0]
80003594:	10 3c       	cp.w	r12,r8
80003596:	c0 a2       	brcc	800035aa <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003598:	48 c8       	lddpc	r8,800035c8 <prvAddCurrentTaskToDelayedList+0x44>
8000359a:	70 0b       	ld.w	r11,r8[0x0]
8000359c:	48 d8       	lddpc	r8,800035d0 <prvAddCurrentTaskToDelayedList+0x4c>
8000359e:	70 0c       	ld.w	r12,r8[0x0]
800035a0:	2f cb       	sub	r11,-4
800035a2:	f0 1f 00 0d 	mcall	800035d4 <prvAddCurrentTaskToDelayedList+0x50>
800035a6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800035aa:	48 88       	lddpc	r8,800035c8 <prvAddCurrentTaskToDelayedList+0x44>
800035ac:	70 0b       	ld.w	r11,r8[0x0]
800035ae:	48 b8       	lddpc	r8,800035d8 <prvAddCurrentTaskToDelayedList+0x54>
800035b0:	70 0c       	ld.w	r12,r8[0x0]
800035b2:	2f cb       	sub	r11,-4
800035b4:	f0 1f 00 08 	mcall	800035d4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800035b8:	48 98       	lddpc	r8,800035dc <prvAddCurrentTaskToDelayedList+0x58>
800035ba:	70 08       	ld.w	r8,r8[0x0]
800035bc:	10 37       	cp.w	r7,r8
800035be:	c0 32       	brcc	800035c4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800035c0:	48 78       	lddpc	r8,800035dc <prvAddCurrentTaskToDelayedList+0x58>
800035c2:	91 07       	st.w	r8[0x0],r7
800035c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800035c8:	00 00       	add	r0,r0
800035ca:	07 0c       	ld.w	r12,r3++
800035cc:	00 00       	add	r0,r0
800035ce:	07 24       	ld.uh	r4,r3++
800035d0:	00 00       	add	r0,r0
800035d2:	06 68       	and	r8,r3
800035d4:	80 00       	ld.sh	r0,r0[0x0]
800035d6:	2c 64       	sub	r4,-58
800035d8:	00 00       	add	r0,r0
800035da:	06 60       	and	r0,r3
800035dc:	00 00       	add	r0,r0
800035de:	00 24       	rsub	r4,r0

800035e0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800035e0:	eb cd 40 c0 	pushm	r6-r7,lr
800035e4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800035e6:	48 e7       	lddpc	r7,8000361c <vTaskPlaceOnEventList+0x3c>
800035e8:	6e 0b       	ld.w	r11,r7[0x0]
800035ea:	2e 8b       	sub	r11,-24
800035ec:	f0 1f 00 0d 	mcall	80003620 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800035f0:	6e 0c       	ld.w	r12,r7[0x0]
800035f2:	2f cc       	sub	r12,-4
800035f4:	f0 1f 00 0c 	mcall	80003624 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800035f8:	5b f6       	cp.w	r6,-1
800035fa:	c0 81       	brne	8000360a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800035fc:	6e 0b       	ld.w	r11,r7[0x0]
800035fe:	2f cb       	sub	r11,-4
80003600:	48 ac       	lddpc	r12,80003628 <vTaskPlaceOnEventList+0x48>
80003602:	f0 1f 00 0b 	mcall	8000362c <vTaskPlaceOnEventList+0x4c>
80003606:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000360a:	48 a8       	lddpc	r8,80003630 <vTaskPlaceOnEventList+0x50>
8000360c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000360e:	ec 0c 00 0c 	add	r12,r6,r12
80003612:	f0 1f 00 09 	mcall	80003634 <vTaskPlaceOnEventList+0x54>
80003616:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000361a:	00 00       	add	r0,r0
8000361c:	00 00       	add	r0,r0
8000361e:	07 0c       	ld.w	r12,r3++
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	2c 64       	sub	r4,-58
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	2c 98       	sub	r8,-55
80003628:	00 00       	add	r0,r0
8000362a:	07 34       	ld.ub	r4,r3++
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	2c 48       	sub	r8,-60
80003630:	00 00       	add	r0,r0
80003632:	07 24       	ld.uh	r4,r3++
80003634:	80 00       	ld.sh	r0,r0[0x0]
80003636:	35 84       	mov	r4,88

80003638 <dip204_example_configure_joystick_IT>:
	Enable_global_interrupt();
}


void dip204_example_configure_joystick_IT(void)
{
80003638:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_UP , GPIO_FALLING_EDGE);
8000363c:	30 2b       	mov	r11,2
8000363e:	31 ac       	mov	r12,26
80003640:	f0 1f 00 18 	mcall	800036a0 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_DOWN , GPIO_FALLING_EDGE);
80003644:	30 2b       	mov	r11,2
80003646:	31 bc       	mov	r12,27
80003648:	f0 1f 00 16 	mcall	800036a0 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_RIGHT , GPIO_FALLING_EDGE);
8000364c:	30 2b       	mov	r11,2
8000364e:	31 cc       	mov	r12,28
80003650:	f0 1f 00 14 	mcall	800036a0 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_PUSH , GPIO_FALLING_EDGE);
80003654:	30 2b       	mov	r11,2
80003656:	31 4c       	mov	r12,20
80003658:	f0 1f 00 12 	mcall	800036a0 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_LEFT , GPIO_FALLING_EDGE);
8000365c:	30 2b       	mov	r11,2
8000365e:	31 9c       	mov	r12,25
80003660:	f0 1f 00 10 	mcall	800036a0 <dip204_example_configure_joystick_IT+0x68>

	/* Disable all interrupts */
	Disable_global_interrupt();
80003664:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_UP/8), AVR32_INTC_INT1);
80003666:	49 07       	lddpc	r7,800036a4 <dip204_example_configure_joystick_IT+0x6c>
80003668:	30 1a       	mov	r10,1
8000366a:	34 3b       	mov	r11,67
8000366c:	0e 9c       	mov	r12,r7
8000366e:	f0 1f 00 0f 	mcall	800036a8 <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_DOWN/8), AVR32_INTC_INT1);
80003672:	30 1a       	mov	r10,1
80003674:	34 3b       	mov	r11,67
80003676:	0e 9c       	mov	r12,r7
80003678:	f0 1f 00 0c 	mcall	800036a8 <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_RIGHT/8), AVR32_INTC_INT1);
8000367c:	30 1a       	mov	r10,1
8000367e:	34 3b       	mov	r11,67
80003680:	0e 9c       	mov	r12,r7
80003682:	f0 1f 00 0a 	mcall	800036a8 <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_LEFT/8), AVR32_INTC_INT1);
80003686:	30 1a       	mov	r10,1
80003688:	34 3b       	mov	r11,67
8000368a:	0e 9c       	mov	r12,r7
8000368c:	f0 1f 00 07 	mcall	800036a8 <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_PUSH/8), AVR32_INTC_INT1);
80003690:	30 1a       	mov	r10,1
80003692:	34 2b       	mov	r11,66
80003694:	0e 9c       	mov	r12,r7
80003696:	f0 1f 00 05 	mcall	800036a8 <dip204_example_configure_joystick_IT+0x70>
	/* Enable all interrupts */
	Enable_global_interrupt();
8000369a:	d5 03       	csrf	0x10
}
8000369c:	e3 cd 80 80 	ldm	sp++,r7,pc
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	26 cc       	sub	r12,108
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	39 00       	mov	r0,-112
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	27 44       	sub	r4,116

800036ac <dip204_example_configure_push_buttons_IT>:
	}
}


void dip204_example_configure_push_buttons_IT(void)
{
800036ac:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_CHARSET , GPIO_RISING_EDGE);
800036b0:	30 1b       	mov	r11,1
800036b2:	35 8c       	mov	r12,88
800036b4:	f0 1f 00 0f 	mcall	800036f0 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_PLUS , GPIO_RISING_EDGE);
800036b8:	30 1b       	mov	r11,1
800036ba:	35 2c       	mov	r12,82
800036bc:	f0 1f 00 0d 	mcall	800036f0 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_MINUS , GPIO_RISING_EDGE);
800036c0:	30 1b       	mov	r11,1
800036c2:	35 5c       	mov	r12,85
800036c4:	f0 1f 00 0b 	mcall	800036f0 <dip204_example_configure_push_buttons_IT+0x44>

	/* Disable all interrupts */
	Disable_global_interrupt();
800036c8:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_PLUS/8), AVR32_INTC_INT1);
800036ca:	48 b7       	lddpc	r7,800036f4 <dip204_example_configure_push_buttons_IT+0x48>
800036cc:	30 1a       	mov	r10,1
800036ce:	34 ab       	mov	r11,74
800036d0:	0e 9c       	mov	r12,r7
800036d2:	f0 1f 00 0a 	mcall	800036f8 <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_MINUS/8), AVR32_INTC_INT1);
800036d6:	30 1a       	mov	r10,1
800036d8:	34 ab       	mov	r11,74
800036da:	0e 9c       	mov	r12,r7
800036dc:	f0 1f 00 07 	mcall	800036f8 <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_CHARSET/8), AVR32_INTC_INT1);
800036e0:	30 1a       	mov	r10,1
800036e2:	34 bb       	mov	r11,75
800036e4:	0e 9c       	mov	r12,r7
800036e6:	f0 1f 00 05 	mcall	800036f8 <dip204_example_configure_push_buttons_IT+0x4c>
	/* Enable all interrupts */
	Enable_global_interrupt();
800036ea:	d5 03       	csrf	0x10
}
800036ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	26 cc       	sub	r12,108
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	39 e4       	mov	r4,-98
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	27 44       	sub	r4,116

800036fc <main>:
	/* Enable all interrupts */
	Enable_global_interrupt();
}

int main(void)
{
800036fc:	d4 31       	pushm	r0-r7,lr
800036fe:	20 4d       	sub	sp,16
		{DIP204_SPI_MOSI_PIN, DIP204_SPI_MOSI_FUNCTION},  // MOSI.
		{DIP204_SPI_NPCS_PIN, DIP204_SPI_NPCS_FUNCTION}   // Chip Select NPCS.
	};

	// Switch the CPU main clock to oscillator 0
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80003700:	30 3a       	mov	r10,3
80003702:	e0 6b 1b 00 	mov	r11,6912
80003706:	ea 1b 00 b7 	orh	r11,0xb7
8000370a:	fe 7c 0c 00 	mov	r12,-62464
8000370e:	f0 1f 00 68 	mcall	800038ac <main+0x1b0>

	// Disable all interrupts.
	Disable_global_interrupt();
80003712:	d3 03       	ssrf	0x10

	// init the interrupts
	INTC_init_interrupts();
80003714:	f0 1f 00 67 	mcall	800038b0 <main+0x1b4>

	// Enable all interrupts.
	Enable_global_interrupt();
80003718:	d5 03       	csrf	0x10
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000371a:	4e 78       	lddpc	r8,800038b4 <main+0x1b8>
8000371c:	f0 ea 00 00 	ld.d	r10,r8[0]
80003720:	fa eb 00 00 	st.d	sp[0],r10
80003724:	f0 e8 00 08 	ld.d	r8,r8[8]
80003728:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
8000372c:	30 4b       	mov	r11,4
8000372e:	4e 3c       	lddpc	r12,800038b8 <main+0x1bc>
80003730:	f0 1f 00 63 	mcall	800038bc <main+0x1c0>
	sizeof(DIP204_SPI_GPIO_MAP) / sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as master
	spi_initMaster(DIP204_SPI, &spiOptions);
80003734:	1a 9b       	mov	r11,sp
80003736:	fe 7c 28 00 	mov	r12,-55296
8000373a:	f0 1f 00 62 	mcall	800038c0 <main+0x1c4>

	// Set selection mode: variable_ps, pcs_decode, delay
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
8000373e:	30 09       	mov	r9,0
80003740:	12 9a       	mov	r10,r9
80003742:	12 9b       	mov	r11,r9
80003744:	fe 7c 28 00 	mov	r12,-55296
80003748:	f0 1f 00 5f 	mcall	800038c4 <main+0x1c8>

	// Enable SPI
	spi_enable(DIP204_SPI);
8000374c:	fe 7c 28 00 	mov	r12,-55296
80003750:	f0 1f 00 5e 	mcall	800038c8 <main+0x1cc>

	// setup chip registers
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
80003754:	e0 6a 1b 00 	mov	r10,6912
80003758:	ea 1a 00 b7 	orh	r10,0xb7
8000375c:	1a 9b       	mov	r11,sp
8000375e:	fe 7c 28 00 	mov	r12,-55296
80003762:	f0 1f 00 5b 	mcall	800038cc <main+0x1d0>

	// configure local push buttons
	dip204_example_configure_push_buttons_IT();
80003766:	f0 1f 00 5b 	mcall	800038d0 <main+0x1d4>

	// configure local joystick
	dip204_example_configure_joystick_IT();
8000376a:	f0 1f 00 5b 	mcall	800038d4 <main+0x1d8>

	// initialize delay driver
	delay_init( FOSC0 );

	// initialize LCD
	dip204_init(backlight_PWM, true);
8000376e:	30 1b       	mov	r11,1
80003770:	16 9c       	mov	r12,r11
80003772:	f0 1f 00 5a 	mcall	800038d8 <main+0x1dc>

	// reset marker
	current_char = 0x10;
80003776:	31 09       	mov	r9,16
80003778:	4d 98       	lddpc	r8,800038dc <main+0x1e0>
8000377a:	b0 09       	st.h	r8[0x0],r9
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000377c:	e0 67 1b 00 	mov	r7,6912
80003780:	ea 17 00 b7 	orh	r7,0xb7
	/* do a loop */
	while (1)
	{
		dip204_clear_display();
		delay_ms(200);
		dip204_set_cursor_position(8,1);
80003784:	30 15       	mov	r5,1
80003786:	30 84       	mov	r4,8
		dip204_write_string("ATMEL");
80003788:	4d 63       	lddpc	r3,800038e0 <main+0x1e4>
		delay_ms(200);
		dip204_set_cursor_position(7,2);
8000378a:	30 22       	mov	r2,2
8000378c:	30 71       	mov	r1,7
		dip204_write_string("EVK1100");
8000378e:	4d 60       	lddpc	r0,800038e4 <main+0x1e8>
		delay_ms(200);
		dip204_set_cursor_position(6,3);
80003790:	30 36       	mov	r6,3


	/* do a loop */
	while (1)
	{
		dip204_clear_display();
80003792:	f0 1f 00 56 	mcall	800038e8 <main+0x1ec>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003796:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000379a:	f0 07 00 0a 	add	r10,r8,r7
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000379e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037a2:	14 38       	cp.w	r8,r10
800037a4:	e0 88 00 08 	brls	800037b4 <main+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037a8:	12 38       	cp.w	r8,r9
800037aa:	fe 98 ff fa 	brls	8000379e <main+0xa2>
800037ae:	12 3a       	cp.w	r10,r9
800037b0:	c4 c3       	brcs	80003848 <main+0x14c>
800037b2:	cf 6b       	rjmp	8000379e <main+0xa2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037b4:	12 38       	cp.w	r8,r9
800037b6:	e0 8b 00 49 	brhi	80003848 <main+0x14c>
800037ba:	12 3a       	cp.w	r10,r9
800037bc:	c4 63       	brcs	80003848 <main+0x14c>
800037be:	cf 0b       	rjmp	8000379e <main+0xa2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037c0:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037c4:	14 38       	cp.w	r8,r10
800037c6:	e0 88 00 08 	brls	800037d6 <main+0xda>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037ca:	12 38       	cp.w	r8,r9
800037cc:	fe 98 ff fa 	brls	800037c0 <main+0xc4>
800037d0:	12 3a       	cp.w	r10,r9
800037d2:	c4 73       	brcs	80003860 <main+0x164>
800037d4:	cf 6b       	rjmp	800037c0 <main+0xc4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037d6:	12 38       	cp.w	r8,r9
800037d8:	e0 8b 00 44 	brhi	80003860 <main+0x164>
800037dc:	12 3a       	cp.w	r10,r9
800037de:	c4 13       	brcs	80003860 <main+0x164>
800037e0:	cf 0b       	rjmp	800037c0 <main+0xc4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800037e2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800037e6:	14 38       	cp.w	r8,r10
800037e8:	e0 88 00 08 	brls	800037f8 <main+0xfc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800037ec:	12 38       	cp.w	r8,r9
800037ee:	fe 98 ff fa 	brls	800037e2 <main+0xe6>
800037f2:	12 3a       	cp.w	r10,r9
800037f4:	c4 23       	brcs	80003878 <main+0x17c>
800037f6:	cf 6b       	rjmp	800037e2 <main+0xe6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800037f8:	12 38       	cp.w	r8,r9
800037fa:	e0 8b 00 3f 	brhi	80003878 <main+0x17c>
800037fe:	12 3a       	cp.w	r10,r9
80003800:	c3 c3       	brcs	80003878 <main+0x17c>
80003802:	cf 0b       	rjmp	800037e2 <main+0xe6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003804:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003808:	14 38       	cp.w	r8,r10
8000380a:	e0 88 00 08 	brls	8000381a <main+0x11e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000380e:	12 38       	cp.w	r8,r9
80003810:	fe 98 ff fa 	brls	80003804 <main+0x108>
80003814:	12 3a       	cp.w	r10,r9
80003816:	c3 d3       	brcs	80003890 <main+0x194>
80003818:	cf 6b       	rjmp	80003804 <main+0x108>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000381a:	12 38       	cp.w	r8,r9
8000381c:	e0 8b 00 3a 	brhi	80003890 <main+0x194>
80003820:	12 3a       	cp.w	r10,r9
80003822:	c3 73       	brcs	80003890 <main+0x194>
80003824:	cf 0b       	rjmp	80003804 <main+0x108>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003826:	e1 ba 00 42 	mfsr	r10,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000382a:	12 38       	cp.w	r8,r9
8000382c:	e0 88 00 08 	brls	8000383c <main+0x140>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80003830:	14 38       	cp.w	r8,r10
80003832:	fe 98 ff fa 	brls	80003826 <main+0x12a>
80003836:	14 39       	cp.w	r9,r10
80003838:	ca d3       	brcs	80003792 <main+0x96>
8000383a:	cf 6b       	rjmp	80003826 <main+0x12a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000383c:	14 38       	cp.w	r8,r10
8000383e:	fe 9b ff aa 	brhi	80003792 <main+0x96>
80003842:	14 39       	cp.w	r9,r10
80003844:	ca 73       	brcs	80003792 <main+0x96>
80003846:	cf 0b       	rjmp	80003826 <main+0x12a>
		delay_ms(200);
		dip204_set_cursor_position(8,1);
80003848:	0a 9b       	mov	r11,r5
8000384a:	08 9c       	mov	r12,r4
8000384c:	f0 1f 00 28 	mcall	800038ec <main+0x1f0>
		dip204_write_string("ATMEL");
80003850:	06 9c       	mov	r12,r3
80003852:	f0 1f 00 28 	mcall	800038f0 <main+0x1f4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003856:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000385a:	f0 07 00 0a 	add	r10,r8,r7
8000385e:	cb 1b       	rjmp	800037c0 <main+0xc4>
		delay_ms(200);
		dip204_set_cursor_position(7,2);
80003860:	04 9b       	mov	r11,r2
80003862:	02 9c       	mov	r12,r1
80003864:	f0 1f 00 22 	mcall	800038ec <main+0x1f0>
		dip204_write_string("EVK1100");
80003868:	00 9c       	mov	r12,r0
8000386a:	f0 1f 00 22 	mcall	800038f0 <main+0x1f4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000386e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003872:	f0 07 00 0a 	add	r10,r8,r7
80003876:	cb 6b       	rjmp	800037e2 <main+0xe6>
		delay_ms(200);
		dip204_set_cursor_position(6,3);
80003878:	0c 9b       	mov	r11,r6
8000387a:	30 6c       	mov	r12,6
8000387c:	f0 1f 00 1c 	mcall	800038ec <main+0x1f0>
		dip204_write_string("AVR32 UC3");
80003880:	49 dc       	lddpc	r12,800038f4 <main+0x1f8>
80003882:	f0 1f 00 1c 	mcall	800038f0 <main+0x1f4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003886:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000388a:	f0 07 00 0a 	add	r10,r8,r7
8000388e:	cb bb       	rjmp	80003804 <main+0x108>
		delay_ms(200);
		dip204_set_cursor_position(3,4);
80003890:	30 4b       	mov	r11,4
80003892:	0c 9c       	mov	r12,r6
80003894:	f0 1f 00 16 	mcall	800038ec <main+0x1f0>
		dip204_write_string("AT32UC3A Series");
80003898:	49 8c       	lddpc	r12,800038f8 <main+0x1fc>
8000389a:	f0 1f 00 16 	mcall	800038f0 <main+0x1f4>
		dip204_hide_cursor();
8000389e:	f0 1f 00 18 	mcall	800038fc <main+0x200>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800038a2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800038a6:	f0 07 00 09 	add	r9,r8,r7
800038aa:	cb eb       	rjmp	80003826 <main+0x12a>
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	28 dc       	sub	r12,-115
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	27 c4       	sub	r4,124
800038b4:	80 00       	ld.sh	r0,r0[0x0]
800038b6:	48 b8       	lddpc	r8,800038e0 <main+0x1e4>
800038b8:	80 00       	ld.sh	r0,r0[0x0]
800038ba:	48 c8       	lddpc	r8,800038e8 <main+0x1ec>
800038bc:	80 00       	ld.sh	r0,r0[0x0]
800038be:	26 64       	sub	r4,102
800038c0:	80 00       	ld.sh	r0,r0[0x0]
800038c2:	29 ee       	sub	lr,-98
800038c4:	80 00       	ld.sh	r0,r0[0x0]
800038c6:	2a 26       	sub	r6,-94
800038c8:	80 00       	ld.sh	r0,r0[0x0]
800038ca:	2a 52       	sub	r2,-91
800038cc:	80 00       	ld.sh	r0,r0[0x0]
800038ce:	2a 94       	sub	r4,-87
800038d0:	80 00       	ld.sh	r0,r0[0x0]
800038d2:	36 ac       	mov	r12,106
800038d4:	80 00       	ld.sh	r0,r0[0x0]
800038d6:	36 38       	mov	r8,99
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	23 cc       	sub	r12,60
800038dc:	00 00       	add	r0,r0
800038de:	07 4c       	ld.w	r12,--r3
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	48 e8       	lddpc	r8,80003918 <dip204_example_Joy_int_handler+0x18>
800038e4:	80 00       	ld.sh	r0,r0[0x0]
800038e6:	48 f0       	lddpc	r0,80003920 <dip204_example_Joy_int_handler+0x20>
800038e8:	80 00       	ld.sh	r0,r0[0x0]
800038ea:	22 e4       	sub	r4,46
800038ec:	80 00       	ld.sh	r0,r0[0x0]
800038ee:	22 24       	sub	r4,34
800038f0:	80 00       	ld.sh	r0,r0[0x0]
800038f2:	21 cc       	sub	r12,28
800038f4:	80 00       	ld.sh	r0,r0[0x0]
800038f6:	48 f8       	lddpc	r8,80003930 <dip204_example_Joy_int_handler+0x30>
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	49 04       	lddpc	r4,80003938 <dip204_example_Joy_int_handler+0x38>
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	22 b4       	sub	r4,43

80003900 <dip204_example_Joy_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_Joy_int_handler(void)
{
80003900:	d4 01       	pushm	lr
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_UP))
80003902:	31 ac       	mov	r12,26
80003904:	f0 1f 00 31 	mcall	800039c8 <dip204_example_Joy_int_handler+0xc8>
80003908:	c0 f0       	breq	80003926 <dip204_example_Joy_int_handler+0x26>
	{
		dip204_set_cursor_position(19,1);
8000390a:	30 1b       	mov	r11,1
8000390c:	31 3c       	mov	r12,19
8000390e:	f0 1f 00 30 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDE);
80003912:	e0 6c 00 de 	mov	r12,222
80003916:	f0 1f 00 2f 	mcall	800039d0 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
8000391a:	30 19       	mov	r9,1
8000391c:	4a e8       	lddpc	r8,800039d4 <dip204_example_Joy_int_handler+0xd4>
8000391e:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_UP);
80003920:	31 ac       	mov	r12,26
80003922:	f0 1f 00 2e 	mcall	800039d8 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_DOWN))
80003926:	31 bc       	mov	r12,27
80003928:	f0 1f 00 28 	mcall	800039c8 <dip204_example_Joy_int_handler+0xc8>
8000392c:	c0 f0       	breq	8000394a <dip204_example_Joy_int_handler+0x4a>
	{
		dip204_set_cursor_position(19,3);
8000392e:	30 3b       	mov	r11,3
80003930:	31 3c       	mov	r12,19
80003932:	f0 1f 00 27 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE0);
80003936:	e0 6c 00 e0 	mov	r12,224
8000393a:	f0 1f 00 26 	mcall	800039d0 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
8000393e:	30 19       	mov	r9,1
80003940:	4a 58       	lddpc	r8,800039d4 <dip204_example_Joy_int_handler+0xd4>
80003942:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_DOWN);
80003944:	31 bc       	mov	r12,27
80003946:	f0 1f 00 25 	mcall	800039d8 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_LEFT))
8000394a:	31 9c       	mov	r12,25
8000394c:	f0 1f 00 1f 	mcall	800039c8 <dip204_example_Joy_int_handler+0xc8>
80003950:	c0 f0       	breq	8000396e <dip204_example_Joy_int_handler+0x6e>
	{
		dip204_set_cursor_position(18,2);
80003952:	30 2b       	mov	r11,2
80003954:	31 2c       	mov	r12,18
80003956:	f0 1f 00 1e 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE1);
8000395a:	e0 6c 00 e1 	mov	r12,225
8000395e:	f0 1f 00 1d 	mcall	800039d0 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
80003962:	30 19       	mov	r9,1
80003964:	49 c8       	lddpc	r8,800039d4 <dip204_example_Joy_int_handler+0xd4>
80003966:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_LEFT);
80003968:	31 9c       	mov	r12,25
8000396a:	f0 1f 00 1c 	mcall	800039d8 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT))
8000396e:	31 cc       	mov	r12,28
80003970:	f0 1f 00 16 	mcall	800039c8 <dip204_example_Joy_int_handler+0xc8>
80003974:	c0 f0       	breq	80003992 <dip204_example_Joy_int_handler+0x92>
	{
		dip204_set_cursor_position(20,2);
80003976:	30 2b       	mov	r11,2
80003978:	31 4c       	mov	r12,20
8000397a:	f0 1f 00 15 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDF);
8000397e:	e0 6c 00 df 	mov	r12,223
80003982:	f0 1f 00 14 	mcall	800039d0 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
80003986:	30 19       	mov	r9,1
80003988:	49 38       	lddpc	r8,800039d4 <dip204_example_Joy_int_handler+0xd4>
8000398a:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT);
8000398c:	31 cc       	mov	r12,28
8000398e:	f0 1f 00 13 	mcall	800039d8 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_PUSH))
80003992:	31 4c       	mov	r12,20
80003994:	f0 1f 00 0d 	mcall	800039c8 <dip204_example_Joy_int_handler+0xc8>
80003998:	c1 60       	breq	800039c4 <dip204_example_Joy_int_handler+0xc4>
	{
		dip204_set_cursor_position(19,2);
8000399a:	30 2b       	mov	r11,2
8000399c:	31 3c       	mov	r12,19
8000399e:	f0 1f 00 0c 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xBB);
800039a2:	e0 6c 00 bb 	mov	r12,187
800039a6:	f0 1f 00 0b 	mcall	800039d0 <dip204_example_Joy_int_handler+0xd0>
		dip204_set_cursor_position(1,4);
800039aa:	30 4b       	mov	r11,4
800039ac:	30 1c       	mov	r12,1
800039ae:	f0 1f 00 08 	mcall	800039cc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_string("  AT32UC3A Series   ");
800039b2:	48 bc       	lddpc	r12,800039dc <dip204_example_Joy_int_handler+0xdc>
800039b4:	f0 1f 00 0b 	mcall	800039e0 <dip204_example_Joy_int_handler+0xe0>
		display = 1;
800039b8:	30 19       	mov	r9,1
800039ba:	48 78       	lddpc	r8,800039d4 <dip204_example_Joy_int_handler+0xd4>
800039bc:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_PUSH);
800039be:	31 4c       	mov	r12,20
800039c0:	f0 1f 00 06 	mcall	800039d8 <dip204_example_Joy_int_handler+0xd8>
	}
}
800039c4:	d4 02       	popm	lr
800039c6:	d6 03       	rete
800039c8:	80 00       	ld.sh	r0,r0[0x0]
800039ca:	27 12       	sub	r2,113
800039cc:	80 00       	ld.sh	r0,r0[0x0]
800039ce:	22 24       	sub	r4,34
800039d0:	80 00       	ld.sh	r0,r0[0x0]
800039d2:	22 80       	sub	r0,40
800039d4:	00 00       	add	r0,r0
800039d6:	07 8c       	ld.ub	r12,r3[0x0]
800039d8:	80 00       	ld.sh	r0,r0[0x0]
800039da:	27 2a       	sub	r10,114
800039dc:	80 00       	ld.sh	r0,r0[0x0]
800039de:	49 14       	lddpc	r4,80003a20 <dip204_example_PB_int_handler+0x3c>
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	21 cc       	sub	r12,28

800039e4 <dip204_example_PB_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_PB_int_handler(void)
{
800039e4:	eb cd 40 c0 	pushm	r6-r7,lr
	unsigned short i;

	/* display all available chars */
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
800039e8:	35 8c       	mov	r12,88
800039ea:	f0 1f 00 23 	mcall	80003a74 <dip204_example_PB_int_handler+0x90>
800039ee:	c2 b0       	breq	80003a44 <dip204_example_PB_int_handler+0x60>
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
800039f0:	30 4b       	mov	r11,4
800039f2:	30 1c       	mov	r12,1
800039f4:	f0 1f 00 21 	mcall	80003a78 <dip204_example_PB_int_handler+0x94>
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
800039f8:	4a 18       	lddpc	r8,80003a7c <dip204_example_PB_int_handler+0x98>
800039fa:	90 07       	ld.sh	r7,r8[0x0]
800039fc:	0e 98       	mov	r8,r7
800039fe:	5c 78       	castu.h	r8
80003a00:	f0 c9 ff f0 	sub	r9,r8,-16
80003a04:	12 38       	cp.w	r8,r9
80003a06:	c0 e4       	brge	80003a22 <dip204_example_PB_int_handler+0x3e>
80003a08:	49 d6       	lddpc	r6,80003a7c <dip204_example_PB_int_handler+0x98>
		{
			dip204_write_data(i);
80003a0a:	0e 9c       	mov	r12,r7
80003a0c:	5c 5c       	castu.b	r12
80003a0e:	f0 1f 00 1d 	mcall	80003a80 <dip204_example_PB_int_handler+0x9c>
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
80003a12:	2f f7       	sub	r7,-1
80003a14:	5c 87       	casts.h	r7
80003a16:	0e 99       	mov	r9,r7
80003a18:	5c 79       	castu.h	r9
80003a1a:	8c 88       	ld.uh	r8,r6[0x0]
80003a1c:	2f 08       	sub	r8,-16
80003a1e:	10 39       	cp.w	r9,r8
80003a20:	cf 55       	brlt	80003a0a <dip204_example_PB_int_handler+0x26>
		{
			dip204_write_data(i);
		}
		dip204_write_string("    ");
80003a22:	49 9c       	lddpc	r12,80003a84 <dip204_example_PB_int_handler+0xa0>
80003a24:	f0 1f 00 19 	mcall	80003a88 <dip204_example_PB_int_handler+0xa4>
		/* mark position in charmap */
		current_char = i;
80003a28:	49 58       	lddpc	r8,80003a7c <dip204_example_PB_int_handler+0x98>
80003a2a:	b0 07       	st.h	r8[0x0],r7
		/* reset marker */
		if (current_char >= 0xFF)
80003a2c:	e0 68 00 fe 	mov	r8,254
80003a30:	f0 07 19 00 	cp.h	r7,r8
80003a34:	e0 88 00 05 	brls	80003a3e <dip204_example_PB_int_handler+0x5a>
		{
			current_char = 0x10;
80003a38:	31 09       	mov	r9,16
80003a3a:	49 18       	lddpc	r8,80003a7c <dip204_example_PB_int_handler+0x98>
80003a3c:	b0 09       	st.h	r8[0x0],r9
		}
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_CHARSET);
80003a3e:	35 8c       	mov	r12,88
80003a40:	f0 1f 00 13 	mcall	80003a8c <dip204_example_PB_int_handler+0xa8>
	}
	/* increase backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS))
80003a44:	35 2c       	mov	r12,82
80003a46:	f0 1f 00 0c 	mcall	80003a74 <dip204_example_PB_int_handler+0x90>
80003a4a:	c0 70       	breq	80003a58 <dip204_example_PB_int_handler+0x74>
	{
		dip204_set_backlight(backlight_power_increase);
80003a4c:	30 0c       	mov	r12,0
80003a4e:	f0 1f 00 11 	mcall	80003a90 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS);
80003a52:	35 2c       	mov	r12,82
80003a54:	f0 1f 00 0e 	mcall	80003a8c <dip204_example_PB_int_handler+0xa8>
	}
	/* decrease backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS))
80003a58:	35 5c       	mov	r12,85
80003a5a:	f0 1f 00 07 	mcall	80003a74 <dip204_example_PB_int_handler+0x90>
80003a5e:	c0 70       	breq	80003a6c <dip204_example_PB_int_handler+0x88>
	{
		dip204_set_backlight(backlight_power_decrease);
80003a60:	30 1c       	mov	r12,1
80003a62:	f0 1f 00 0c 	mcall	80003a90 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS);
80003a66:	35 5c       	mov	r12,85
80003a68:	f0 1f 00 09 	mcall	80003a8c <dip204_example_PB_int_handler+0xa8>
	}
}
80003a6c:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
80003a70:	d6 03       	rete
80003a72:	00 00       	add	r0,r0
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	27 12       	sub	r2,113
80003a78:	80 00       	ld.sh	r0,r0[0x0]
80003a7a:	22 24       	sub	r4,34
80003a7c:	00 00       	add	r0,r0
80003a7e:	07 4c       	ld.w	r12,--r3
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	22 80       	sub	r0,40
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	49 2c       	lddpc	r12,80003acc <free+0x8>
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	21 cc       	sub	r12,28
80003a8c:	80 00       	ld.sh	r0,r0[0x0]
80003a8e:	27 2a       	sub	r10,114
80003a90:	80 00       	ld.sh	r0,r0[0x0]
80003a92:	23 40       	sub	r0,52

80003a94 <atexit>:
80003a94:	d4 01       	pushm	lr
80003a96:	30 09       	mov	r9,0
80003a98:	18 9b       	mov	r11,r12
80003a9a:	12 9a       	mov	r10,r9
80003a9c:	12 9c       	mov	r12,r9
80003a9e:	e0 a0 03 17 	rcall	800040cc <__register_exitproc>
80003aa2:	d8 02       	popm	pc

80003aa4 <exit>:
80003aa4:	d4 21       	pushm	r4-r7,lr
80003aa6:	30 0b       	mov	r11,0
80003aa8:	18 97       	mov	r7,r12
80003aaa:	e0 a0 03 63 	rcall	80004170 <__call_exitprocs>
80003aae:	fe c8 f1 76 	sub	r8,pc,-3722
80003ab2:	70 0c       	ld.w	r12,r8[0x0]
80003ab4:	78 a8       	ld.w	r8,r12[0x28]
80003ab6:	58 08       	cp.w	r8,0
80003ab8:	c0 20       	breq	80003abc <exit+0x18>
80003aba:	5d 18       	icall	r8
80003abc:	0e 9c       	mov	r12,r7
80003abe:	e0 a0 02 e6 	rcall	8000408a <_exit>
80003ac2:	d7 03       	nop

80003ac4 <free>:
80003ac4:	d4 01       	pushm	lr
80003ac6:	e0 68 01 18 	mov	r8,280
80003aca:	18 9b       	mov	r11,r12
80003acc:	70 0c       	ld.w	r12,r8[0x0]
80003ace:	e0 a0 04 05 	rcall	800042d8 <_free_r>
80003ad2:	d8 02       	popm	pc

80003ad4 <malloc>:
80003ad4:	d4 01       	pushm	lr
80003ad6:	e0 68 01 18 	mov	r8,280
80003ada:	18 9b       	mov	r11,r12
80003adc:	70 0c       	ld.w	r12,r8[0x0]
80003ade:	c0 3c       	rcall	80003ae4 <_malloc_r>
80003ae0:	d8 02       	popm	pc
80003ae2:	d7 03       	nop

80003ae4 <_malloc_r>:
80003ae4:	d4 31       	pushm	r0-r7,lr
80003ae6:	f6 c8 ff f5 	sub	r8,r11,-11
80003aea:	18 95       	mov	r5,r12
80003aec:	10 97       	mov	r7,r8
80003aee:	e0 17 ff f8 	andl	r7,0xfff8
80003af2:	59 68       	cp.w	r8,22
80003af4:	f9 b7 08 10 	movls	r7,16
80003af8:	16 37       	cp.w	r7,r11
80003afa:	5f 38       	srlo	r8
80003afc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80003b00:	c0 50       	breq	80003b0a <_malloc_r+0x26>
80003b02:	30 c8       	mov	r8,12
80003b04:	99 38       	st.w	r12[0xc],r8
80003b06:	e0 8f 01 f8 	bral	80003ef6 <_malloc_r+0x412>
80003b0a:	fe b0 f9 3f 	rcall	80002d88 <__malloc_lock>
80003b0e:	e0 47 01 f7 	cp.w	r7,503
80003b12:	e0 8b 00 1d 	brhi	80003b4c <_malloc_r+0x68>
80003b16:	ee 03 16 03 	lsr	r3,r7,0x3
80003b1a:	e0 68 01 1c 	mov	r8,284
80003b1e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80003b22:	70 36       	ld.w	r6,r8[0xc]
80003b24:	10 36       	cp.w	r6,r8
80003b26:	c0 61       	brne	80003b32 <_malloc_r+0x4e>
80003b28:	ec c8 ff f8 	sub	r8,r6,-8
80003b2c:	70 36       	ld.w	r6,r8[0xc]
80003b2e:	10 36       	cp.w	r6,r8
80003b30:	c0 c0       	breq	80003b48 <_malloc_r+0x64>
80003b32:	6c 18       	ld.w	r8,r6[0x4]
80003b34:	e0 18 ff fc 	andl	r8,0xfffc
80003b38:	6c 3a       	ld.w	r10,r6[0xc]
80003b3a:	ec 08 00 09 	add	r9,r6,r8
80003b3e:	0a 9c       	mov	r12,r5
80003b40:	6c 28       	ld.w	r8,r6[0x8]
80003b42:	95 28       	st.w	r10[0x8],r8
80003b44:	91 3a       	st.w	r8[0xc],r10
80003b46:	c4 78       	rjmp	80003bd4 <_malloc_r+0xf0>
80003b48:	2f e3       	sub	r3,-2
80003b4a:	c4 d8       	rjmp	80003be4 <_malloc_r+0x100>
80003b4c:	ee 03 16 09 	lsr	r3,r7,0x9
80003b50:	c0 41       	brne	80003b58 <_malloc_r+0x74>
80003b52:	ee 03 16 03 	lsr	r3,r7,0x3
80003b56:	c2 68       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b58:	58 43       	cp.w	r3,4
80003b5a:	e0 8b 00 06 	brhi	80003b66 <_malloc_r+0x82>
80003b5e:	ee 03 16 06 	lsr	r3,r7,0x6
80003b62:	2c 83       	sub	r3,-56
80003b64:	c1 f8       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b66:	59 43       	cp.w	r3,20
80003b68:	e0 8b 00 04 	brhi	80003b70 <_malloc_r+0x8c>
80003b6c:	2a 53       	sub	r3,-91
80003b6e:	c1 a8       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b70:	e0 43 00 54 	cp.w	r3,84
80003b74:	e0 8b 00 06 	brhi	80003b80 <_malloc_r+0x9c>
80003b78:	ee 03 16 0c 	lsr	r3,r7,0xc
80003b7c:	29 23       	sub	r3,-110
80003b7e:	c1 28       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b80:	e0 43 01 54 	cp.w	r3,340
80003b84:	e0 8b 00 06 	brhi	80003b90 <_malloc_r+0xac>
80003b88:	ee 03 16 0f 	lsr	r3,r7,0xf
80003b8c:	28 93       	sub	r3,-119
80003b8e:	c0 a8       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b90:	e0 43 05 54 	cp.w	r3,1364
80003b94:	e0 88 00 04 	brls	80003b9c <_malloc_r+0xb8>
80003b98:	37 e3       	mov	r3,126
80003b9a:	c0 48       	rjmp	80003ba2 <_malloc_r+0xbe>
80003b9c:	ee 03 16 12 	lsr	r3,r7,0x12
80003ba0:	28 43       	sub	r3,-124
80003ba2:	e0 6a 01 1c 	mov	r10,284
80003ba6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80003baa:	74 36       	ld.w	r6,r10[0xc]
80003bac:	c1 98       	rjmp	80003bde <_malloc_r+0xfa>
80003bae:	6c 19       	ld.w	r9,r6[0x4]
80003bb0:	e0 19 ff fc 	andl	r9,0xfffc
80003bb4:	f2 07 01 0b 	sub	r11,r9,r7
80003bb8:	58 fb       	cp.w	r11,15
80003bba:	e0 8a 00 04 	brle	80003bc2 <_malloc_r+0xde>
80003bbe:	20 13       	sub	r3,1
80003bc0:	c1 18       	rjmp	80003be2 <_malloc_r+0xfe>
80003bc2:	6c 38       	ld.w	r8,r6[0xc]
80003bc4:	58 0b       	cp.w	r11,0
80003bc6:	c0 b5       	brlt	80003bdc <_malloc_r+0xf8>
80003bc8:	6c 2a       	ld.w	r10,r6[0x8]
80003bca:	ec 09 00 09 	add	r9,r6,r9
80003bce:	0a 9c       	mov	r12,r5
80003bd0:	91 2a       	st.w	r8[0x8],r10
80003bd2:	95 38       	st.w	r10[0xc],r8
80003bd4:	72 18       	ld.w	r8,r9[0x4]
80003bd6:	a1 a8       	sbr	r8,0x0
80003bd8:	93 18       	st.w	r9[0x4],r8
80003bda:	cb c8       	rjmp	80003d52 <_malloc_r+0x26e>
80003bdc:	10 96       	mov	r6,r8
80003bde:	14 36       	cp.w	r6,r10
80003be0:	ce 71       	brne	80003bae <_malloc_r+0xca>
80003be2:	2f f3       	sub	r3,-1
80003be4:	e0 6a 01 1c 	mov	r10,284
80003be8:	f4 cc ff f8 	sub	r12,r10,-8
80003bec:	78 26       	ld.w	r6,r12[0x8]
80003bee:	18 36       	cp.w	r6,r12
80003bf0:	c6 c0       	breq	80003cc8 <_malloc_r+0x1e4>
80003bf2:	6c 19       	ld.w	r9,r6[0x4]
80003bf4:	e0 19 ff fc 	andl	r9,0xfffc
80003bf8:	f2 07 01 08 	sub	r8,r9,r7
80003bfc:	58 f8       	cp.w	r8,15
80003bfe:	e0 89 00 8f 	brgt	80003d1c <_malloc_r+0x238>
80003c02:	99 3c       	st.w	r12[0xc],r12
80003c04:	99 2c       	st.w	r12[0x8],r12
80003c06:	58 08       	cp.w	r8,0
80003c08:	c0 55       	brlt	80003c12 <_malloc_r+0x12e>
80003c0a:	ec 09 00 09 	add	r9,r6,r9
80003c0e:	0a 9c       	mov	r12,r5
80003c10:	ce 2b       	rjmp	80003bd4 <_malloc_r+0xf0>
80003c12:	e0 49 01 ff 	cp.w	r9,511
80003c16:	e0 8b 00 13 	brhi	80003c3c <_malloc_r+0x158>
80003c1a:	a3 99       	lsr	r9,0x3
80003c1c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80003c20:	70 2b       	ld.w	r11,r8[0x8]
80003c22:	8d 38       	st.w	r6[0xc],r8
80003c24:	8d 2b       	st.w	r6[0x8],r11
80003c26:	97 36       	st.w	r11[0xc],r6
80003c28:	91 26       	st.w	r8[0x8],r6
80003c2a:	a3 49       	asr	r9,0x2
80003c2c:	74 18       	ld.w	r8,r10[0x4]
80003c2e:	30 1b       	mov	r11,1
80003c30:	f6 09 09 49 	lsl	r9,r11,r9
80003c34:	f1 e9 10 09 	or	r9,r8,r9
80003c38:	95 19       	st.w	r10[0x4],r9
80003c3a:	c4 78       	rjmp	80003cc8 <_malloc_r+0x1e4>
80003c3c:	f2 0a 16 09 	lsr	r10,r9,0x9
80003c40:	58 4a       	cp.w	r10,4
80003c42:	e0 8b 00 07 	brhi	80003c50 <_malloc_r+0x16c>
80003c46:	f2 0a 16 06 	lsr	r10,r9,0x6
80003c4a:	2c 8a       	sub	r10,-56
80003c4c:	c2 08       	rjmp	80003c8c <_malloc_r+0x1a8>
80003c4e:	d7 03       	nop
80003c50:	59 4a       	cp.w	r10,20
80003c52:	e0 8b 00 04 	brhi	80003c5a <_malloc_r+0x176>
80003c56:	2a 5a       	sub	r10,-91
80003c58:	c1 a8       	rjmp	80003c8c <_malloc_r+0x1a8>
80003c5a:	e0 4a 00 54 	cp.w	r10,84
80003c5e:	e0 8b 00 06 	brhi	80003c6a <_malloc_r+0x186>
80003c62:	f2 0a 16 0c 	lsr	r10,r9,0xc
80003c66:	29 2a       	sub	r10,-110
80003c68:	c1 28       	rjmp	80003c8c <_malloc_r+0x1a8>
80003c6a:	e0 4a 01 54 	cp.w	r10,340
80003c6e:	e0 8b 00 06 	brhi	80003c7a <_malloc_r+0x196>
80003c72:	f2 0a 16 0f 	lsr	r10,r9,0xf
80003c76:	28 9a       	sub	r10,-119
80003c78:	c0 a8       	rjmp	80003c8c <_malloc_r+0x1a8>
80003c7a:	e0 4a 05 54 	cp.w	r10,1364
80003c7e:	e0 88 00 04 	brls	80003c86 <_malloc_r+0x1a2>
80003c82:	37 ea       	mov	r10,126
80003c84:	c0 48       	rjmp	80003c8c <_malloc_r+0x1a8>
80003c86:	f2 0a 16 12 	lsr	r10,r9,0x12
80003c8a:	28 4a       	sub	r10,-124
80003c8c:	e0 6b 01 1c 	mov	r11,284
80003c90:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80003c94:	68 28       	ld.w	r8,r4[0x8]
80003c96:	08 38       	cp.w	r8,r4
80003c98:	c0 e1       	brne	80003cb4 <_malloc_r+0x1d0>
80003c9a:	76 19       	ld.w	r9,r11[0x4]
80003c9c:	a3 4a       	asr	r10,0x2
80003c9e:	30 1e       	mov	lr,1
80003ca0:	fc 0a 09 4a 	lsl	r10,lr,r10
80003ca4:	f3 ea 10 0a 	or	r10,r9,r10
80003ca8:	10 99       	mov	r9,r8
80003caa:	97 1a       	st.w	r11[0x4],r10
80003cac:	c0 a8       	rjmp	80003cc0 <_malloc_r+0x1dc>
80003cae:	70 28       	ld.w	r8,r8[0x8]
80003cb0:	08 38       	cp.w	r8,r4
80003cb2:	c0 60       	breq	80003cbe <_malloc_r+0x1da>
80003cb4:	70 1a       	ld.w	r10,r8[0x4]
80003cb6:	e0 1a ff fc 	andl	r10,0xfffc
80003cba:	14 39       	cp.w	r9,r10
80003cbc:	cf 93       	brcs	80003cae <_malloc_r+0x1ca>
80003cbe:	70 39       	ld.w	r9,r8[0xc]
80003cc0:	8d 39       	st.w	r6[0xc],r9
80003cc2:	8d 28       	st.w	r6[0x8],r8
80003cc4:	91 36       	st.w	r8[0xc],r6
80003cc6:	93 26       	st.w	r9[0x8],r6
80003cc8:	e6 08 14 02 	asr	r8,r3,0x2
80003ccc:	30 1b       	mov	r11,1
80003cce:	e0 64 01 1c 	mov	r4,284
80003cd2:	f6 08 09 4b 	lsl	r11,r11,r8
80003cd6:	68 18       	ld.w	r8,r4[0x4]
80003cd8:	10 3b       	cp.w	r11,r8
80003cda:	e0 8b 00 6b 	brhi	80003db0 <_malloc_r+0x2cc>
80003cde:	f7 e8 00 09 	and	r9,r11,r8
80003ce2:	c0 b1       	brne	80003cf8 <_malloc_r+0x214>
80003ce4:	e0 13 ff fc 	andl	r3,0xfffc
80003ce8:	a1 7b       	lsl	r11,0x1
80003cea:	2f c3       	sub	r3,-4
80003cec:	c0 38       	rjmp	80003cf2 <_malloc_r+0x20e>
80003cee:	2f c3       	sub	r3,-4
80003cf0:	a1 7b       	lsl	r11,0x1
80003cf2:	f7 e8 00 09 	and	r9,r11,r8
80003cf6:	cf c0       	breq	80003cee <_malloc_r+0x20a>
80003cf8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80003cfc:	06 92       	mov	r2,r3
80003cfe:	1c 91       	mov	r1,lr
80003d00:	62 36       	ld.w	r6,r1[0xc]
80003d02:	c2 e8       	rjmp	80003d5e <_malloc_r+0x27a>
80003d04:	6c 1a       	ld.w	r10,r6[0x4]
80003d06:	e0 1a ff fc 	andl	r10,0xfffc
80003d0a:	f4 07 01 08 	sub	r8,r10,r7
80003d0e:	58 f8       	cp.w	r8,15
80003d10:	e0 8a 00 15 	brle	80003d3a <_malloc_r+0x256>
80003d14:	6c 3a       	ld.w	r10,r6[0xc]
80003d16:	6c 29       	ld.w	r9,r6[0x8]
80003d18:	95 29       	st.w	r10[0x8],r9
80003d1a:	93 3a       	st.w	r9[0xc],r10
80003d1c:	0e 99       	mov	r9,r7
80003d1e:	ec 07 00 07 	add	r7,r6,r7
80003d22:	a1 a9       	sbr	r9,0x0
80003d24:	99 37       	st.w	r12[0xc],r7
80003d26:	99 27       	st.w	r12[0x8],r7
80003d28:	8d 19       	st.w	r6[0x4],r9
80003d2a:	ee 08 09 08 	st.w	r7[r8],r8
80003d2e:	8f 2c       	st.w	r7[0x8],r12
80003d30:	8f 3c       	st.w	r7[0xc],r12
80003d32:	a1 a8       	sbr	r8,0x0
80003d34:	0a 9c       	mov	r12,r5
80003d36:	8f 18       	st.w	r7[0x4],r8
80003d38:	c0 d8       	rjmp	80003d52 <_malloc_r+0x26e>
80003d3a:	6c 39       	ld.w	r9,r6[0xc]
80003d3c:	58 08       	cp.w	r8,0
80003d3e:	c0 f5       	brlt	80003d5c <_malloc_r+0x278>
80003d40:	ec 0a 00 0a 	add	r10,r6,r10
80003d44:	74 18       	ld.w	r8,r10[0x4]
80003d46:	a1 a8       	sbr	r8,0x0
80003d48:	0a 9c       	mov	r12,r5
80003d4a:	95 18       	st.w	r10[0x4],r8
80003d4c:	6c 28       	ld.w	r8,r6[0x8]
80003d4e:	93 28       	st.w	r9[0x8],r8
80003d50:	91 39       	st.w	r8[0xc],r9
80003d52:	fe b0 f8 21 	rcall	80002d94 <__malloc_unlock>
80003d56:	ec cc ff f8 	sub	r12,r6,-8
80003d5a:	d8 32       	popm	r0-r7,pc
80003d5c:	12 96       	mov	r6,r9
80003d5e:	02 36       	cp.w	r6,r1
80003d60:	cd 21       	brne	80003d04 <_malloc_r+0x220>
80003d62:	2f f2       	sub	r2,-1
80003d64:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80003d68:	c0 30       	breq	80003d6e <_malloc_r+0x28a>
80003d6a:	2f 81       	sub	r1,-8
80003d6c:	cc ab       	rjmp	80003d00 <_malloc_r+0x21c>
80003d6e:	1c 98       	mov	r8,lr
80003d70:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80003d74:	c0 81       	brne	80003d84 <_malloc_r+0x2a0>
80003d76:	68 19       	ld.w	r9,r4[0x4]
80003d78:	f6 08 11 ff 	rsub	r8,r11,-1
80003d7c:	f3 e8 00 08 	and	r8,r9,r8
80003d80:	89 18       	st.w	r4[0x4],r8
80003d82:	c0 78       	rjmp	80003d90 <_malloc_r+0x2ac>
80003d84:	f0 c9 00 08 	sub	r9,r8,8
80003d88:	20 13       	sub	r3,1
80003d8a:	70 08       	ld.w	r8,r8[0x0]
80003d8c:	12 38       	cp.w	r8,r9
80003d8e:	cf 10       	breq	80003d70 <_malloc_r+0x28c>
80003d90:	a1 7b       	lsl	r11,0x1
80003d92:	68 18       	ld.w	r8,r4[0x4]
80003d94:	10 3b       	cp.w	r11,r8
80003d96:	e0 8b 00 0d 	brhi	80003db0 <_malloc_r+0x2cc>
80003d9a:	58 0b       	cp.w	r11,0
80003d9c:	c0 a0       	breq	80003db0 <_malloc_r+0x2cc>
80003d9e:	04 93       	mov	r3,r2
80003da0:	c0 38       	rjmp	80003da6 <_malloc_r+0x2c2>
80003da2:	2f c3       	sub	r3,-4
80003da4:	a1 7b       	lsl	r11,0x1
80003da6:	f7 e8 00 09 	and	r9,r11,r8
80003daa:	ca 71       	brne	80003cf8 <_malloc_r+0x214>
80003dac:	cf bb       	rjmp	80003da2 <_malloc_r+0x2be>
80003dae:	d7 03       	nop
80003db0:	68 23       	ld.w	r3,r4[0x8]
80003db2:	66 12       	ld.w	r2,r3[0x4]
80003db4:	e0 12 ff fc 	andl	r2,0xfffc
80003db8:	0e 32       	cp.w	r2,r7
80003dba:	5f 39       	srlo	r9
80003dbc:	e4 07 01 08 	sub	r8,r2,r7
80003dc0:	58 f8       	cp.w	r8,15
80003dc2:	5f aa       	srle	r10
80003dc4:	f5 e9 10 09 	or	r9,r10,r9
80003dc8:	e0 80 00 98 	breq	80003ef8 <_malloc_r+0x414>
80003dcc:	e0 68 07 58 	mov	r8,1880
80003dd0:	70 01       	ld.w	r1,r8[0x0]
80003dd2:	e0 68 05 28 	mov	r8,1320
80003dd6:	2f 01       	sub	r1,-16
80003dd8:	70 08       	ld.w	r8,r8[0x0]
80003dda:	0e 01       	add	r1,r7
80003ddc:	5b f8       	cp.w	r8,-1
80003dde:	c0 40       	breq	80003de6 <_malloc_r+0x302>
80003de0:	28 11       	sub	r1,-127
80003de2:	e0 11 ff 80 	andl	r1,0xff80
80003de6:	02 9b       	mov	r11,r1
80003de8:	0a 9c       	mov	r12,r5
80003dea:	c3 bd       	rcall	80004060 <_sbrk_r>
80003dec:	18 96       	mov	r6,r12
80003dee:	5b fc       	cp.w	r12,-1
80003df0:	c7 40       	breq	80003ed8 <_malloc_r+0x3f4>
80003df2:	e6 02 00 08 	add	r8,r3,r2
80003df6:	10 3c       	cp.w	r12,r8
80003df8:	c0 32       	brcc	80003dfe <_malloc_r+0x31a>
80003dfa:	08 33       	cp.w	r3,r4
80003dfc:	c6 e1       	brne	80003ed8 <_malloc_r+0x3f4>
80003dfe:	e0 6a 07 5c 	mov	r10,1884
80003e02:	74 09       	ld.w	r9,r10[0x0]
80003e04:	e2 09 00 09 	add	r9,r1,r9
80003e08:	95 09       	st.w	r10[0x0],r9
80003e0a:	10 36       	cp.w	r6,r8
80003e0c:	c0 a1       	brne	80003e20 <_malloc_r+0x33c>
80003e0e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80003e12:	c0 71       	brne	80003e20 <_malloc_r+0x33c>
80003e14:	e2 02 00 02 	add	r2,r1,r2
80003e18:	68 28       	ld.w	r8,r4[0x8]
80003e1a:	a1 a2       	sbr	r2,0x0
80003e1c:	91 12       	st.w	r8[0x4],r2
80003e1e:	c4 e8       	rjmp	80003eba <_malloc_r+0x3d6>
80003e20:	e0 6a 05 28 	mov	r10,1320
80003e24:	74 0b       	ld.w	r11,r10[0x0]
80003e26:	5b fb       	cp.w	r11,-1
80003e28:	c0 31       	brne	80003e2e <_malloc_r+0x34a>
80003e2a:	95 06       	st.w	r10[0x0],r6
80003e2c:	c0 78       	rjmp	80003e3a <_malloc_r+0x356>
80003e2e:	ec 09 00 09 	add	r9,r6,r9
80003e32:	e0 6a 07 5c 	mov	r10,1884
80003e36:	10 19       	sub	r9,r8
80003e38:	95 09       	st.w	r10[0x0],r9
80003e3a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80003e3e:	f0 09 11 08 	rsub	r9,r8,8
80003e42:	58 08       	cp.w	r8,0
80003e44:	f2 08 17 10 	movne	r8,r9
80003e48:	ed d8 e1 06 	addne	r6,r6,r8
80003e4c:	28 08       	sub	r8,-128
80003e4e:	ec 01 00 01 	add	r1,r6,r1
80003e52:	0a 9c       	mov	r12,r5
80003e54:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80003e58:	f0 01 01 01 	sub	r1,r8,r1
80003e5c:	02 9b       	mov	r11,r1
80003e5e:	c0 1d       	rcall	80004060 <_sbrk_r>
80003e60:	e0 68 07 5c 	mov	r8,1884
80003e64:	5b fc       	cp.w	r12,-1
80003e66:	ec 0c 17 00 	moveq	r12,r6
80003e6a:	f9 b1 00 00 	moveq	r1,0
80003e6e:	70 09       	ld.w	r9,r8[0x0]
80003e70:	0c 1c       	sub	r12,r6
80003e72:	89 26       	st.w	r4[0x8],r6
80003e74:	02 0c       	add	r12,r1
80003e76:	12 01       	add	r1,r9
80003e78:	a1 ac       	sbr	r12,0x0
80003e7a:	91 01       	st.w	r8[0x0],r1
80003e7c:	8d 1c       	st.w	r6[0x4],r12
80003e7e:	08 33       	cp.w	r3,r4
80003e80:	c1 d0       	breq	80003eba <_malloc_r+0x3d6>
80003e82:	58 f2       	cp.w	r2,15
80003e84:	e0 8b 00 05 	brhi	80003e8e <_malloc_r+0x3aa>
80003e88:	30 18       	mov	r8,1
80003e8a:	8d 18       	st.w	r6[0x4],r8
80003e8c:	c2 68       	rjmp	80003ed8 <_malloc_r+0x3f4>
80003e8e:	30 59       	mov	r9,5
80003e90:	20 c2       	sub	r2,12
80003e92:	e0 12 ff f8 	andl	r2,0xfff8
80003e96:	e6 02 00 08 	add	r8,r3,r2
80003e9a:	91 29       	st.w	r8[0x8],r9
80003e9c:	91 19       	st.w	r8[0x4],r9
80003e9e:	66 18       	ld.w	r8,r3[0x4]
80003ea0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003ea4:	e5 e8 10 08 	or	r8,r2,r8
80003ea8:	87 18       	st.w	r3[0x4],r8
80003eaa:	58 f2       	cp.w	r2,15
80003eac:	e0 88 00 07 	brls	80003eba <_malloc_r+0x3d6>
80003eb0:	e6 cb ff f8 	sub	r11,r3,-8
80003eb4:	0a 9c       	mov	r12,r5
80003eb6:	e0 a0 02 11 	rcall	800042d8 <_free_r>
80003eba:	e0 69 07 54 	mov	r9,1876
80003ebe:	72 0a       	ld.w	r10,r9[0x0]
80003ec0:	e0 68 07 5c 	mov	r8,1884
80003ec4:	70 08       	ld.w	r8,r8[0x0]
80003ec6:	14 38       	cp.w	r8,r10
80003ec8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003ecc:	e0 69 07 50 	mov	r9,1872
80003ed0:	72 0a       	ld.w	r10,r9[0x0]
80003ed2:	14 38       	cp.w	r8,r10
80003ed4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003ed8:	68 28       	ld.w	r8,r4[0x8]
80003eda:	70 18       	ld.w	r8,r8[0x4]
80003edc:	e0 18 ff fc 	andl	r8,0xfffc
80003ee0:	0e 38       	cp.w	r8,r7
80003ee2:	5f 39       	srlo	r9
80003ee4:	0e 18       	sub	r8,r7
80003ee6:	58 f8       	cp.w	r8,15
80003ee8:	5f aa       	srle	r10
80003eea:	f5 e9 10 09 	or	r9,r10,r9
80003eee:	c0 50       	breq	80003ef8 <_malloc_r+0x414>
80003ef0:	0a 9c       	mov	r12,r5
80003ef2:	fe b0 f7 51 	rcall	80002d94 <__malloc_unlock>
80003ef6:	d8 3a       	popm	r0-r7,pc,r12=0
80003ef8:	68 26       	ld.w	r6,r4[0x8]
80003efa:	a1 a8       	sbr	r8,0x0
80003efc:	0e 99       	mov	r9,r7
80003efe:	a1 a9       	sbr	r9,0x0
80003f00:	8d 19       	st.w	r6[0x4],r9
80003f02:	ec 07 00 07 	add	r7,r6,r7
80003f06:	0a 9c       	mov	r12,r5
80003f08:	89 27       	st.w	r4[0x8],r7
80003f0a:	8f 18       	st.w	r7[0x4],r8
80003f0c:	fe b0 f7 44 	rcall	80002d94 <__malloc_unlock>
80003f10:	ec cc ff f8 	sub	r12,r6,-8
80003f14:	d8 32       	popm	r0-r7,pc
80003f16:	d7 03       	nop

80003f18 <memcpy>:
80003f18:	58 8a       	cp.w	r10,8
80003f1a:	c2 f5       	brlt	80003f78 <memcpy+0x60>
80003f1c:	f9 eb 10 09 	or	r9,r12,r11
80003f20:	e2 19 00 03 	andl	r9,0x3,COH
80003f24:	e0 81 00 97 	brne	80004052 <memcpy+0x13a>
80003f28:	e0 4a 00 20 	cp.w	r10,32
80003f2c:	c3 b4       	brge	80003fa2 <memcpy+0x8a>
80003f2e:	f4 08 14 02 	asr	r8,r10,0x2
80003f32:	f0 09 11 08 	rsub	r9,r8,8
80003f36:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80003f3a:	76 69       	ld.w	r9,r11[0x18]
80003f3c:	99 69       	st.w	r12[0x18],r9
80003f3e:	76 59       	ld.w	r9,r11[0x14]
80003f40:	99 59       	st.w	r12[0x14],r9
80003f42:	76 49       	ld.w	r9,r11[0x10]
80003f44:	99 49       	st.w	r12[0x10],r9
80003f46:	76 39       	ld.w	r9,r11[0xc]
80003f48:	99 39       	st.w	r12[0xc],r9
80003f4a:	76 29       	ld.w	r9,r11[0x8]
80003f4c:	99 29       	st.w	r12[0x8],r9
80003f4e:	76 19       	ld.w	r9,r11[0x4]
80003f50:	99 19       	st.w	r12[0x4],r9
80003f52:	76 09       	ld.w	r9,r11[0x0]
80003f54:	99 09       	st.w	r12[0x0],r9
80003f56:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80003f5a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80003f5e:	e0 1a 00 03 	andl	r10,0x3
80003f62:	f4 0a 11 04 	rsub	r10,r10,4
80003f66:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003f6a:	17 a9       	ld.ub	r9,r11[0x2]
80003f6c:	b0 a9       	st.b	r8[0x2],r9
80003f6e:	17 99       	ld.ub	r9,r11[0x1]
80003f70:	b0 99       	st.b	r8[0x1],r9
80003f72:	17 89       	ld.ub	r9,r11[0x0]
80003f74:	b0 89       	st.b	r8[0x0],r9
80003f76:	5e fc       	retal	r12
80003f78:	f4 0a 11 09 	rsub	r10,r10,9
80003f7c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003f80:	17 f9       	ld.ub	r9,r11[0x7]
80003f82:	b8 f9       	st.b	r12[0x7],r9
80003f84:	17 e9       	ld.ub	r9,r11[0x6]
80003f86:	b8 e9       	st.b	r12[0x6],r9
80003f88:	17 d9       	ld.ub	r9,r11[0x5]
80003f8a:	b8 d9       	st.b	r12[0x5],r9
80003f8c:	17 c9       	ld.ub	r9,r11[0x4]
80003f8e:	b8 c9       	st.b	r12[0x4],r9
80003f90:	17 b9       	ld.ub	r9,r11[0x3]
80003f92:	b8 b9       	st.b	r12[0x3],r9
80003f94:	17 a9       	ld.ub	r9,r11[0x2]
80003f96:	b8 a9       	st.b	r12[0x2],r9
80003f98:	17 99       	ld.ub	r9,r11[0x1]
80003f9a:	b8 99       	st.b	r12[0x1],r9
80003f9c:	17 89       	ld.ub	r9,r11[0x0]
80003f9e:	b8 89       	st.b	r12[0x0],r9
80003fa0:	5e fc       	retal	r12
80003fa2:	eb cd 40 c0 	pushm	r6-r7,lr
80003fa6:	18 99       	mov	r9,r12
80003fa8:	22 0a       	sub	r10,32
80003faa:	b7 07       	ld.d	r6,r11++
80003fac:	b3 26       	st.d	r9++,r6
80003fae:	b7 07       	ld.d	r6,r11++
80003fb0:	b3 26       	st.d	r9++,r6
80003fb2:	b7 07       	ld.d	r6,r11++
80003fb4:	b3 26       	st.d	r9++,r6
80003fb6:	b7 07       	ld.d	r6,r11++
80003fb8:	b3 26       	st.d	r9++,r6
80003fba:	22 0a       	sub	r10,32
80003fbc:	cf 74       	brge	80003faa <memcpy+0x92>
80003fbe:	2f 0a       	sub	r10,-16
80003fc0:	c0 65       	brlt	80003fcc <memcpy+0xb4>
80003fc2:	b7 07       	ld.d	r6,r11++
80003fc4:	b3 26       	st.d	r9++,r6
80003fc6:	b7 07       	ld.d	r6,r11++
80003fc8:	b3 26       	st.d	r9++,r6
80003fca:	21 0a       	sub	r10,16
80003fcc:	5c 3a       	neg	r10
80003fce:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80003fd2:	d7 03       	nop
80003fd4:	d7 03       	nop
80003fd6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80003fda:	f3 66 00 0e 	st.b	r9[14],r6
80003fde:	f7 36 00 0d 	ld.ub	r6,r11[13]
80003fe2:	f3 66 00 0d 	st.b	r9[13],r6
80003fe6:	f7 36 00 0c 	ld.ub	r6,r11[12]
80003fea:	f3 66 00 0c 	st.b	r9[12],r6
80003fee:	f7 36 00 0b 	ld.ub	r6,r11[11]
80003ff2:	f3 66 00 0b 	st.b	r9[11],r6
80003ff6:	f7 36 00 0a 	ld.ub	r6,r11[10]
80003ffa:	f3 66 00 0a 	st.b	r9[10],r6
80003ffe:	f7 36 00 09 	ld.ub	r6,r11[9]
80004002:	f3 66 00 09 	st.b	r9[9],r6
80004006:	f7 36 00 08 	ld.ub	r6,r11[8]
8000400a:	f3 66 00 08 	st.b	r9[8],r6
8000400e:	f7 36 00 07 	ld.ub	r6,r11[7]
80004012:	f3 66 00 07 	st.b	r9[7],r6
80004016:	f7 36 00 06 	ld.ub	r6,r11[6]
8000401a:	f3 66 00 06 	st.b	r9[6],r6
8000401e:	f7 36 00 05 	ld.ub	r6,r11[5]
80004022:	f3 66 00 05 	st.b	r9[5],r6
80004026:	f7 36 00 04 	ld.ub	r6,r11[4]
8000402a:	f3 66 00 04 	st.b	r9[4],r6
8000402e:	f7 36 00 03 	ld.ub	r6,r11[3]
80004032:	f3 66 00 03 	st.b	r9[3],r6
80004036:	f7 36 00 02 	ld.ub	r6,r11[2]
8000403a:	f3 66 00 02 	st.b	r9[2],r6
8000403e:	f7 36 00 01 	ld.ub	r6,r11[1]
80004042:	f3 66 00 01 	st.b	r9[1],r6
80004046:	f7 36 00 00 	ld.ub	r6,r11[0]
8000404a:	f3 66 00 00 	st.b	r9[0],r6
8000404e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004052:	20 1a       	sub	r10,1
80004054:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80004058:	f8 0a 0b 09 	st.b	r12[r10],r9
8000405c:	cf b1       	brne	80004052 <memcpy+0x13a>
8000405e:	5e fc       	retal	r12

80004060 <_sbrk_r>:
80004060:	d4 21       	pushm	r4-r7,lr
80004062:	30 08       	mov	r8,0
80004064:	18 97       	mov	r7,r12
80004066:	e0 66 07 90 	mov	r6,1936
8000406a:	16 9c       	mov	r12,r11
8000406c:	8d 08       	st.w	r6[0x0],r8
8000406e:	c1 3c       	rcall	80004094 <_sbrk>
80004070:	5b fc       	cp.w	r12,-1
80004072:	c0 51       	brne	8000407c <_sbrk_r+0x1c>
80004074:	6c 08       	ld.w	r8,r6[0x0]
80004076:	58 08       	cp.w	r8,0
80004078:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000407c:	d8 22       	popm	r4-r7,pc
8000407e:	d7 03       	nop

80004080 <_init_argv>:
80004080:	30 e8       	mov	r8,14
80004082:	d6 73       	breakpoint
80004084:	3f fc       	mov	r12,-1
80004086:	35 8b       	mov	r11,88
80004088:	5e fc       	retal	r12

8000408a <_exit>:
8000408a:	30 d8       	mov	r8,13
8000408c:	d6 73       	breakpoint
8000408e:	3f fc       	mov	r12,-1
80004090:	35 8b       	mov	r11,88
80004092:	c0 08       	rjmp	80004092 <_exit+0x8>

80004094 <_sbrk>:
80004094:	d4 01       	pushm	lr
80004096:	e0 68 07 84 	mov	r8,1924
8000409a:	70 09       	ld.w	r9,r8[0x0]
8000409c:	58 09       	cp.w	r9,0
8000409e:	c0 41       	brne	800040a6 <_sbrk+0x12>
800040a0:	e0 69 07 98 	mov	r9,1944
800040a4:	91 09       	st.w	r8[0x0],r9
800040a6:	e0 69 07 84 	mov	r9,1924
800040aa:	e0 6a f0 00 	mov	r10,61440
800040ae:	72 08       	ld.w	r8,r9[0x0]
800040b0:	f0 0c 00 0c 	add	r12,r8,r12
800040b4:	14 3c       	cp.w	r12,r10
800040b6:	e0 8b 00 04 	brhi	800040be <_sbrk+0x2a>
800040ba:	93 0c       	st.w	r9[0x0],r12
800040bc:	c0 58       	rjmp	800040c6 <_sbrk+0x32>
800040be:	cb fc       	rcall	8000423c <__errno>
800040c0:	30 c8       	mov	r8,12
800040c2:	99 08       	st.w	r12[0x0],r8
800040c4:	3f f8       	mov	r8,-1
800040c6:	10 9c       	mov	r12,r8
800040c8:	d8 02       	popm	pc
800040ca:	d7 03       	nop

800040cc <__register_exitproc>:
800040cc:	d4 31       	pushm	r0-r7,lr
800040ce:	fe c8 f7 96 	sub	r8,pc,-2154
800040d2:	70 03       	ld.w	r3,r8[0x0]
800040d4:	67 24       	ld.w	r4,r3[0x48]
800040d6:	e6 c8 ff b4 	sub	r8,r3,-76
800040da:	58 04       	cp.w	r4,0
800040dc:	f0 04 17 00 	moveq	r4,r8
800040e0:	e7 f4 0a 12 	st.weq	r3[0x48],r4
800040e4:	18 97       	mov	r7,r12
800040e6:	16 96       	mov	r6,r11
800040e8:	14 95       	mov	r5,r10
800040ea:	12 92       	mov	r2,r9
800040ec:	68 18       	ld.w	r8,r4[0x4]
800040ee:	59 f8       	cp.w	r8,31
800040f0:	e0 8a 00 0e 	brle	8000410c <__register_exitproc+0x40>
800040f4:	e0 6c 00 8c 	mov	r12,140
800040f8:	fe b0 fc ee 	rcall	80003ad4 <malloc>
800040fc:	18 94       	mov	r4,r12
800040fe:	c3 80       	breq	8000416e <__register_exitproc+0xa2>
80004100:	67 28       	ld.w	r8,r3[0x48]
80004102:	99 08       	st.w	r12[0x0],r8
80004104:	e7 4c 00 48 	st.w	r3[72],r12
80004108:	30 08       	mov	r8,0
8000410a:	99 18       	st.w	r12[0x4],r8
8000410c:	58 07       	cp.w	r7,0
8000410e:	c2 70       	breq	8000415c <__register_exitproc+0x90>
80004110:	e8 fc 00 88 	ld.w	r12,r4[136]
80004114:	58 0c       	cp.w	r12,0
80004116:	c0 d1       	brne	80004130 <__register_exitproc+0x64>
80004118:	e0 6c 01 08 	mov	r12,264
8000411c:	fe b0 fc dc 	rcall	80003ad4 <malloc>
80004120:	c2 70       	breq	8000416e <__register_exitproc+0xa2>
80004122:	30 08       	mov	r8,0
80004124:	e9 4c 00 88 	st.w	r4[136],r12
80004128:	f9 48 01 04 	st.w	r12[260],r8
8000412c:	f9 48 01 00 	st.w	r12[256],r8
80004130:	68 18       	ld.w	r8,r4[0x4]
80004132:	f0 c9 ff e0 	sub	r9,r8,-32
80004136:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000413a:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000413e:	30 1a       	mov	r10,1
80004140:	f8 f9 01 00 	ld.w	r9,r12[256]
80004144:	f4 08 09 48 	lsl	r8,r10,r8
80004148:	10 49       	or	r9,r8
8000414a:	f9 49 01 00 	st.w	r12[256],r9
8000414e:	58 27       	cp.w	r7,2
80004150:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004154:	f3 d8 e0 38 	oreq	r8,r9,r8
80004158:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000415c:	68 18       	ld.w	r8,r4[0x4]
8000415e:	30 0c       	mov	r12,0
80004160:	f0 c9 ff ff 	sub	r9,r8,-1
80004164:	2f e8       	sub	r8,-2
80004166:	89 19       	st.w	r4[0x4],r9
80004168:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000416c:	d8 32       	popm	r0-r7,pc
8000416e:	dc 3a       	popm	r0-r7,pc,r12=-1

80004170 <__call_exitprocs>:
80004170:	d4 31       	pushm	r0-r7,lr
80004172:	20 3d       	sub	sp,12
80004174:	fe c8 f8 3c 	sub	r8,pc,-1988
80004178:	50 2c       	stdsp	sp[0x8],r12
8000417a:	70 08       	ld.w	r8,r8[0x0]
8000417c:	16 91       	mov	r1,r11
8000417e:	50 08       	stdsp	sp[0x0],r8
80004180:	2b 88       	sub	r8,-72
80004182:	50 18       	stdsp	sp[0x4],r8
80004184:	40 0a       	lddsp	r10,sp[0x0]
80004186:	40 14       	lddsp	r4,sp[0x4]
80004188:	75 27       	ld.w	r7,r10[0x48]
8000418a:	c5 58       	rjmp	80004234 <__call_exitprocs+0xc4>
8000418c:	6e 15       	ld.w	r5,r7[0x4]
8000418e:	ee f6 00 88 	ld.w	r6,r7[136]
80004192:	ea c2 ff ff 	sub	r2,r5,-1
80004196:	20 15       	sub	r5,1
80004198:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000419c:	ec 05 00 23 	add	r3,r6,r5<<0x2
800041a0:	c3 58       	rjmp	8000420a <__call_exitprocs+0x9a>
800041a2:	58 01       	cp.w	r1,0
800041a4:	c0 70       	breq	800041b2 <__call_exitprocs+0x42>
800041a6:	58 06       	cp.w	r6,0
800041a8:	c2 e0       	breq	80004204 <__call_exitprocs+0x94>
800041aa:	e6 f8 00 80 	ld.w	r8,r3[128]
800041ae:	02 38       	cp.w	r8,r1
800041b0:	c2 a1       	brne	80004204 <__call_exitprocs+0x94>
800041b2:	6e 19       	ld.w	r9,r7[0x4]
800041b4:	64 08       	ld.w	r8,r2[0x0]
800041b6:	20 19       	sub	r9,1
800041b8:	12 35       	cp.w	r5,r9
800041ba:	ef f5 0a 01 	st.weq	r7[0x4],r5
800041be:	f9 b9 01 00 	movne	r9,0
800041c2:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800041c6:	58 08       	cp.w	r8,0
800041c8:	c1 e0       	breq	80004204 <__call_exitprocs+0x94>
800041ca:	6e 10       	ld.w	r0,r7[0x4]
800041cc:	58 06       	cp.w	r6,0
800041ce:	c0 90       	breq	800041e0 <__call_exitprocs+0x70>
800041d0:	30 1a       	mov	r10,1
800041d2:	f4 05 09 49 	lsl	r9,r10,r5
800041d6:	ec fa 01 00 	ld.w	r10,r6[256]
800041da:	f3 ea 00 0a 	and	r10,r9,r10
800041de:	c0 31       	brne	800041e4 <__call_exitprocs+0x74>
800041e0:	5d 18       	icall	r8
800041e2:	c0 b8       	rjmp	800041f8 <__call_exitprocs+0x88>
800041e4:	ec fa 01 04 	ld.w	r10,r6[260]
800041e8:	66 0b       	ld.w	r11,r3[0x0]
800041ea:	14 69       	and	r9,r10
800041ec:	c0 41       	brne	800041f4 <__call_exitprocs+0x84>
800041ee:	40 2c       	lddsp	r12,sp[0x8]
800041f0:	5d 18       	icall	r8
800041f2:	c0 38       	rjmp	800041f8 <__call_exitprocs+0x88>
800041f4:	16 9c       	mov	r12,r11
800041f6:	5d 18       	icall	r8
800041f8:	6e 18       	ld.w	r8,r7[0x4]
800041fa:	10 30       	cp.w	r0,r8
800041fc:	cc 41       	brne	80004184 <__call_exitprocs+0x14>
800041fe:	68 08       	ld.w	r8,r4[0x0]
80004200:	0e 38       	cp.w	r8,r7
80004202:	cc 11       	brne	80004184 <__call_exitprocs+0x14>
80004204:	20 15       	sub	r5,1
80004206:	20 43       	sub	r3,4
80004208:	20 42       	sub	r2,4
8000420a:	58 05       	cp.w	r5,0
8000420c:	cc b4       	brge	800041a2 <__call_exitprocs+0x32>
8000420e:	6e 18       	ld.w	r8,r7[0x4]
80004210:	58 08       	cp.w	r8,0
80004212:	c0 f1       	brne	80004230 <__call_exitprocs+0xc0>
80004214:	6e 08       	ld.w	r8,r7[0x0]
80004216:	58 08       	cp.w	r8,0
80004218:	c0 c0       	breq	80004230 <__call_exitprocs+0xc0>
8000421a:	89 08       	st.w	r4[0x0],r8
8000421c:	58 06       	cp.w	r6,0
8000421e:	c0 40       	breq	80004226 <__call_exitprocs+0xb6>
80004220:	0c 9c       	mov	r12,r6
80004222:	fe b0 fc 51 	rcall	80003ac4 <free>
80004226:	0e 9c       	mov	r12,r7
80004228:	fe b0 fc 4e 	rcall	80003ac4 <free>
8000422c:	68 07       	ld.w	r7,r4[0x0]
8000422e:	c0 38       	rjmp	80004234 <__call_exitprocs+0xc4>
80004230:	0e 94       	mov	r4,r7
80004232:	6e 07       	ld.w	r7,r7[0x0]
80004234:	58 07       	cp.w	r7,0
80004236:	ca b1       	brne	8000418c <__call_exitprocs+0x1c>
80004238:	2f dd       	sub	sp,-12
8000423a:	d8 32       	popm	r0-r7,pc

8000423c <__errno>:
8000423c:	e0 68 01 18 	mov	r8,280
80004240:	70 0c       	ld.w	r12,r8[0x0]
80004242:	2f 4c       	sub	r12,-12
80004244:	5e fc       	retal	r12
80004246:	d7 03       	nop

80004248 <_malloc_trim_r>:
80004248:	d4 21       	pushm	r4-r7,lr
8000424a:	16 95       	mov	r5,r11
8000424c:	18 97       	mov	r7,r12
8000424e:	fe b0 f5 9d 	rcall	80002d88 <__malloc_lock>
80004252:	e0 64 01 1c 	mov	r4,284
80004256:	68 28       	ld.w	r8,r4[0x8]
80004258:	70 16       	ld.w	r6,r8[0x4]
8000425a:	e0 16 ff fc 	andl	r6,0xfffc
8000425e:	ec c8 ff 91 	sub	r8,r6,-111
80004262:	f0 05 01 05 	sub	r5,r8,r5
80004266:	e0 15 ff 80 	andl	r5,0xff80
8000426a:	ea c5 00 80 	sub	r5,r5,128
8000426e:	e0 45 00 7f 	cp.w	r5,127
80004272:	e0 8a 00 22 	brle	800042b6 <_malloc_trim_r+0x6e>
80004276:	30 0b       	mov	r11,0
80004278:	0e 9c       	mov	r12,r7
8000427a:	cf 3e       	rcall	80004060 <_sbrk_r>
8000427c:	68 28       	ld.w	r8,r4[0x8]
8000427e:	0c 08       	add	r8,r6
80004280:	10 3c       	cp.w	r12,r8
80004282:	c1 a1       	brne	800042b6 <_malloc_trim_r+0x6e>
80004284:	ea 0b 11 00 	rsub	r11,r5,0
80004288:	0e 9c       	mov	r12,r7
8000428a:	ce be       	rcall	80004060 <_sbrk_r>
8000428c:	5b fc       	cp.w	r12,-1
8000428e:	c1 81       	brne	800042be <_malloc_trim_r+0x76>
80004290:	30 0b       	mov	r11,0
80004292:	0e 9c       	mov	r12,r7
80004294:	ce 6e       	rcall	80004060 <_sbrk_r>
80004296:	68 28       	ld.w	r8,r4[0x8]
80004298:	f8 08 01 09 	sub	r9,r12,r8
8000429c:	58 f9       	cp.w	r9,15
8000429e:	e0 8a 00 0c 	brle	800042b6 <_malloc_trim_r+0x6e>
800042a2:	a1 a9       	sbr	r9,0x0
800042a4:	91 19       	st.w	r8[0x4],r9
800042a6:	e0 68 05 28 	mov	r8,1320
800042aa:	70 09       	ld.w	r9,r8[0x0]
800042ac:	e0 68 07 5c 	mov	r8,1884
800042b0:	f8 09 01 09 	sub	r9,r12,r9
800042b4:	91 09       	st.w	r8[0x0],r9
800042b6:	0e 9c       	mov	r12,r7
800042b8:	fe b0 f5 6e 	rcall	80002d94 <__malloc_unlock>
800042bc:	d8 2a       	popm	r4-r7,pc,r12=0
800042be:	68 28       	ld.w	r8,r4[0x8]
800042c0:	0a 16       	sub	r6,r5
800042c2:	a1 a6       	sbr	r6,0x0
800042c4:	91 16       	st.w	r8[0x4],r6
800042c6:	e0 68 07 5c 	mov	r8,1884
800042ca:	70 09       	ld.w	r9,r8[0x0]
800042cc:	0a 19       	sub	r9,r5
800042ce:	0e 9c       	mov	r12,r7
800042d0:	91 09       	st.w	r8[0x0],r9
800042d2:	fe b0 f5 61 	rcall	80002d94 <__malloc_unlock>
800042d6:	da 2a       	popm	r4-r7,pc,r12=1

800042d8 <_free_r>:
800042d8:	d4 21       	pushm	r4-r7,lr
800042da:	16 96       	mov	r6,r11
800042dc:	18 97       	mov	r7,r12
800042de:	58 0b       	cp.w	r11,0
800042e0:	e0 80 00 c0 	breq	80004460 <_free_r+0x188>
800042e4:	fe b0 f5 52 	rcall	80002d88 <__malloc_lock>
800042e8:	20 86       	sub	r6,8
800042ea:	e0 6a 01 1c 	mov	r10,284
800042ee:	6c 18       	ld.w	r8,r6[0x4]
800042f0:	74 2e       	ld.w	lr,r10[0x8]
800042f2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800042f6:	a1 c8       	cbr	r8,0x0
800042f8:	ec 08 00 09 	add	r9,r6,r8
800042fc:	72 1b       	ld.w	r11,r9[0x4]
800042fe:	e0 1b ff fc 	andl	r11,0xfffc
80004302:	1c 39       	cp.w	r9,lr
80004304:	c1 e1       	brne	80004340 <_free_r+0x68>
80004306:	f6 08 00 08 	add	r8,r11,r8
8000430a:	58 0c       	cp.w	r12,0
8000430c:	c0 81       	brne	8000431c <_free_r+0x44>
8000430e:	6c 09       	ld.w	r9,r6[0x0]
80004310:	12 16       	sub	r6,r9
80004312:	12 08       	add	r8,r9
80004314:	6c 3b       	ld.w	r11,r6[0xc]
80004316:	6c 29       	ld.w	r9,r6[0x8]
80004318:	97 29       	st.w	r11[0x8],r9
8000431a:	93 3b       	st.w	r9[0xc],r11
8000431c:	10 99       	mov	r9,r8
8000431e:	95 26       	st.w	r10[0x8],r6
80004320:	a1 a9       	sbr	r9,0x0
80004322:	8d 19       	st.w	r6[0x4],r9
80004324:	e0 69 05 24 	mov	r9,1316
80004328:	72 09       	ld.w	r9,r9[0x0]
8000432a:	12 38       	cp.w	r8,r9
8000432c:	c0 63       	brcs	80004338 <_free_r+0x60>
8000432e:	e0 68 07 58 	mov	r8,1880
80004332:	0e 9c       	mov	r12,r7
80004334:	70 0b       	ld.w	r11,r8[0x0]
80004336:	c8 9f       	rcall	80004248 <_malloc_trim_r>
80004338:	0e 9c       	mov	r12,r7
8000433a:	fe b0 f5 2d 	rcall	80002d94 <__malloc_unlock>
8000433e:	d8 22       	popm	r4-r7,pc
80004340:	93 1b       	st.w	r9[0x4],r11
80004342:	58 0c       	cp.w	r12,0
80004344:	c0 30       	breq	8000434a <_free_r+0x72>
80004346:	30 0c       	mov	r12,0
80004348:	c1 08       	rjmp	80004368 <_free_r+0x90>
8000434a:	6c 0e       	ld.w	lr,r6[0x0]
8000434c:	f4 c5 ff f8 	sub	r5,r10,-8
80004350:	1c 16       	sub	r6,lr
80004352:	1c 08       	add	r8,lr
80004354:	6c 2e       	ld.w	lr,r6[0x8]
80004356:	0a 3e       	cp.w	lr,r5
80004358:	f9 bc 00 01 	moveq	r12,1
8000435c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80004360:	eb fe 1a 02 	st.wne	r5[0x8],lr
80004364:	fd f5 1a 03 	st.wne	lr[0xc],r5
80004368:	f2 0b 00 0e 	add	lr,r9,r11
8000436c:	7c 1e       	ld.w	lr,lr[0x4]
8000436e:	ed be 00 00 	bld	lr,0x0
80004372:	c1 40       	breq	8000439a <_free_r+0xc2>
80004374:	16 08       	add	r8,r11
80004376:	58 0c       	cp.w	r12,0
80004378:	c0 d1       	brne	80004392 <_free_r+0xba>
8000437a:	e0 6e 01 1c 	mov	lr,284
8000437e:	72 2b       	ld.w	r11,r9[0x8]
80004380:	2f 8e       	sub	lr,-8
80004382:	1c 3b       	cp.w	r11,lr
80004384:	c0 71       	brne	80004392 <_free_r+0xba>
80004386:	97 36       	st.w	r11[0xc],r6
80004388:	97 26       	st.w	r11[0x8],r6
8000438a:	8d 2b       	st.w	r6[0x8],r11
8000438c:	8d 3b       	st.w	r6[0xc],r11
8000438e:	30 1c       	mov	r12,1
80004390:	c0 58       	rjmp	8000439a <_free_r+0xc2>
80004392:	72 2b       	ld.w	r11,r9[0x8]
80004394:	72 39       	ld.w	r9,r9[0xc]
80004396:	93 2b       	st.w	r9[0x8],r11
80004398:	97 39       	st.w	r11[0xc],r9
8000439a:	10 99       	mov	r9,r8
8000439c:	ec 08 09 08 	st.w	r6[r8],r8
800043a0:	a1 a9       	sbr	r9,0x0
800043a2:	8d 19       	st.w	r6[0x4],r9
800043a4:	58 0c       	cp.w	r12,0
800043a6:	c5 a1       	brne	8000445a <_free_r+0x182>
800043a8:	e0 48 01 ff 	cp.w	r8,511
800043ac:	e0 8b 00 13 	brhi	800043d2 <_free_r+0xfa>
800043b0:	a3 98       	lsr	r8,0x3
800043b2:	f4 08 00 39 	add	r9,r10,r8<<0x3
800043b6:	72 2b       	ld.w	r11,r9[0x8]
800043b8:	8d 39       	st.w	r6[0xc],r9
800043ba:	8d 2b       	st.w	r6[0x8],r11
800043bc:	97 36       	st.w	r11[0xc],r6
800043be:	93 26       	st.w	r9[0x8],r6
800043c0:	a3 48       	asr	r8,0x2
800043c2:	74 19       	ld.w	r9,r10[0x4]
800043c4:	30 1b       	mov	r11,1
800043c6:	f6 08 09 48 	lsl	r8,r11,r8
800043ca:	f3 e8 10 08 	or	r8,r9,r8
800043ce:	95 18       	st.w	r10[0x4],r8
800043d0:	c4 58       	rjmp	8000445a <_free_r+0x182>
800043d2:	f0 0b 16 09 	lsr	r11,r8,0x9
800043d6:	58 4b       	cp.w	r11,4
800043d8:	e0 8b 00 06 	brhi	800043e4 <_free_r+0x10c>
800043dc:	f0 0b 16 06 	lsr	r11,r8,0x6
800043e0:	2c 8b       	sub	r11,-56
800043e2:	c2 08       	rjmp	80004422 <_free_r+0x14a>
800043e4:	59 4b       	cp.w	r11,20
800043e6:	e0 8b 00 04 	brhi	800043ee <_free_r+0x116>
800043ea:	2a 5b       	sub	r11,-91
800043ec:	c1 b8       	rjmp	80004422 <_free_r+0x14a>
800043ee:	e0 4b 00 54 	cp.w	r11,84
800043f2:	e0 8b 00 06 	brhi	800043fe <_free_r+0x126>
800043f6:	f0 0b 16 0c 	lsr	r11,r8,0xc
800043fa:	29 2b       	sub	r11,-110
800043fc:	c1 38       	rjmp	80004422 <_free_r+0x14a>
800043fe:	e0 4b 01 54 	cp.w	r11,340
80004402:	e0 8b 00 06 	brhi	8000440e <_free_r+0x136>
80004406:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000440a:	28 9b       	sub	r11,-119
8000440c:	c0 b8       	rjmp	80004422 <_free_r+0x14a>
8000440e:	e0 4b 05 54 	cp.w	r11,1364
80004412:	e0 88 00 05 	brls	8000441c <_free_r+0x144>
80004416:	37 eb       	mov	r11,126
80004418:	c0 58       	rjmp	80004422 <_free_r+0x14a>
8000441a:	d7 03       	nop
8000441c:	f0 0b 16 12 	lsr	r11,r8,0x12
80004420:	28 4b       	sub	r11,-124
80004422:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80004426:	78 29       	ld.w	r9,r12[0x8]
80004428:	18 39       	cp.w	r9,r12
8000442a:	c0 e1       	brne	80004446 <_free_r+0x16e>
8000442c:	74 18       	ld.w	r8,r10[0x4]
8000442e:	a3 4b       	asr	r11,0x2
80004430:	30 1c       	mov	r12,1
80004432:	f8 0b 09 4b 	lsl	r11,r12,r11
80004436:	f1 eb 10 0b 	or	r11,r8,r11
8000443a:	12 98       	mov	r8,r9
8000443c:	95 1b       	st.w	r10[0x4],r11
8000443e:	c0 a8       	rjmp	80004452 <_free_r+0x17a>
80004440:	72 29       	ld.w	r9,r9[0x8]
80004442:	18 39       	cp.w	r9,r12
80004444:	c0 60       	breq	80004450 <_free_r+0x178>
80004446:	72 1a       	ld.w	r10,r9[0x4]
80004448:	e0 1a ff fc 	andl	r10,0xfffc
8000444c:	14 38       	cp.w	r8,r10
8000444e:	cf 93       	brcs	80004440 <_free_r+0x168>
80004450:	72 38       	ld.w	r8,r9[0xc]
80004452:	8d 38       	st.w	r6[0xc],r8
80004454:	8d 29       	st.w	r6[0x8],r9
80004456:	93 36       	st.w	r9[0xc],r6
80004458:	91 26       	st.w	r8[0x8],r6
8000445a:	0e 9c       	mov	r12,r7
8000445c:	fe b0 f4 9c 	rcall	80002d94 <__malloc_unlock>
80004460:	d8 22       	popm	r4-r7,pc
80004462:	d7 03       	nop

80004464 <__do_global_ctors_aux>:
80004464:	d4 21       	pushm	r4-r7,lr
80004466:	30 c7       	mov	r7,12
80004468:	c0 28       	rjmp	8000446c <__do_global_ctors_aux+0x8>
8000446a:	5d 18       	icall	r8
8000446c:	20 47       	sub	r7,4
8000446e:	6e 08       	ld.w	r8,r7[0x0]
80004470:	5b f8       	cp.w	r8,-1
80004472:	cf c1       	brne	8000446a <__do_global_ctors_aux+0x6>
80004474:	d8 22       	popm	r4-r7,pc
80004476:	d7 03       	nop

Disassembly of section .exception:

80004600 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80004600:	c0 08       	rjmp	80004600 <_evba>
	...

80004604 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80004604:	c0 08       	rjmp	80004604 <_handle_TLB_Multiple_Hit>
	...

80004608 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80004608:	c0 08       	rjmp	80004608 <_handle_Bus_Error_Data_Fetch>
	...

8000460c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000460c:	c0 08       	rjmp	8000460c <_handle_Bus_Error_Instruction_Fetch>
	...

80004610 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80004610:	c0 08       	rjmp	80004610 <_handle_NMI>
	...

80004614 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80004614:	c0 08       	rjmp	80004614 <_handle_Instruction_Address>
	...

80004618 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80004618:	c0 08       	rjmp	80004618 <_handle_ITLB_Protection>
	...

8000461c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000461c:	c0 08       	rjmp	8000461c <_handle_Breakpoint>
	...

80004620 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80004620:	c0 08       	rjmp	80004620 <_handle_Illegal_Opcode>
	...

80004624 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80004624:	c0 08       	rjmp	80004624 <_handle_Unimplemented_Instruction>
	...

80004628 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80004628:	c0 08       	rjmp	80004628 <_handle_Privilege_Violation>
	...

8000462c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000462c:	c0 08       	rjmp	8000462c <_handle_Floating_Point>
	...

80004630 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80004630:	c0 08       	rjmp	80004630 <_handle_Coprocessor_Absent>
	...

80004634 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80004634:	c0 08       	rjmp	80004634 <_handle_Data_Address_Read>
	...

80004638 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80004638:	c0 08       	rjmp	80004638 <_handle_Data_Address_Write>
	...

8000463c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000463c:	c0 08       	rjmp	8000463c <_handle_DTLB_Protection_Read>
	...

80004640 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80004640:	c0 08       	rjmp	80004640 <_handle_DTLB_Protection_Write>
	...

80004644 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80004644:	c0 08       	rjmp	80004644 <_handle_DTLB_Modified>
	...

80004650 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80004650:	c0 08       	rjmp	80004650 <_handle_ITLB_Miss>
	...

80004660 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80004660:	c0 08       	rjmp	80004660 <_handle_DTLB_Miss_Read>
	...

80004670 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80004670:	c0 08       	rjmp	80004670 <_handle_DTLB_Miss_Write>
	...

80004700 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80004700:	fe cf 1a 30 	sub	pc,pc,6704

80004704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80004704:	30 0c       	mov	r12,0
80004706:	fe b0 f0 89 	rcall	80002818 <_get_interrupt_handler>
8000470a:	58 0c       	cp.w	r12,0
8000470c:	f8 0f 17 10 	movne	pc,r12
80004710:	d6 03       	rete

80004712 <_int1>:
80004712:	30 1c       	mov	r12,1
80004714:	fe b0 f0 82 	rcall	80002818 <_get_interrupt_handler>
80004718:	58 0c       	cp.w	r12,0
8000471a:	f8 0f 17 10 	movne	pc,r12
8000471e:	d6 03       	rete

80004720 <_int2>:
80004720:	30 2c       	mov	r12,2
80004722:	fe b0 f0 7b 	rcall	80002818 <_get_interrupt_handler>
80004726:	58 0c       	cp.w	r12,0
80004728:	f8 0f 17 10 	movne	pc,r12
8000472c:	d6 03       	rete

8000472e <_int3>:
8000472e:	30 3c       	mov	r12,3
80004730:	fe b0 f0 74 	rcall	80002818 <_get_interrupt_handler>
80004734:	58 0c       	cp.w	r12,0
80004736:	f8 0f 17 10 	movne	pc,r12
8000473a:	d6 03       	rete
8000473c:	d7 03       	nop
8000473e:	d7 03       	nop
80004740:	d7 03       	nop
80004742:	d7 03       	nop
80004744:	d7 03       	nop
80004746:	d7 03       	nop
80004748:	d7 03       	nop
8000474a:	d7 03       	nop
8000474c:	d7 03       	nop
8000474e:	d7 03       	nop
80004750:	d7 03       	nop
80004752:	d7 03       	nop
80004754:	d7 03       	nop
80004756:	d7 03       	nop
80004758:	d7 03       	nop
8000475a:	d7 03       	nop
8000475c:	d7 03       	nop
8000475e:	d7 03       	nop
80004760:	d7 03       	nop
80004762:	d7 03       	nop
80004764:	d7 03       	nop
80004766:	d7 03       	nop
80004768:	d7 03       	nop
8000476a:	d7 03       	nop
8000476c:	d7 03       	nop
8000476e:	d7 03       	nop
80004770:	d7 03       	nop
80004772:	d7 03       	nop
80004774:	d7 03       	nop
80004776:	d7 03       	nop
80004778:	d7 03       	nop
8000477a:	d7 03       	nop
8000477c:	d7 03       	nop
8000477e:	d7 03       	nop
80004780:	d7 03       	nop
80004782:	d7 03       	nop
80004784:	d7 03       	nop
80004786:	d7 03       	nop
80004788:	d7 03       	nop
8000478a:	d7 03       	nop
8000478c:	d7 03       	nop
8000478e:	d7 03       	nop
80004790:	d7 03       	nop
80004792:	d7 03       	nop
80004794:	d7 03       	nop
80004796:	d7 03       	nop
80004798:	d7 03       	nop
8000479a:	d7 03       	nop
8000479c:	d7 03       	nop
8000479e:	d7 03       	nop
800047a0:	d7 03       	nop
800047a2:	d7 03       	nop
800047a4:	d7 03       	nop
800047a6:	d7 03       	nop
800047a8:	d7 03       	nop
800047aa:	d7 03       	nop
800047ac:	d7 03       	nop
800047ae:	d7 03       	nop
800047b0:	d7 03       	nop
800047b2:	d7 03       	nop
800047b4:	d7 03       	nop
800047b6:	d7 03       	nop
800047b8:	d7 03       	nop
800047ba:	d7 03       	nop
800047bc:	d7 03       	nop
800047be:	d7 03       	nop
800047c0:	d7 03       	nop
800047c2:	d7 03       	nop
800047c4:	d7 03       	nop
800047c6:	d7 03       	nop
800047c8:	d7 03       	nop
800047ca:	d7 03       	nop
800047cc:	d7 03       	nop
800047ce:	d7 03       	nop
800047d0:	d7 03       	nop
800047d2:	d7 03       	nop
800047d4:	d7 03       	nop
800047d6:	d7 03       	nop
800047d8:	d7 03       	nop
800047da:	d7 03       	nop
800047dc:	d7 03       	nop
800047de:	d7 03       	nop
800047e0:	d7 03       	nop
800047e2:	d7 03       	nop
800047e4:	d7 03       	nop
800047e6:	d7 03       	nop
800047e8:	d7 03       	nop
800047ea:	d7 03       	nop
800047ec:	d7 03       	nop
800047ee:	d7 03       	nop
800047f0:	d7 03       	nop
800047f2:	d7 03       	nop
800047f4:	d7 03       	nop
800047f6:	d7 03       	nop
800047f8:	d7 03       	nop
800047fa:	d7 03       	nop
800047fc:	d7 03       	nop
800047fe:	d7 03       	nop

Disassembly of section .fini:

80004800 <_fini>:
80004800:	eb cd 40 40 	pushm	r6,lr
80004804:	48 26       	lddpc	r6,8000480c <_fini+0xc>
80004806:	1e 26       	rsub	r6,pc
80004808:	c0 48       	rjmp	80004810 <_fini+0x10>
8000480a:	d7 03       	nop
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	47 ea       	lddsp	r10,sp[0x1f8]
80004810:	fe b0 ec 3c 	rcall	80002088 <__do_global_dtors_aux>
80004814:	e3 cd 80 40 	ldm	sp++,r6,pc
