
DEMO_EVK1100_EXAMPLE1.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00002380  80002028  80002028  00002428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80004400  80004400  00004800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80004600  80004600  00004a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       0000018c  80004618  80004618  00004a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .lalign       00000004  800047a4  800047a4  00004ba4  2**0
                  ALLOC
  8 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  9 .ctors        00000008  00000008  800047a8  00004c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  00000010  800047b0  00004c10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .jcr          00000004  00000018  800047b8  00004c18  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .got          00000000  0000001c  800047bc  00004c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .data         00000510  0000001c  800047bc  00004c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          00000254  00000544  00000544  00000000  2**2
                  ALLOC
 15 .heap         0000e868  00000798  00000798  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  0000512c  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 000009f8  00000000  00000000  00005160  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 00001540  00000000  00000000  00005b58  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00011029  00000000  00000000  00007098  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00002dbb  00000000  00000000  000180c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   00009778  00000000  00000000  0001ae7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  0000170c  00000000  00000000  000245f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00003640  00000000  00000000  00025d00  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    000036fa  00000000  00000000  00029340  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 00b51e18  00000000  00000000  0002ca3a  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000ae0  00000000  00000000  00b7e852  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	20 28       	sub	r8,2

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

8000200c <_init>:
8000200c:	eb cd 40 40 	pushm	r6,lr
80002010:	48 26       	lddpc	r6,80002018 <_init+0xc>
80002012:	1e 26       	rsub	r6,pc
80002014:	c0 48       	rjmp	8000201c <_init+0x10>
80002016:	d7 03       	nop
80002018:	80 00       	ld.sh	r0,r0[0x0]
8000201a:	1f f6       	ld.ub	r6,pc[0x7]
8000201c:	c5 4c       	rcall	800020c4 <frame_dummy>
8000201e:	e0 a0 11 bb 	rcall	80004394 <__do_global_ctors_aux>
80002022:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002028 <_stext>:
80002028:	30 07       	mov	r7,0
8000202a:	e0 7a 00 00 	mov	r10,65536
8000202e:	5b fa       	cp.w	r10,-1
80002030:	f4 0d 17 10 	movne	sp,r10
80002034:	fe cb d8 8c 	sub	r11,pc,-10100
80002038:	30 8c       	mov	r12,8
8000203a:	18 3b       	cp.w	r11,r12
8000203c:	c0 70       	breq	8000204a <_stext+0x22>
8000203e:	e0 6a 05 30 	mov	r10,1328
80002042:	b7 09       	ld.d	r8,r11++
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf d5       	brlt	80002042 <_stext+0x1a>
8000204a:	e0 6a 07 98 	mov	r10,1944
8000204e:	e0 6c 05 30 	mov	r12,1328
80002052:	30 08       	mov	r8,0
80002054:	30 09       	mov	r9,0
80002056:	b9 28       	st.d	r12++,r8
80002058:	14 3c       	cp.w	r12,r10
8000205a:	cf e5       	brlt	80002056 <_stext+0x2e>
8000205c:	e0 a0 06 74 	rcall	80002d44 <_init_startup>
80002060:	fe cc da 60 	sub	r12,pc,-9632
80002064:	e0 a0 0c b0 	rcall	800039c4 <atexit>
80002068:	cd 2f       	rcall	8000200c <_init>
8000206a:	1a 9c       	mov	r12,sp
8000206c:	30 0b       	mov	r11,0
8000206e:	e0 a0 0f a1 	rcall	80003fb0 <_init_argv>
80002072:	5b fc       	cp.w	r12,-1
80002074:	f9 bc 00 00 	moveq	r12,0
80002078:	f9 ba 00 00 	moveq	r10,0
8000207c:	14 1d       	sub	sp,r10
8000207e:	e0 a0 0b 11 	rcall	800036a0 <main>
80002082:	e0 a0 0c a9 	rcall	800039d4 <exit>
80002086:	d7 03       	nop

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	e0 68 05 44 	mov	r8,1348
8000208e:	11 89       	ld.ub	r9,r8[0x0]
80002090:	30 08       	mov	r8,0
80002092:	f0 09 18 00 	cp.b	r9,r8
80002096:	c1 61       	brne	800020c2 <__do_global_dtors_aux+0x3a>
80002098:	31 08       	mov	r8,16
8000209a:	31 46       	mov	r6,20
8000209c:	10 95       	mov	r5,r8
8000209e:	10 16       	sub	r6,r8
800020a0:	e0 67 05 48 	mov	r7,1352
800020a4:	a3 46       	asr	r6,0x2
800020a6:	20 16       	sub	r6,1
800020a8:	c0 68       	rjmp	800020b4 <__do_global_dtors_aux+0x2c>
800020aa:	2f f8       	sub	r8,-1
800020ac:	8f 08       	st.w	r7[0x0],r8
800020ae:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020b2:	5d 18       	icall	r8
800020b4:	6e 08       	ld.w	r8,r7[0x0]
800020b6:	0c 38       	cp.w	r8,r6
800020b8:	cf 93       	brcs	800020aa <__do_global_dtors_aux+0x22>
800020ba:	30 19       	mov	r9,1
800020bc:	e0 68 05 44 	mov	r8,1348
800020c0:	b0 89       	st.b	r8[0x0],r9
800020c2:	d8 22       	popm	r4-r7,pc

800020c4 <frame_dummy>:
800020c4:	d4 01       	pushm	lr
800020c6:	31 8c       	mov	r12,24
800020c8:	78 08       	ld.w	r8,r12[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 50       	breq	800020d6 <frame_dummy+0x12>
800020ce:	48 38       	lddpc	r8,800020d8 <frame_dummy+0x14>
800020d0:	58 08       	cp.w	r8,0
800020d2:	c0 20       	breq	800020d6 <frame_dummy+0x12>
800020d4:	5d 18       	icall	r8
800020d6:	d8 02       	popm	pc
800020d8:	00 00       	add	r0,r0
	...

800020dc <dip204_select>:

/*! \brief function to select the LCD
 *
 */
static void dip204_select(void)
{
800020dc:	d4 01       	pushm	lr
  spi_selectChip(DIP204_SPI, DIP204_SPI_NPCS);
800020de:	30 2b       	mov	r11,2
800020e0:	fe 7c 28 00 	mov	r12,-55296
800020e4:	f0 1f 00 02 	mcall	800020ec <dip204_select+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	2b 60       	sub	r0,-74

800020f0 <dip204_write_byte>:
 *
 *  \param  byte  Input. byte to write to the LCD (D7 .. D0)
 *
 */
static void dip204_write_byte(unsigned char byte)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
  unsigned char reverse;

  switch (byte)
800020f4:	f8 c8 ff f8 	sub	r8,r12,-8
800020f8:	30 69       	mov	r9,6
800020fa:	f2 08 18 00 	cp.b	r8,r9
800020fe:	e0 8b 00 0f 	brhi	8000211c <dip204_write_byte+0x2c>
80002102:	30 19       	mov	r9,1
80002104:	f2 08 09 48 	lsl	r8,r9,r8
80002108:	e2 18 00 55 	andl	r8,0x55,COH
8000210c:	c0 80       	breq	8000211c <dip204_write_byte+0x2c>
    {
      /* send D7 to D0 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, byte);
8000210e:	18 9b       	mov	r11,r12
80002110:	fe 7c 28 00 	mov	r12,-55296
80002114:	f0 1f 00 0c 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      break;
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
    }
    /* LSB first for all other data */
    default:
    {
      /* reverse byte */
      reverse = bit_reverse8(byte);
8000211c:	5c 9c       	brev	r12
      /* send D0 to D3 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, (reverse & 0xF0));
8000211e:	f8 07 16 18 	lsr	r7,r12,0x18
80002122:	0e 9b       	mov	r11,r7
80002124:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002128:	fe 7c 28 00 	mov	r12,-55296
8000212c:	f0 1f 00 06 	mcall	80002144 <dip204_write_byte+0x54>
      Assert( SPI_OK==spi_status );
      /* send D4 to D7 */
#ifdef _ASSERT_ENABLE_
      spi_status =
#endif
      spi_write(DIP204_SPI, ((reverse << 4) & 0xF0));
80002130:	ee 0b 15 04 	lsl	r11,r7,0x4
80002134:	e2 1b 00 f0 	andl	r11,0xf0,COH
80002138:	fe 7c 28 00 	mov	r12,-55296
8000213c:	f0 1f 00 02 	mcall	80002144 <dip204_write_byte+0x54>
80002140:	e3 cd 80 80 	ldm	sp++,r7,pc
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	29 fc       	sub	r12,-97

80002148 <dip204_read_byte>:
 *
 *  \param  byte  Input. byte read from the LCD (D7 .. D0)
 *
 */
static void dip204_read_byte(unsigned char *byte)
{
80002148:	eb cd 40 c0 	pushm	r6-r7,lr
8000214c:	20 1d       	sub	sp,4
8000214e:	18 96       	mov	r6,r12
  unsigned short reverse = 0x00;
80002150:	fa c7 ff fc 	sub	r7,sp,-4
80002154:	30 08       	mov	r8,0
80002156:	0e e8       	st.h	--r7,r8

  /* dummy write */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_write(DIP204_SPI, 0x00);
80002158:	30 0b       	mov	r11,0
8000215a:	fe 7c 28 00 	mov	r12,-55296
8000215e:	f0 1f 00 08 	mcall	8000217c <dip204_read_byte+0x34>
  Assert( SPI_OK==spi_status );
  /* read RSR register */
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_read(DIP204_SPI, &reverse);
80002162:	0e 9b       	mov	r11,r7
80002164:	fe 7c 28 00 	mov	r12,-55296
80002168:	f0 1f 00 06 	mcall	80002180 <dip204_read_byte+0x38>
  Assert( SPI_OK==spi_status );
  /* Revert received byte (issued LSB first by the LCD) */
  *byte = bit_reverse8(reverse);
8000216c:	1b b8       	ld.ub	r8,sp[0x3]
8000216e:	5c 98       	brev	r8
80002170:	b9 88       	lsr	r8,0x18
80002172:	ac 88       	st.b	r6[0x0],r8
}
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	29 fc       	sub	r12,-97
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	2a 18       	sub	r8,-95

80002184 <dip204_wait_busy>:

/*! \brief function to wait for LCD becomes not busy
 *
 */
static void dip204_wait_busy(void)
{
80002184:	eb cd 40 c0 	pushm	r6-r7,lr
80002188:	20 1d       	sub	sp,4
  unsigned char status = 0x00;
8000218a:	fa c7 ff fc 	sub	r7,sp,-4
8000218e:	30 08       	mov	r8,0
80002190:	0e f8       	st.b	--r7,r8

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
80002192:	e0 6c 00 fc 	mov	r12,252
80002196:	f0 1f 00 07 	mcall	800021b0 <dip204_wait_busy+0x2c>
  /* read next byte */
  do {
  dip204_read_byte(&status);
  /* keep D7 to know status */
  }while (status & 0x80);
8000219a:	30 06       	mov	r6,0

  /* send read command to LCD */
  dip204_write_byte(DIP204_READ_COMMAND);
  /* read next byte */
  do {
  dip204_read_byte(&status);
8000219c:	0e 9c       	mov	r12,r7
8000219e:	f0 1f 00 06 	mcall	800021b4 <dip204_wait_busy+0x30>
  /* keep D7 to know status */
  }while (status & 0x80);
800021a2:	1b b8       	ld.ub	r8,sp[0x3]
800021a4:	ec 08 18 00 	cp.b	r8,r6
800021a8:	cf a5       	brlt	8000219c <dip204_wait_busy+0x18>
}
800021aa:	2f fd       	sub	sp,-4
800021ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	20 f0       	sub	r0,15
800021b4:	80 00       	ld.sh	r0,r0[0x0]
800021b6:	21 48       	sub	r8,20

800021b8 <dip204_unselect>:

/*! \brief function to unselect the LCD
 *
 */
static void dip204_unselect(void)
{
800021b8:	d4 01       	pushm	lr
#ifdef _ASSERT_ENABLE_
  spi_status =
#endif
  spi_unselectChip(DIP204_SPI, DIP204_SPI_NPCS);
800021ba:	30 2b       	mov	r11,2
800021bc:	fe 7c 28 00 	mov	r12,-55296
800021c0:	f0 1f 00 02 	mcall	800021c8 <dip204_unselect+0x10>
  Assert( SPI_OK==spi_status );
}
800021c4:	d8 02       	popm	pc
800021c6:	00 00       	add	r0,r0
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	2b 20       	sub	r0,-78

800021cc <dip204_write_string>:
  dip204_unselect();
}


void dip204_write_string(const char *string)
{
800021cc:	eb cd 40 f8 	pushm	r3-r7,lr
800021d0:	18 94       	mov	r4,r12
  unsigned char i=0;

  dip204_select();
800021d2:	f0 1f 00 11 	mcall	80002214 <dip204_write_string+0x48>
  /* for all chars in string */
  while(string[i]!=0)
800021d6:	09 89       	ld.ub	r9,r4[0x0]
800021d8:	30 08       	mov	r8,0
800021da:	f0 09 18 00 	cp.b	r9,r8
800021de:	c1 60       	breq	8000220a <dip204_write_string+0x3e>
800021e0:	08 96       	mov	r6,r4
800021e2:	30 07       	mov	r7,0
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021e4:	e0 63 00 fa 	mov	r3,250
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021e8:	10 95       	mov	r5,r8
  {
    /* Send Write Data Start Byte */
    dip204_write_byte(DIP204_WRITE_DATA);
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 0b 	mcall	80002218 <dip204_write_string+0x4c>
    /* Send byte */
    dip204_write_byte(string[i]);
800021f0:	0d 8c       	ld.ub	r12,r6[0x0]
800021f2:	f0 1f 00 0a 	mcall	80002218 <dip204_write_string+0x4c>
    /* go to next char */
    i++;
800021f6:	2f f7       	sub	r7,-1
800021f8:	5c 57       	castu.b	r7
    dip204_wait_busy();
800021fa:	f0 1f 00 09 	mcall	8000221c <dip204_write_string+0x50>
{
  unsigned char i=0;

  dip204_select();
  /* for all chars in string */
  while(string[i]!=0)
800021fe:	e8 07 00 06 	add	r6,r4,r7
80002202:	0d 88       	ld.ub	r8,r6[0x0]
80002204:	ea 08 18 00 	cp.b	r8,r5
80002208:	cf 11       	brne	800021ea <dip204_write_string+0x1e>
    dip204_write_byte(string[i]);
    /* go to next char */
    i++;
    dip204_wait_busy();
  }
  dip204_unselect();
8000220a:	f0 1f 00 06 	mcall	80002220 <dip204_write_string+0x54>
}
8000220e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002212:	00 00       	add	r0,r0
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	20 dc       	sub	r12,13
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	20 f0       	sub	r0,15
8000221c:	80 00       	ld.sh	r0,r0[0x0]
8000221e:	21 84       	sub	r4,24
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	21 b8       	sub	r8,27

80002224 <dip204_set_cursor_position>:
  dip204_set_cursor_position(column, line);
}


void dip204_set_cursor_position(unsigned char column, unsigned char line)
{
80002224:	eb cd 40 c0 	pushm	r6-r7,lr
80002228:	18 96       	mov	r6,r12
8000222a:	16 97       	mov	r7,r11
  unsigned char address = 0;

  dip204_select();
8000222c:	f0 1f 00 11 	mcall	80002270 <dip204_set_cursor_position+0x4c>
  if ((column <= 20) && (line <= 4))
80002230:	31 48       	mov	r8,20
80002232:	f0 06 18 00 	cp.b	r6,r8
80002236:	5f 89       	srls	r9
80002238:	30 48       	mov	r8,4
8000223a:	f0 07 18 00 	cp.b	r7,r8
8000223e:	5f 88       	srls	r8
80002240:	f3 e8 00 08 	and	r8,r9,r8
80002244:	c0 31       	brne	8000224a <dip204_set_cursor_position+0x26>
80002246:	30 06       	mov	r6,0
80002248:	c0 68       	rjmp	80002254 <dip204_set_cursor_position+0x30>
  {
    /* Calculate DDRAM address from line and row values */
    address = ( (line-1) * 32 ) + ( column-1 ) + 128;
8000224a:	28 16       	sub	r6,-127
8000224c:	20 17       	sub	r7,1
8000224e:	a5 77       	lsl	r7,0x5
80002250:	0e 06       	add	r6,r7
80002252:	5c 56       	castu.b	r6
  }
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
80002254:	e0 6c 00 f8 	mov	r12,248
80002258:	f0 1f 00 07 	mcall	80002274 <dip204_set_cursor_position+0x50>
  /* Send Address lower Nibble */
  dip204_write_byte(address);
8000225c:	0c 9c       	mov	r12,r6
8000225e:	f0 1f 00 06 	mcall	80002274 <dip204_set_cursor_position+0x50>
  dip204_wait_busy();
80002262:	f0 1f 00 06 	mcall	80002278 <dip204_set_cursor_position+0x54>
  dip204_unselect();
80002266:	f0 1f 00 06 	mcall	8000227c <dip204_set_cursor_position+0x58>
}
8000226a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000226e:	00 00       	add	r0,r0
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	20 dc       	sub	r12,13
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	20 f0       	sub	r0,15
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	21 84       	sub	r4,24
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	21 b8       	sub	r8,27

80002280 <dip204_write_data>:
  dip204_unselect();
}


void dip204_write_data(unsigned char data)
{
80002280:	eb cd 40 80 	pushm	r7,lr
80002284:	18 97       	mov	r7,r12
  dip204_select();
80002286:	f0 1f 00 08 	mcall	800022a4 <dip204_write_data+0x24>
  /* Send Write Data Start-Byte */
  dip204_write_byte(DIP204_WRITE_DATA);
8000228a:	e0 6c 00 fa 	mov	r12,250
8000228e:	f0 1f 00 07 	mcall	800022a8 <dip204_write_data+0x28>
  /* send data */
  dip204_write_byte(data);
80002292:	0e 9c       	mov	r12,r7
80002294:	f0 1f 00 05 	mcall	800022a8 <dip204_write_data+0x28>
  dip204_wait_busy();
80002298:	f0 1f 00 05 	mcall	800022ac <dip204_write_data+0x2c>
  dip204_unselect();
8000229c:	f0 1f 00 05 	mcall	800022b0 <dip204_write_data+0x30>
}
800022a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	20 dc       	sub	r12,13
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	20 f0       	sub	r0,15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	21 84       	sub	r4,24
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	21 b8       	sub	r8,27

800022b4 <dip204_hide_cursor>:
  dip204_unselect();
}


void dip204_hide_cursor(void)
{
800022b4:	d4 01       	pushm	lr
  /* select the LCD chip */
  dip204_select();
800022b6:	f0 1f 00 08 	mcall	800022d4 <dip204_hide_cursor+0x20>
  /* Send Command Start Byte */
  dip204_write_byte(DIP204_WRITE_COMMAND);
800022ba:	e0 6c 00 f8 	mov	r12,248
800022be:	f0 1f 00 07 	mcall	800022d8 <dip204_hide_cursor+0x24>
  /* Send "Display On Command: Display On, Cursor On, Blink On" */
  dip204_write_byte(0x0C);
800022c2:	30 cc       	mov	r12,12
800022c4:	f0 1f 00 05 	mcall	800022d8 <dip204_hide_cursor+0x24>
  dip204_wait_busy();
800022c8:	f0 1f 00 05 	mcall	800022dc <dip204_hide_cursor+0x28>
  /* unselect chip */
  dip204_unselect();
800022cc:	f0 1f 00 05 	mcall	800022e0 <dip204_hide_cursor+0x2c>
}
800022d0:	d8 02       	popm	pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	20 dc       	sub	r12,13
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	20 f0       	sub	r0,15
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	21 84       	sub	r4,24
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	21 b8       	sub	r8,27

800022e4 <dip204_set_backlight>:
  dip204_unselect();
}


void dip204_set_backlight(backlight_power power)
{
800022e4:	d4 01       	pushm	lr
  if (channel_id != -1)
800022e6:	49 d8       	lddpc	r8,80002358 <dip204_set_backlight+0x74>
800022e8:	70 08       	ld.w	r8,r8[0x0]
800022ea:	5b f8       	cp.w	r8,-1
800022ec:	c2 a0       	breq	80002340 <dip204_set_backlight+0x5c>
  {
    if (power == backlight_power_decrease)
800022ee:	58 1c       	cp.w	r12,1
800022f0:	c1 41       	brne	80002318 <dip204_set_backlight+0x34>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Max(pwm_duty - (DIP204_PERIOD_MAX / 10), 1);
800022f2:	49 ba       	lddpc	r10,8000235c <dip204_set_backlight+0x78>
800022f4:	94 89       	ld.uh	r9,r10[0x0]
800022f6:	20 59       	sub	r9,5
800022f8:	30 1b       	mov	r11,1
800022fa:	f2 0b 0c 49 	max	r9,r9,r11
800022fe:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
80002300:	49 8b       	lddpc	r11,80002360 <dip204_set_backlight+0x7c>
80002302:	76 0a       	ld.w	r10,r11[0x0]
80002304:	30 0c       	mov	r12,0
80002306:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
8000230a:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
8000230c:	5c 79       	castu.h	r9
8000230e:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
80002310:	10 9c       	mov	r12,r8
80002312:	f0 1f 00 15 	mcall	80002364 <dip204_set_backlight+0x80>
80002316:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
80002318:	58 0c       	cp.w	r12,0
8000231a:	c1 e1       	brne	80002356 <dip204_set_backlight+0x72>
    {
      // update channel duty cycle using double buffering to prevent unexpected waveform.
      pwm_duty = Min(pwm_duty + (DIP204_PERIOD_MAX / 10), DIP204_PERIOD_MAX - 1);
8000231c:	49 0a       	lddpc	r10,8000235c <dip204_set_backlight+0x78>
8000231e:	94 89       	ld.uh	r9,r10[0x0]
80002320:	2f b9       	sub	r9,-5
80002322:	33 1b       	mov	r11,49
80002324:	f2 0b 0d 49 	min	r9,r9,r11
80002328:	b4 09       	st.h	r10[0x0],r9
      pwm_channel.CMR.cpd = PWM_UPDATE_DUTY;
8000232a:	48 eb       	lddpc	r11,80002360 <dip204_set_backlight+0x7c>
8000232c:	76 0a       	ld.w	r10,r11[0x0]
8000232e:	f5 dc d1 41 	bfins	r10,r12,0xa,0x1
80002332:	97 0a       	st.w	r11[0x0],r10
      // new duty cycle
      pwm_channel.cupd = pwm_duty;
80002334:	5c 79       	castu.h	r9
80002336:	97 49       	st.w	r11[0x10],r9
      // set channel configuration.
      pwm_sync_update_channel(channel_id, &pwm_channel);
80002338:	10 9c       	mov	r12,r8
8000233a:	f0 1f 00 0b 	mcall	80002364 <dip204_set_backlight+0x80>
8000233e:	d8 02       	popm	pc
    }
  }
  else
  {
    if (power == backlight_power_decrease)
80002340:	58 1c       	cp.w	r12,1
80002342:	c0 51       	brne	8000234c <dip204_set_backlight+0x68>
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
80002344:	33 2c       	mov	r12,50
80002346:	f0 1f 00 09 	mcall	80002368 <dip204_set_backlight+0x84>
8000234a:	d8 02       	popm	pc
    }
    else if (power == backlight_power_increase)
8000234c:	58 0c       	cp.w	r12,0
8000234e:	c0 41       	brne	80002356 <dip204_set_backlight+0x72>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
80002350:	33 2c       	mov	r12,50
80002352:	f0 1f 00 07 	mcall	8000236c <dip204_set_backlight+0x88>
80002356:	d8 02       	popm	pc
80002358:	00 00       	add	r0,r0
8000235a:	00 1c       	sub	r12,r0
8000235c:	00 00       	add	r0,r0
8000235e:	05 6c       	ld.uh	r12,--r2
80002360:	00 00       	add	r0,r0
80002362:	05 4c       	ld.w	r12,--r2
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	28 f4       	sub	r4,-113
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	26 38       	sub	r8,99
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	26 54       	sub	r4,101

80002370 <dip204_init>:


/****************************** global functions *****************************/

void dip204_init(backlight_options option, bool backlight_on)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	20 4d       	sub	sp,16
80002376:	16 97       	mov	r7,r11
  pwm_opt_t pwm_opt;  // pwm option config

  if (option == backlight_PWM)
80002378:	58 1c       	cp.w	r12,1
8000237a:	c3 11       	brne	800023dc <dip204_init+0x6c>
  {
    channel_id = DIP204_PWM_CHANNEL;
8000237c:	30 69       	mov	r9,6
8000237e:	fe f8 02 02 	ld.w	r8,pc[514]
80002382:	91 09       	st.w	r8[0x0],r9
    gpio_enable_module_pin(DIP204_PWM_PIN, DIP204_PWM_FUNCTION);
80002384:	30 2b       	mov	r11,2
80002386:	33 2c       	mov	r12,50
80002388:	f0 1f 00 7f 	mcall	80002584 <dip204_init+0x214>

    // PWM controller configuration
    pwm_opt.diva=0;
8000238c:	30 08       	mov	r8,0
8000238e:	50 18       	stdsp	sp[0x4],r8
    pwm_opt.divb=0;
80002390:	50 08       	stdsp	sp[0x0],r8
    pwm_opt.prea=0;
80002392:	50 38       	stdsp	sp[0xc],r8
    pwm_opt.preb=0;
80002394:	50 28       	stdsp	sp[0x8],r8

    pwm_init(&pwm_opt);
80002396:	1a 9c       	mov	r12,sp
80002398:	f0 1f 00 7c 	mcall	80002588 <dip204_init+0x218>
    pwm_duty = (backlight_on) ? DIP204_PERIOD_MAX - 1 : 1;
8000239c:	58 07       	cp.w	r7,0
8000239e:	f9 b7 01 31 	movne	r7,49
800023a2:	f9 b7 00 01 	moveq	r7,1
800023a6:	4f a8       	lddpc	r8,8000258c <dip204_init+0x21c>
800023a8:	b0 07       	st.h	r8[0x0],r7
    pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED;   // channel mode
800023aa:	4f ab       	lddpc	r11,80002590 <dip204_init+0x220>
800023ac:	76 08       	ld.w	r8,r11[0x0]
    pwm_channel.CMR.cpol = PWM_POLARITY_LOW;   // channel polarity
    pwm_channel.CMR.cpd = PWM_UPDATE_PERIOD;   // not used the first time
800023ae:	e0 18 fc ff 	andl	r8,0xfcff
    pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK_DIV_256;   // channel prescaler
800023b2:	ab a8       	sbr	r8,0xa
800023b4:	30 89       	mov	r9,8
800023b6:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800023ba:	97 08       	st.w	r11[0x0],r8
    pwm_channel.cdty = pwm_duty;  // channel duty cycle, should be < CPRD
800023bc:	97 17       	st.w	r11[0x4],r7
    pwm_channel.cprd = DIP204_PERIOD_MAX;  // channel period
800023be:	33 28       	mov	r8,50
800023c0:	97 28       	st.w	r11[0x8],r8
    pwm_channel.cupd = 0;  // channel update is not used here.
800023c2:	30 08       	mov	r8,0
800023c4:	97 48       	st.w	r11[0x10],r8

    pwm_channel_init(channel_id, &pwm_channel);
800023c6:	4e f7       	lddpc	r7,80002580 <dip204_init+0x210>
800023c8:	6e 0c       	ld.w	r12,r7[0x0]
800023ca:	f0 1f 00 73 	mcall	80002594 <dip204_init+0x224>
    // start PWM
    pwm_start_channels(1 << channel_id);
800023ce:	6e 08       	ld.w	r8,r7[0x0]
800023d0:	30 1c       	mov	r12,1
800023d2:	f8 08 09 4c 	lsl	r12,r12,r8
800023d6:	f0 1f 00 71 	mcall	80002598 <dip204_init+0x228>
800023da:	c0 a8       	rjmp	800023ee <dip204_init+0x7e>
  }
  else
  {
    if (backlight_on)
800023dc:	58 0b       	cp.w	r11,0
800023de:	c0 50       	breq	800023e8 <dip204_init+0x78>
    {
      gpio_clr_gpio_pin(DIP204_BACKLIGHT_PIN);
800023e0:	33 2c       	mov	r12,50
800023e2:	f0 1f 00 6f 	mcall	8000259c <dip204_init+0x22c>
800023e6:	c0 48       	rjmp	800023ee <dip204_init+0x7e>
    }
    else
    {
      gpio_set_gpio_pin(DIP204_BACKLIGHT_PIN);
800023e8:	33 2c       	mov	r12,50
800023ea:	f0 1f 00 6e 	mcall	800025a0 <dip204_init+0x230>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800023ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800023f2:	e0 6a 4f 80 	mov	r10,20352
800023f6:	ea 1a 00 12 	orh	r10,0x12
800023fa:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800023fe:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002402:	14 38       	cp.w	r8,r10
80002404:	e0 88 00 08 	brls	80002414 <dip204_init+0xa4>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002408:	12 38       	cp.w	r8,r9
8000240a:	fe 98 ff fa 	brls	800023fe <dip204_init+0x8e>
8000240e:	12 3a       	cp.w	r10,r9
80002410:	c6 e3       	brcs	800024ec <dip204_init+0x17c>
80002412:	cf 6b       	rjmp	800023fe <dip204_init+0x8e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002414:	12 38       	cp.w	r8,r9
80002416:	e0 8b 00 6b 	brhi	800024ec <dip204_init+0x17c>
8000241a:	12 3a       	cp.w	r10,r9
8000241c:	c6 83       	brcs	800024ec <dip204_init+0x17c>
8000241e:	cf 0b       	rjmp	800023fe <dip204_init+0x8e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002420:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002424:	14 38       	cp.w	r8,r10
80002426:	e0 88 00 08 	brls	80002436 <dip204_init+0xc6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000242a:	12 38       	cp.w	r8,r9
8000242c:	fe 98 ff fa 	brls	80002420 <dip204_init+0xb0>
80002430:	12 3a       	cp.w	r10,r9
80002432:	c6 d3       	brcs	8000250c <dip204_init+0x19c>
80002434:	cf 6b       	rjmp	80002420 <dip204_init+0xb0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002436:	12 38       	cp.w	r8,r9
80002438:	e0 8b 00 6a 	brhi	8000250c <dip204_init+0x19c>
8000243c:	12 3a       	cp.w	r10,r9
8000243e:	c6 73       	brcs	8000250c <dip204_init+0x19c>
80002440:	cf 0b       	rjmp	80002420 <dip204_init+0xb0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002442:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002446:	14 38       	cp.w	r8,r10
80002448:	e0 88 00 08 	brls	80002458 <dip204_init+0xe8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000244c:	12 38       	cp.w	r8,r9
8000244e:	fe 98 ff fa 	brls	80002442 <dip204_init+0xd2>
80002452:	12 3a       	cp.w	r10,r9
80002454:	c6 63       	brcs	80002520 <dip204_init+0x1b0>
80002456:	cf 6b       	rjmp	80002442 <dip204_init+0xd2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002458:	12 38       	cp.w	r8,r9
8000245a:	e0 8b 00 63 	brhi	80002520 <dip204_init+0x1b0>
8000245e:	12 3a       	cp.w	r10,r9
80002460:	c6 03       	brcs	80002520 <dip204_init+0x1b0>
80002462:	cf 0b       	rjmp	80002442 <dip204_init+0xd2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002464:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002468:	14 38       	cp.w	r8,r10
8000246a:	e0 88 00 08 	brls	8000247a <dip204_init+0x10a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000246e:	12 38       	cp.w	r8,r9
80002470:	fe 98 ff fa 	brls	80002464 <dip204_init+0xf4>
80002474:	12 3a       	cp.w	r10,r9
80002476:	c5 f3       	brcs	80002534 <dip204_init+0x1c4>
80002478:	cf 6b       	rjmp	80002464 <dip204_init+0xf4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000247a:	12 38       	cp.w	r8,r9
8000247c:	e0 8b 00 5c 	brhi	80002534 <dip204_init+0x1c4>
80002480:	12 3a       	cp.w	r10,r9
80002482:	c5 93       	brcs	80002534 <dip204_init+0x1c4>
80002484:	cf 0b       	rjmp	80002464 <dip204_init+0xf4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002486:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000248a:	14 38       	cp.w	r8,r10
8000248c:	e0 88 00 08 	brls	8000249c <dip204_init+0x12c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002490:	12 38       	cp.w	r8,r9
80002492:	fe 98 ff fa 	brls	80002486 <dip204_init+0x116>
80002496:	12 3a       	cp.w	r10,r9
80002498:	c5 83       	brcs	80002548 <dip204_init+0x1d8>
8000249a:	cf 6b       	rjmp	80002486 <dip204_init+0x116>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000249c:	12 38       	cp.w	r8,r9
8000249e:	e0 8b 00 55 	brhi	80002548 <dip204_init+0x1d8>
800024a2:	12 3a       	cp.w	r10,r9
800024a4:	c5 23       	brcs	80002548 <dip204_init+0x1d8>
800024a6:	cf 0b       	rjmp	80002486 <dip204_init+0x116>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024a8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024ac:	14 38       	cp.w	r8,r10
800024ae:	e0 88 00 08 	brls	800024be <dip204_init+0x14e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024b2:	12 38       	cp.w	r8,r9
800024b4:	fe 98 ff fa 	brls	800024a8 <dip204_init+0x138>
800024b8:	12 3a       	cp.w	r10,r9
800024ba:	c5 13       	brcs	8000255c <dip204_init+0x1ec>
800024bc:	cf 6b       	rjmp	800024a8 <dip204_init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024be:	12 38       	cp.w	r8,r9
800024c0:	e0 8b 00 4e 	brhi	8000255c <dip204_init+0x1ec>
800024c4:	12 3a       	cp.w	r10,r9
800024c6:	c4 b3       	brcs	8000255c <dip204_init+0x1ec>
800024c8:	cf 0b       	rjmp	800024a8 <dip204_init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800024ca:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800024ce:	14 38       	cp.w	r8,r10
800024d0:	e0 88 00 08 	brls	800024e0 <dip204_init+0x170>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800024d4:	12 38       	cp.w	r8,r9
800024d6:	fe 98 ff fa 	brls	800024ca <dip204_init+0x15a>
800024da:	12 3a       	cp.w	r10,r9
800024dc:	c4 a3       	brcs	80002570 <dip204_init+0x200>
800024de:	cf 6b       	rjmp	800024ca <dip204_init+0x15a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800024e0:	12 38       	cp.w	r8,r9
800024e2:	e0 8b 00 47 	brhi	80002570 <dip204_init+0x200>
800024e6:	12 3a       	cp.w	r10,r9
800024e8:	c4 43       	brcs	80002570 <dip204_init+0x200>
800024ea:	cf 0b       	rjmp	800024ca <dip204_init+0x15a>
    }
  }
  // delay for power on
  delay_ms(20);
  // select the LCD chip
  dip204_select();
800024ec:	f0 1f 00 2e 	mcall	800025a4 <dip204_init+0x234>
  // Send Command Start Byte
  dip204_write_byte(DIP204_WRITE_COMMAND);
800024f0:	e0 6c 00 f8 	mov	r12,248
800024f4:	f0 1f 00 2d 	mcall	800025a8 <dip204_init+0x238>
  // Send "extended Function Set" Command  (RE=1)
  dip204_write_byte(0x34);
800024f8:	33 4c       	mov	r12,52
800024fa:	f0 1f 00 2c 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800024fe:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002502:	e0 69 ea 60 	mov	r9,60000
80002506:	f0 09 00 0a 	add	r10,r8,r9
8000250a:	c8 bb       	rjmp	80002420 <dip204_init+0xb0>
  // Wait for command execution
  delay_ms(1);
  // Send "Enter 4-Line Mode" Command
  dip204_write_byte(0x09);
8000250c:	30 9c       	mov	r12,9
8000250e:	f0 1f 00 27 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002512:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002516:	e0 69 ea 60 	mov	r9,60000
8000251a:	f0 09 00 0a 	add	r10,r8,r9
8000251e:	c9 2b       	rjmp	80002442 <dip204_init+0xd2>
  // Wait for command execution
  delay_ms(1);
  // Send "Function Set" Command (RE=0)
  dip204_write_byte(0x30);
80002520:	33 0c       	mov	r12,48
80002522:	f0 1f 00 22 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002526:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000252a:	e0 69 ea 60 	mov	r9,60000
8000252e:	f0 09 00 0a 	add	r10,r8,r9
80002532:	c9 9b       	rjmp	80002464 <dip204_init+0xf4>
  // Wait for command execution
  delay_ms(1);
  // Send "Display On Command: Display On, Cursor On, Blink On"
  dip204_write_byte(0x0F);
80002534:	30 fc       	mov	r12,15
80002536:	f0 1f 00 1d 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000253a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000253e:	e0 69 ea 60 	mov	r9,60000
80002542:	f0 09 00 0a 	add	r10,r8,r9
80002546:	ca 0b       	rjmp	80002486 <dip204_init+0x116>
  // Wait for command execution
  delay_ms(1);
  // Send "Display Clear" Command
  dip204_write_byte(0x01);
80002548:	30 1c       	mov	r12,1
8000254a:	f0 1f 00 18 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000254e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002552:	e4 69 93 e0 	mov	r9,300000
80002556:	f0 09 00 0a 	add	r10,r8,r9
8000255a:	ca 7b       	rjmp	800024a8 <dip204_init+0x138>
  // Wait for command execution
  delay_ms(5);
  // Send "Entry Mode Set Command: Increment Mode, Entire Shift off"
  dip204_write_byte(0x06);
8000255c:	30 6c       	mov	r12,6
8000255e:	f0 1f 00 13 	mcall	800025a8 <dip204_init+0x238>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002562:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002566:	e0 69 ea 60 	mov	r9,60000
8000256a:	f0 09 00 0a 	add	r10,r8,r9
8000256e:	ca eb       	rjmp	800024ca <dip204_init+0x15a>
  // Wait for command execution
  delay_ms(1);
  dip204_wait_busy();
80002570:	f0 1f 00 0f 	mcall	800025ac <dip204_init+0x23c>
  // unselect chip
  dip204_unselect();
80002574:	f0 1f 00 0f 	mcall	800025b0 <dip204_init+0x240>
}
80002578:	2f cd       	sub	sp,-16
8000257a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000257e:	00 00       	add	r0,r0
80002580:	00 00       	add	r0,r0
80002582:	00 1c       	sub	r12,r0
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	25 b4       	sub	r4,91
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	29 2c       	sub	r12,-110
8000258c:	00 00       	add	r0,r0
8000258e:	05 6c       	ld.uh	r12,--r2
80002590:	00 00       	add	r0,r0
80002592:	05 4c       	ld.w	r12,--r2
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	28 ac       	sub	r12,-118
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	28 e2       	sub	r2,-114
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	26 54       	sub	r4,101
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	26 38       	sub	r8,99
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	20 dc       	sub	r12,13
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	20 f0       	sub	r0,15
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	21 84       	sub	r4,24
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	21 b8       	sub	r8,27

800025b4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800025b4:	f8 08 16 05 	lsr	r8,r12,0x5
800025b8:	a9 68       	lsl	r8,0x8
800025ba:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800025be:	58 1b       	cp.w	r11,1
800025c0:	c0 d0       	breq	800025da <gpio_enable_module_pin+0x26>
800025c2:	c0 63       	brcs	800025ce <gpio_enable_module_pin+0x1a>
800025c4:	58 2b       	cp.w	r11,2
800025c6:	c1 00       	breq	800025e6 <gpio_enable_module_pin+0x32>
800025c8:	58 3b       	cp.w	r11,3
800025ca:	c1 40       	breq	800025f2 <gpio_enable_module_pin+0x3e>
800025cc:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800025ce:	30 19       	mov	r9,1
800025d0:	f2 0c 09 49 	lsl	r9,r9,r12
800025d4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800025d6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025d8:	c1 28       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800025da:	30 19       	mov	r9,1
800025dc:	f2 0c 09 49 	lsl	r9,r9,r12
800025e0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800025e2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025e4:	c0 c8       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800025e6:	30 19       	mov	r9,1
800025e8:	f2 0c 09 49 	lsl	r9,r9,r12
800025ec:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800025ee:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800025f0:	c0 68       	rjmp	800025fc <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800025f2:	30 19       	mov	r9,1
800025f4:	f2 0c 09 49 	lsl	r9,r9,r12
800025f8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800025fa:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800025fc:	30 19       	mov	r9,1
800025fe:	f2 0c 09 4c 	lsl	r12,r9,r12
80002602:	91 2c       	st.w	r8[0x8],r12
80002604:	5e fd       	retal	0
80002606:	d7 03       	nop

80002608 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002608:	d4 21       	pushm	r4-r7,lr
8000260a:	18 97       	mov	r7,r12
8000260c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000260e:	58 0b       	cp.w	r11,0
80002610:	c0 31       	brne	80002616 <gpio_enable_module+0xe>
80002612:	30 05       	mov	r5,0
80002614:	c0 d8       	rjmp	8000262e <gpio_enable_module+0x26>
80002616:	30 06       	mov	r6,0
80002618:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000261a:	6e 1b       	ld.w	r11,r7[0x4]
8000261c:	6e 0c       	ld.w	r12,r7[0x0]
8000261e:	f0 1f 00 06 	mcall	80002634 <gpio_enable_module+0x2c>
80002622:	18 45       	or	r5,r12
		gpiomap++;
80002624:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002626:	2f f6       	sub	r6,-1
80002628:	0c 34       	cp.w	r4,r6
8000262a:	fe 9b ff f8 	brhi	8000261a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000262e:	0a 9c       	mov	r12,r5
80002630:	d8 22       	popm	r4-r7,pc
80002632:	00 00       	add	r0,r0
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	25 b4       	sub	r4,91

80002638 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002638:	f8 08 16 05 	lsr	r8,r12,0x5
8000263c:	a9 68       	lsl	r8,0x8
8000263e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002642:	30 19       	mov	r9,1
80002644:	f2 0c 09 4c 	lsl	r12,r9,r12
80002648:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000264c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002650:	91 1c       	st.w	r8[0x4],r12
}
80002652:	5e fc       	retal	r12

80002654 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002654:	f8 08 16 05 	lsr	r8,r12,0x5
80002658:	a9 68       	lsl	r8,0x8
8000265a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000265e:	30 19       	mov	r9,1
80002660:	f2 0c 09 4c 	lsl	r12,r9,r12
80002664:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80002668:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000266c:	91 1c       	st.w	r8[0x4],r12
}
8000266e:	5e fc       	retal	r12

80002670 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002670:	f8 08 16 05 	lsr	r8,r12,0x5
80002674:	a9 68       	lsl	r8,0x8
80002676:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
8000267a:	30 19       	mov	r9,1
8000267c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002680:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80002684:	12 3b       	cp.w	r11,r9
80002686:	c0 a0       	breq	8000269a <gpio_enable_pin_interrupt+0x2a>
80002688:	c0 43       	brcs	80002690 <gpio_enable_pin_interrupt+0x20>
8000268a:	58 2b       	cp.w	r11,2
8000268c:	c1 11       	brne	800026ae <gpio_enable_pin_interrupt+0x3e>
8000268e:	c0 b8       	rjmp	800026a4 <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002690:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80002694:	f1 4c 00 b8 	st.w	r8[184],r12
80002698:	c0 c8       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
8000269a:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000269e:	f1 4c 00 b8 	st.w	r8[184],r12
800026a2:	c0 78       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800026a4:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
800026a8:	f1 4c 00 b4 	st.w	r8[180],r12
800026ac:	c0 28       	rjmp	800026b0 <gpio_enable_pin_interrupt+0x40>
800026ae:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
800026b0:	f1 4c 00 94 	st.w	r8[148],r12
800026b4:	5e fd       	retal	0

800026b6 <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026b6:	f8 08 16 05 	lsr	r8,r12,0x5
800026ba:	a9 68       	lsl	r8,0x8
800026bc:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
800026c0:	f0 f8 00 d0 	ld.w	r8,r8[208]
800026c4:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800026c8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800026cc:	5e fc       	retal	r12

800026ce <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800026ce:	f8 08 16 05 	lsr	r8,r12,0x5
800026d2:	a9 68       	lsl	r8,0x8
800026d4:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800026d8:	30 19       	mov	r9,1
800026da:	f2 0c 09 4c 	lsl	r12,r9,r12
800026de:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
800026e2:	5e fc       	retal	r12

800026e4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800026e4:	c0 08       	rjmp	800026e4 <_unhandled_interrupt>
800026e6:	d7 03       	nop

800026e8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800026e8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800026ec:	49 99       	lddpc	r9,80002750 <INTC_register_interrupt+0x68>
800026ee:	f2 08 00 39 	add	r9,r9,r8<<0x3
800026f2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800026f6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800026f8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800026fc:	58 0a       	cp.w	r10,0
800026fe:	c0 91       	brne	80002710 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002700:	49 59       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
80002702:	49 6a       	lddpc	r10,80002758 <INTC_register_interrupt+0x70>
80002704:	12 1a       	sub	r10,r9
80002706:	fe 79 08 00 	mov	r9,-63488
8000270a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000270e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80002710:	58 1a       	cp.w	r10,1
80002712:	c0 a1       	brne	80002726 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002714:	49 09       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
80002716:	49 2a       	lddpc	r10,8000275c <INTC_register_interrupt+0x74>
80002718:	12 1a       	sub	r10,r9
8000271a:	bf aa       	sbr	r10,0x1e
8000271c:	fe 79 08 00 	mov	r9,-63488
80002720:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002724:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80002726:	58 2a       	cp.w	r10,2
80002728:	c0 a1       	brne	8000273c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000272a:	48 b9       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
8000272c:	48 da       	lddpc	r10,80002760 <INTC_register_interrupt+0x78>
8000272e:	12 1a       	sub	r10,r9
80002730:	bf ba       	sbr	r10,0x1f
80002732:	fe 79 08 00 	mov	r9,-63488
80002736:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000273a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000273c:	48 69       	lddpc	r9,80002754 <INTC_register_interrupt+0x6c>
8000273e:	48 aa       	lddpc	r10,80002764 <INTC_register_interrupt+0x7c>
80002740:	12 1a       	sub	r10,r9
80002742:	ea 1a c0 00 	orh	r10,0xc000
80002746:	fe 79 08 00 	mov	r9,-63488
8000274a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000274e:	5e fc       	retal	r12
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	46 18       	lddsp	r8,sp[0x184]
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	44 00       	lddsp	r0,sp[0x100]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	45 04       	lddsp	r4,sp[0x140]
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	45 12       	lddsp	r2,sp[0x144]
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	45 20       	lddsp	r0,sp[0x148]
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	45 2e       	lddsp	lr,sp[0x148]

80002768 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002768:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000276a:	49 18       	lddpc	r8,800027ac <INTC_init_interrupts+0x44>
8000276c:	e3 b8 00 01 	mtsr	0x4,r8
80002770:	49 0e       	lddpc	lr,800027b0 <INTC_init_interrupts+0x48>
80002772:	30 07       	mov	r7,0
80002774:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002776:	49 0c       	lddpc	r12,800027b4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002778:	49 05       	lddpc	r5,800027b8 <INTC_init_interrupts+0x50>
8000277a:	10 15       	sub	r5,r8
8000277c:	fe 76 08 00 	mov	r6,-63488
80002780:	c1 08       	rjmp	800027a0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002782:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002784:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002786:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002788:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000278c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000278e:	10 3a       	cp.w	r10,r8
80002790:	fe 9b ff fc 	brhi	80002788 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002794:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002798:	2f f7       	sub	r7,-1
8000279a:	2f 8e       	sub	lr,-8
8000279c:	59 47       	cp.w	r7,20
8000279e:	c0 50       	breq	800027a8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800027a0:	7c 08       	ld.w	r8,lr[0x0]
800027a2:	58 08       	cp.w	r8,0
800027a4:	ce f1       	brne	80002782 <INTC_init_interrupts+0x1a>
800027a6:	cf 7b       	rjmp	80002794 <INTC_init_interrupts+0x2c>
800027a8:	d8 22       	popm	r4-r7,pc
800027aa:	00 00       	add	r0,r0
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	44 00       	lddsp	r0,sp[0x100]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	46 18       	lddsp	r8,sp[0x184]
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	26 e4       	sub	r4,110
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	45 04       	lddsp	r4,sp[0x140]

800027bc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800027bc:	fe 78 08 00 	mov	r8,-63488
800027c0:	e0 69 00 83 	mov	r9,131
800027c4:	f2 0c 01 0c 	sub	r12,r9,r12
800027c8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800027cc:	f2 ca ff c0 	sub	r10,r9,-64
800027d0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800027d4:	58 08       	cp.w	r8,0
800027d6:	c0 21       	brne	800027da <_get_interrupt_handler+0x1e>
800027d8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
800027da:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800027de:	48 5a       	lddpc	r10,800027f0 <_get_interrupt_handler+0x34>
800027e0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800027e4:	f0 08 11 1f 	rsub	r8,r8,31
800027e8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800027ea:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800027ee:	5e fc       	retal	r12
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	46 18       	lddsp	r8,sp[0x184]

800027f4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800027f4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800027f6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800027fa:	99 a8       	st.w	r12[0x28],r8
}
800027fc:	5e fc       	retal	r12
800027fe:	d7 03       	nop

80002800 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002800:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002802:	ec 5b bb 9f 	cp.w	r11,899999
80002806:	e0 8b 00 04 	brhi	8000280e <pm_enable_osc0_crystal+0xe>
8000280a:	30 4b       	mov	r11,4
8000280c:	c1 38       	rjmp	80002832 <pm_enable_osc0_crystal+0x32>
8000280e:	e0 68 c6 bf 	mov	r8,50879
80002812:	ea 18 00 2d 	orh	r8,0x2d
80002816:	10 3b       	cp.w	r11,r8
80002818:	e0 8b 00 04 	brhi	80002820 <pm_enable_osc0_crystal+0x20>
8000281c:	30 5b       	mov	r11,5
8000281e:	c0 a8       	rjmp	80002832 <pm_enable_osc0_crystal+0x32>
80002820:	e0 68 12 00 	mov	r8,4608
80002824:	ea 18 00 7a 	orh	r8,0x7a
80002828:	10 3b       	cp.w	r11,r8
8000282a:	f9 bb 03 06 	movlo	r11,6
8000282e:	f9 bb 02 07 	movhs	r11,7
80002832:	f0 1f 00 02 	mcall	80002838 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002836:	d8 02       	popm	pc
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	27 f4       	sub	r4,127

8000283c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000283c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000283e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002842:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002844:	78 08       	ld.w	r8,r12[0x0]
80002846:	a3 a8       	sbr	r8,0x2
80002848:	99 08       	st.w	r12[0x0],r8
}
8000284a:	5e fc       	retal	r12

8000284c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000284c:	79 58       	ld.w	r8,r12[0x54]
8000284e:	e2 18 00 80 	andl	r8,0x80,COH
80002852:	cf d0       	breq	8000284c <pm_wait_for_clk0_ready>
}
80002854:	5e fc       	retal	r12
80002856:	d7 03       	nop

80002858 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002858:	eb cd 40 80 	pushm	r7,lr
8000285c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000285e:	f0 1f 00 04 	mcall	8000286c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002862:	0e 9c       	mov	r12,r7
80002864:	f0 1f 00 03 	mcall	80002870 <pm_enable_clk0+0x18>
}
80002868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	28 3c       	sub	r12,-125
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	28 4c       	sub	r12,-124

80002874 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002874:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002876:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000287a:	99 08       	st.w	r12[0x0],r8
}
8000287c:	5e fc       	retal	r12
8000287e:	d7 03       	nop

80002880 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002880:	eb cd 40 c0 	pushm	r6-r7,lr
80002884:	18 97       	mov	r7,r12
80002886:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002888:	f0 1f 00 06 	mcall	800028a0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000288c:	0c 9b       	mov	r11,r6
8000288e:	0e 9c       	mov	r12,r7
80002890:	f0 1f 00 05 	mcall	800028a4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002894:	30 1b       	mov	r11,1
80002896:	0e 9c       	mov	r12,r7
80002898:	f0 1f 00 04 	mcall	800028a8 <pm_switch_to_osc0+0x28>
}
8000289c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	28 00       	sub	r0,-128
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	28 58       	sub	r8,-123
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	28 74       	sub	r4,-121

800028ac <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
800028ac:	58 0b       	cp.w	r11,0
800028ae:	c1 90       	breq	800028e0 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
800028b0:	58 6c       	cp.w	r12,6
800028b2:	e0 8b 00 17 	brhi	800028e0 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
800028b6:	76 0a       	ld.w	r10,r11[0x0]
800028b8:	fe 78 30 00 	mov	r8,-53248
800028bc:	f8 c9 ff f0 	sub	r9,r12,-16
800028c0:	a5 79       	lsl	r9,0x5
800028c2:	f0 09 00 09 	add	r9,r8,r9
800028c6:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
800028c8:	76 19       	ld.w	r9,r11[0x4]
800028ca:	a5 7c       	lsl	r12,0x5
800028cc:	f0 0c 00 0c 	add	r12,r8,r12
800028d0:	f8 c8 fd fc 	sub	r8,r12,-516
800028d4:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
800028d6:	76 28       	ld.w	r8,r11[0x8]
800028d8:	f8 cc fd f8 	sub	r12,r12,-520
800028dc:	99 08       	st.w	r12[0x0],r8
800028de:	5e fd       	retal	0

  return PWM_SUCCESS;
800028e0:	5e ff       	retal	1

800028e2 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
800028e2:	18 98       	mov	r8,r12
800028e4:	e0 18 ff 80 	andl	r8,0xff80
800028e8:	c0 20       	breq	800028ec <pwm_start_channels+0xa>
800028ea:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800028ec:	fe 78 30 00 	mov	r8,-53248
800028f0:	91 1c       	st.w	r8[0x4],r12
800028f2:	5e fd       	retal	0

800028f4 <pwm_sync_update_channel>:

int pwm_sync_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
800028f4:	58 6c       	cp.w	r12,6
800028f6:	e0 88 00 03 	brls	800028fc <pwm_sync_update_channel+0x8>
800028fa:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  AVR32_PWM.isr;                                    // Acknowledgement and clear previous register state.
800028fc:	fe 78 30 00 	mov	r8,-53248
80002900:	70 79       	ld.w	r9,r8[0x1c]
  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80002902:	76 09       	ld.w	r9,r11[0x0]
80002904:	f8 ca ff f0 	sub	r10,r12,-16
80002908:	a5 7a       	lsl	r10,0x5
8000290a:	14 08       	add	r8,r10
8000290c:	91 09       	st.w	r8[0x0],r9
  while (!(AVR32_PWM.isr & (1 << channel_id)));     // Wait until the last write has been taken into account.
8000290e:	30 1a       	mov	r10,1
80002910:	f4 0c 09 4a 	lsl	r10,r10,r12
80002914:	fe 79 30 00 	mov	r9,-53248
80002918:	72 78       	ld.w	r8,r9[0x1c]
8000291a:	f5 e8 00 08 	and	r8,r10,r8
8000291e:	cf d0       	breq	80002918 <pwm_sync_update_channel+0x24>
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80002920:	76 48       	ld.w	r8,r11[0x10]
80002922:	a5 7c       	lsl	r12,0x5
80002924:	e0 2c cd f0 	sub	r12,52720
80002928:	99 08       	st.w	r12[0x0],r8
8000292a:	5e fd       	retal	0

8000292c <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000292c:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80002930:	58 0c       	cp.w	r12,0
80002932:	c0 21       	brne	80002936 <pwm_init+0xa>
80002934:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002936:	e6 18 00 01 	andh	r8,0x1,COH
8000293a:	c0 91       	brne	8000294c <pwm_init+0x20>
8000293c:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000293e:	fe 78 30 00 	mov	r8,-53248
80002942:	37 f9       	mov	r9,127
80002944:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002946:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002948:	d5 03       	csrf	0x10
8000294a:	c0 68       	rjmp	80002956 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
8000294c:	fe 78 30 00 	mov	r8,-53248
80002950:	37 f9       	mov	r9,127
80002952:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002954:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80002956:	78 08       	ld.w	r8,r12[0x0]
80002958:	78 39       	ld.w	r9,r12[0xc]
8000295a:	a9 69       	lsl	r9,0x8
8000295c:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80002960:	78 18       	ld.w	r8,r12[0x4]
80002962:	10 49       	or	r9,r8
80002964:	78 28       	ld.w	r8,r12[0x8]
80002966:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
8000296a:	fe 78 30 00 	mov	r8,-53248
8000296e:	91 09       	st.w	r8[0x0],r9
80002970:	5e fd       	retal	0

80002972 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002972:	f8 c8 00 01 	sub	r8,r12,1
80002976:	f0 0b 00 0b 	add	r11,r8,r11
8000297a:	f6 0c 0d 0a 	divu	r10,r11,r12
8000297e:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002980:	f4 c8 00 01 	sub	r8,r10,1
80002984:	e0 48 00 fe 	cp.w	r8,254
80002988:	e0 88 00 03 	brls	8000298e <getBaudDiv+0x1c>
8000298c:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
8000298e:	5c 8c       	casts.h	r12
}
80002990:	5e fc       	retal	r12

80002992 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002992:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002996:	30 18       	mov	r8,1
80002998:	f0 09 18 00 	cp.b	r9,r8
8000299c:	e0 88 00 04 	brls	800029a4 <spi_initMaster+0x12>
800029a0:	30 2c       	mov	r12,2
800029a2:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800029a4:	e0 68 00 80 	mov	r8,128
800029a8:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800029aa:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800029ac:	30 19       	mov	r9,1
800029ae:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800029b2:	f7 39 00 0d 	ld.ub	r9,r11[13]
800029b6:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800029ba:	30 09       	mov	r9,0
800029bc:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800029c0:	30 fa       	mov	r10,15
800029c2:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800029c6:	99 18       	st.w	r12[0x4],r8
800029c8:	5e f9       	retal	r9

800029ca <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800029ca:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800029cc:	30 18       	mov	r8,1
800029ce:	f0 0b 18 00 	cp.b	r11,r8
800029d2:	5f be       	srhi	lr
800029d4:	f0 0a 18 00 	cp.b	r10,r8
800029d8:	5f b8       	srhi	r8
800029da:	fd e8 10 08 	or	r8,lr,r8
800029de:	c0 30       	breq	800029e4 <spi_selectionMode+0x1a>
800029e0:	30 2c       	mov	r12,2
800029e2:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800029e4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800029e6:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800029ea:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800029ee:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800029f2:	99 18       	st.w	r12[0x4],r8
800029f4:	d8 0a       	popm	pc,r12=0

800029f6 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800029f6:	30 18       	mov	r8,1
800029f8:	99 08       	st.w	r12[0x0],r8
}
800029fa:	5e fc       	retal	r12

800029fc <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800029fc:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a00:	c0 58       	rjmp	80002a0a <spi_write+0xe>
		if (!timeout--) {
80002a02:	58 08       	cp.w	r8,0
80002a04:	c0 21       	brne	80002a08 <spi_write+0xc>
80002a06:	5e ff       	retal	1
80002a08:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002a0a:	78 49       	ld.w	r9,r12[0x10]
80002a0c:	e2 19 00 02 	andl	r9,0x2,COH
80002a10:	cf 90       	breq	80002a02 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002a12:	5c 7b       	castu.h	r11
80002a14:	99 3b       	st.w	r12[0xc],r11
80002a16:	5e fd       	retal	0

80002a18 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002a18:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a1c:	c0 58       	rjmp	80002a26 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002a1e:	58 08       	cp.w	r8,0
80002a20:	c0 21       	brne	80002a24 <spi_read+0xc>
80002a22:	5e ff       	retal	1
80002a24:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002a26:	78 49       	ld.w	r9,r12[0x10]
80002a28:	e2 19 02 01 	andl	r9,0x201,COH
80002a2c:	e0 49 02 01 	cp.w	r9,513
80002a30:	cf 71       	brne	80002a1e <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002a32:	78 28       	ld.w	r8,r12[0x8]
80002a34:	b6 08       	st.h	r11[0x0],r8
80002a36:	5e fd       	retal	0

80002a38 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002a38:	eb cd 40 f8 	pushm	r3-r7,lr
80002a3c:	18 95       	mov	r5,r12
80002a3e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a40:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002a44:	30 38       	mov	r8,3
80002a46:	f0 06 18 00 	cp.b	r6,r8
80002a4a:	e0 8b 00 5e 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80002a4e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a52:	30 18       	mov	r8,1
80002a54:	f0 04 18 00 	cp.b	r4,r8
80002a58:	e0 8b 00 57 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002a5c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002a60:	30 78       	mov	r8,7
80002a62:	f0 03 18 00 	cp.b	r3,r8
80002a66:	e0 88 00 50 	brls	80002b06 <spi_setupChipReg+0xce>
80002a6a:	31 08       	mov	r8,16
80002a6c:	f0 03 18 00 	cp.b	r3,r8
80002a70:	e0 8b 00 4b 	brhi	80002b06 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002a74:	14 9b       	mov	r11,r10
80002a76:	6e 1c       	ld.w	r12,r7[0x4]
80002a78:	f0 1f 00 26 	mcall	80002b10 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80002a7c:	c4 55       	brlt	80002b06 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002a7e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002a80:	ec 09 16 01 	lsr	r9,r6,0x1
80002a84:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002a88:	ec 16 00 01 	eorl	r6,0x1
80002a8c:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002a90:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002a94:	20 83       	sub	r3,8
80002a96:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002a9a:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002a9e:	ef 39 00 09 	ld.ub	r9,r7[9]
80002aa2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002aa6:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002aaa:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002aae:	0f 89       	ld.ub	r9,r7[0x0]
80002ab0:	30 1a       	mov	r10,1
80002ab2:	f4 09 18 00 	cp.b	r9,r10
80002ab6:	c0 d0       	breq	80002ad0 <spi_setupChipReg+0x98>
80002ab8:	c0 a3       	brcs	80002acc <spi_setupChipReg+0x94>
80002aba:	30 2a       	mov	r10,2
80002abc:	f4 09 18 00 	cp.b	r9,r10
80002ac0:	c0 a0       	breq	80002ad4 <spi_setupChipReg+0x9c>
80002ac2:	30 3a       	mov	r10,3
80002ac4:	f4 09 18 00 	cp.b	r9,r10
80002ac8:	c1 f1       	brne	80002b06 <spi_setupChipReg+0xce>
80002aca:	c0 78       	rjmp	80002ad8 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002acc:	8b c8       	st.w	r5[0x30],r8
		break;
80002ace:	c0 68       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002ad0:	8b d8       	st.w	r5[0x34],r8
		break;
80002ad2:	c0 48       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002ad4:	8b e8       	st.w	r5[0x38],r8
		break;
80002ad6:	c0 28       	rjmp	80002ada <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002ad8:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80002ada:	48 f8       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002adc:	70 08       	ld.w	r8,r8[0x0]
80002ade:	58 08       	cp.w	r8,0
80002ae0:	c1 61       	brne	80002b0c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80002ae2:	30 0b       	mov	r11,0
80002ae4:	30 1c       	mov	r12,1
80002ae6:	f0 1f 00 0d 	mcall	80002b18 <spi_setupChipReg+0xe0>
80002aea:	48 b8       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002aec:	91 0c       	st.w	r8[0x0],r12
80002aee:	58 0c       	cp.w	r12,0
80002af0:	c0 a0       	breq	80002b04 <spi_setupChipReg+0xcc>
80002af2:	30 09       	mov	r9,0
80002af4:	12 9a       	mov	r10,r9
80002af6:	12 9b       	mov	r11,r9
80002af8:	f0 1f 00 09 	mcall	80002b1c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80002afc:	48 68       	lddpc	r8,80002b14 <spi_setupChipReg+0xdc>
80002afe:	70 08       	ld.w	r8,r8[0x0]
80002b00:	58 08       	cp.w	r8,0
80002b02:	c0 51       	brne	80002b0c <spi_setupChipReg+0xd4>
80002b04:	c0 08       	rjmp	80002b04 <spi_setupChipReg+0xcc>
80002b06:	30 2c       	mov	r12,2
80002b08:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002b0c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	29 72       	sub	r2,-105
80002b14:	00 00       	add	r0,r0
80002b16:	07 88       	ld.ub	r8,r3[0x0]
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	31 1c       	mov	r12,17
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	30 1c       	mov	r12,1

80002b20 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002b20:	d4 01       	pushm	lr
80002b22:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b26:	c0 58       	rjmp	80002b30 <spi_unselectChip+0x10>
		if (!timeout--) {
80002b28:	58 08       	cp.w	r8,0
80002b2a:	c0 21       	brne	80002b2e <spi_unselectChip+0xe>
80002b2c:	da 0a       	popm	pc,r12=1
80002b2e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002b30:	78 49       	ld.w	r9,r12[0x10]
80002b32:	e2 19 02 00 	andl	r9,0x200,COH
80002b36:	cf 90       	breq	80002b28 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002b38:	78 18       	ld.w	r8,r12[0x4]
80002b3a:	ea 18 00 0f 	orh	r8,0xf
80002b3e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002b40:	fc 18 01 00 	movh	r8,0x100
80002b44:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80002b46:	30 09       	mov	r9,0
80002b48:	12 9a       	mov	r10,r9
80002b4a:	12 9b       	mov	r11,r9
80002b4c:	48 38       	lddpc	r8,80002b58 <spi_unselectChip+0x38>
80002b4e:	70 0c       	ld.w	r12,r8[0x0]
80002b50:	f0 1f 00 03 	mcall	80002b5c <spi_unselectChip+0x3c>
80002b54:	d8 0a       	popm	pc,r12=0
80002b56:	00 00       	add	r0,r0
80002b58:	00 00       	add	r0,r0
80002b5a:	07 88       	ld.ub	r8,r3[0x0]
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	30 1c       	mov	r12,1

80002b60 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002b60:	eb cd 40 f8 	pushm	r3-r7,lr
80002b64:	18 94       	mov	r4,r12
80002b66:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80002b68:	49 a6       	lddpc	r6,80002bd0 <spi_selectChip+0x70>
80002b6a:	30 07       	mov	r7,0
80002b6c:	31 45       	mov	r5,20
80002b6e:	0e 99       	mov	r9,r7
80002b70:	0a 9a       	mov	r10,r5
80002b72:	0e 9b       	mov	r11,r7
80002b74:	6c 0c       	ld.w	r12,r6[0x0]
80002b76:	f0 1f 00 18 	mcall	80002bd4 <spi_selectChip+0x74>
80002b7a:	cf a0       	breq	80002b6e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002b7c:	68 18       	ld.w	r8,r4[0x4]
80002b7e:	ea 18 00 0f 	orh	r8,0xf
80002b82:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002b84:	68 18       	ld.w	r8,r4[0x4]
80002b86:	e2 18 00 04 	andl	r8,0x4,COH
80002b8a:	c1 10       	breq	80002bac <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002b8c:	30 e8       	mov	r8,14
80002b8e:	f0 03 18 00 	cp.b	r3,r8
80002b92:	e0 8b 00 1c 	brhi	80002bca <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002b96:	68 19       	ld.w	r9,r4[0x4]
80002b98:	e6 08 15 10 	lsl	r8,r3,0x10
80002b9c:	ea 18 ff f0 	orh	r8,0xfff0
80002ba0:	e8 18 ff ff 	orl	r8,0xffff
80002ba4:	12 68       	and	r8,r9
80002ba6:	89 18       	st.w	r4[0x4],r8
80002ba8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002bac:	30 38       	mov	r8,3
80002bae:	f0 03 18 00 	cp.b	r3,r8
80002bb2:	e0 8b 00 0c 	brhi	80002bca <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002bb6:	68 19       	ld.w	r9,r4[0x4]
80002bb8:	2f 03       	sub	r3,-16
80002bba:	30 18       	mov	r8,1
80002bbc:	f0 03 09 48 	lsl	r8,r8,r3
80002bc0:	5c d8       	com	r8
80002bc2:	12 68       	and	r8,r9
80002bc4:	89 18       	st.w	r4[0x4],r8
80002bc6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80002bca:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002bcc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002bd0:	00 00       	add	r0,r0
80002bd2:	07 88       	ld.ub	r8,r3[0x0]
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2f 00       	sub	r0,-16

80002bd8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80002bd8:	f8 c8 ff f8 	sub	r8,r12,-8
80002bdc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80002bde:	3f f9       	mov	r9,-1
80002be0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80002be2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80002be4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80002be6:	30 08       	mov	r8,0
80002be8:	99 08       	st.w	r12[0x0],r8
}
80002bea:	5e fc       	retal	r12

80002bec <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80002bec:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80002bee:	70 19       	ld.w	r9,r8[0x4]
80002bf0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80002bf2:	78 19       	ld.w	r9,r12[0x4]
80002bf4:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002bf6:	70 19       	ld.w	r9,r8[0x4]
80002bf8:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80002bfa:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80002bfc:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002bfe:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c00:	78 08       	ld.w	r8,r12[0x0]
80002c02:	2f f8       	sub	r8,-1
80002c04:	99 08       	st.w	r12[0x0],r8
}
80002c06:	5e fc       	retal	r12

80002c08 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80002c08:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80002c0a:	5b fa       	cp.w	r10,-1
80002c0c:	c0 31       	brne	80002c12 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80002c0e:	78 48       	ld.w	r8,r12[0x10]
80002c10:	c0 c8       	rjmp	80002c28 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80002c12:	f8 c8 ff f8 	sub	r8,r12,-8
80002c16:	70 19       	ld.w	r9,r8[0x4]
80002c18:	72 09       	ld.w	r9,r9[0x0]
80002c1a:	12 3a       	cp.w	r10,r9
80002c1c:	c0 63       	brcs	80002c28 <vListInsert+0x20>
80002c1e:	70 18       	ld.w	r8,r8[0x4]
80002c20:	70 19       	ld.w	r9,r8[0x4]
80002c22:	72 09       	ld.w	r9,r9[0x0]
80002c24:	12 3a       	cp.w	r10,r9
80002c26:	cf c2       	brcc	80002c1e <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80002c28:	70 19       	ld.w	r9,r8[0x4]
80002c2a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80002c2c:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80002c2e:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80002c30:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80002c32:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80002c34:	78 08       	ld.w	r8,r12[0x0]
80002c36:	2f f8       	sub	r8,-1
80002c38:	99 08       	st.w	r12[0x0],r8
}
80002c3a:	5e fc       	retal	r12

80002c3c <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80002c3c:	78 18       	ld.w	r8,r12[0x4]
80002c3e:	78 29       	ld.w	r9,r12[0x8]
80002c40:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80002c42:	78 28       	ld.w	r8,r12[0x8]
80002c44:	78 19       	ld.w	r9,r12[0x4]
80002c46:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80002c48:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80002c4a:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80002c4c:	18 39       	cp.w	r9,r12
80002c4e:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80002c52:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80002c56:	30 09       	mov	r9,0
80002c58:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80002c5a:	70 09       	ld.w	r9,r8[0x0]
80002c5c:	20 19       	sub	r9,1
80002c5e:	91 09       	st.w	r8[0x0],r9
}
80002c60:	5e fc       	retal	r12
80002c62:	d7 03       	nop

80002c64 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80002c64:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80002c66:	48 38       	lddpc	r8,80002c70 <vPortEnterCritical+0xc>
80002c68:	70 09       	ld.w	r9,r8[0x0]
80002c6a:	2f f9       	sub	r9,-1
80002c6c:	91 09       	st.w	r8[0x0],r9
}
80002c6e:	5e fc       	retal	r12
80002c70:	00 00       	add	r0,r0
80002c72:	00 20       	rsub	r0,r0

80002c74 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80002c74:	20 6d       	sub	sp,24
80002c76:	eb cd 00 ff 	pushm	r0-r7
80002c7a:	fa c7 ff c0 	sub	r7,sp,-64
80002c7e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80002c82:	ef 40 ff e0 	st.w	r7[-32],r0
80002c86:	ee f0 ff fc 	ld.w	r0,r7[-4]
80002c8a:	ef 40 ff e4 	st.w	r7[-28],r0
80002c8e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80002c92:	e0 68 00 20 	mov	r8,32
80002c96:	ea 18 00 00 	orh	r8,0x0
80002c9a:	70 00       	ld.w	r0,r8[0x0]
80002c9c:	1a d0       	st.w	--sp,r0
80002c9e:	f0 1f 00 1a 	mcall	80002d04 <LABEL_RET_SCALL_260+0x14>
80002ca2:	e0 68 07 0c 	mov	r8,1804
80002ca6:	ea 18 00 00 	orh	r8,0x0
80002caa:	70 00       	ld.w	r0,r8[0x0]
80002cac:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80002cae:	f0 1f 00 17 	mcall	80002d08 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80002cb2:	e0 68 07 0c 	mov	r8,1804
80002cb6:	ea 18 00 00 	orh	r8,0x0
80002cba:	70 00       	ld.w	r0,r8[0x0]
80002cbc:	60 0d       	ld.w	sp,r0[0x0]
80002cbe:	1b 00       	ld.w	r0,sp++
80002cc0:	e0 68 00 20 	mov	r8,32
80002cc4:	ea 18 00 00 	orh	r8,0x0
80002cc8:	91 00       	st.w	r8[0x0],r0
80002cca:	fa c7 ff d8 	sub	r7,sp,-40
80002cce:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80002cd2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80002cd6:	e0 61 00 20 	mov	r1,32
80002cda:	ea 11 00 00 	orh	r1,0x0
80002cde:	62 02       	ld.w	r2,r1[0x0]
80002ce0:	58 02       	cp.w	r2,0
80002ce2:	c0 70       	breq	80002cf0 <LABEL_RET_SCALL_260>
80002ce4:	e4 c2 00 01 	sub	r2,r2,1
80002ce8:	83 02       	st.w	r1[0x0],r2
80002cea:	58 02       	cp.w	r2,0
80002cec:	c0 21       	brne	80002cf0 <LABEL_RET_SCALL_260>
80002cee:	b1 c0       	cbr	r0,0x10

80002cf0 <LABEL_RET_SCALL_260>:
80002cf0:	ef 40 ff f8 	st.w	r7[-8],r0
80002cf4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80002cf8:	ef 40 ff fc 	st.w	r7[-4],r0
80002cfc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80002d00:	2f ad       	sub	sp,-24
80002d02:	d6 13       	rets
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	2c 64       	sub	r4,-58
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	31 a0       	mov	r0,26

80002d0c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80002d0c:	48 78       	lddpc	r8,80002d28 <vPortExitCritical+0x1c>
80002d0e:	70 08       	ld.w	r8,r8[0x0]
80002d10:	58 08       	cp.w	r8,0
80002d12:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80002d14:	48 58       	lddpc	r8,80002d28 <vPortExitCritical+0x1c>
80002d16:	70 09       	ld.w	r9,r8[0x0]
80002d18:	20 19       	sub	r9,1
80002d1a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80002d1c:	70 08       	ld.w	r8,r8[0x0]
80002d1e:	58 08       	cp.w	r8,0
80002d20:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80002d22:	d5 03       	csrf	0x10
80002d24:	5e fc       	retal	r12
80002d26:	00 00       	add	r0,r0
80002d28:	00 00       	add	r0,r0
80002d2a:	00 20       	rsub	r0,r0

80002d2c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80002d2c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80002d2e:	f0 1f 00 02 	mcall	80002d34 <__malloc_lock+0x8>
}
80002d32:	d8 02       	popm	pc
80002d34:	80 00       	ld.sh	r0,r0[0x0]
80002d36:	31 90       	mov	r0,25

80002d38 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80002d38:	d4 01       	pushm	lr
	xTaskResumeAll();
80002d3a:	f0 1f 00 02 	mcall	80002d40 <__malloc_unlock+0x8>
}
80002d3e:	d8 02       	popm	pc
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	34 40       	mov	r0,68

80002d44 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80002d44:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80002d46:	48 a8       	lddpc	r8,80002d6c <_init_startup+0x28>
80002d48:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80002d4c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
80002d4e:	f0 1f 00 09 	mcall	80002d70 <_init_startup+0x2c>

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002d52:	48 98       	lddpc	r8,80002d74 <_init_startup+0x30>
80002d54:	48 99       	lddpc	r9,80002d78 <_init_startup+0x34>
80002d56:	12 38       	cp.w	r8,r9
80002d58:	c0 82       	brcc	80002d68 <_init_startup+0x24>
		{
			*pxMem++ = 0xA5A5A5A5;
80002d5a:	e0 6a a5 a5 	mov	r10,42405
80002d5e:	ea 1a a5 a5 	orh	r10,0xa5a5
80002d62:	10 aa       	st.w	r8++,r10
	INTC_init_interrupts();

	#if configHEAP_INIT

		/* Initialize the heap used by malloc. */
		for( pxMem = &__heap_start__; pxMem < ( portBASE_TYPE * )&__heap_end__; )
80002d64:	12 38       	cp.w	r8,r9
80002d66:	cf e3       	brcs	80002d62 <_init_startup+0x1e>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80002d68:	da 0a       	popm	pc,r12=1
80002d6a:	00 00       	add	r0,r0
80002d6c:	80 00       	ld.sh	r0,r0[0x0]
80002d6e:	44 00       	lddsp	r0,sp[0x100]
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	27 68       	sub	r8,118
80002d74:	00 00       	add	r0,r0
80002d76:	07 98       	ld.ub	r8,r3[0x1]
80002d78:	00 00       	add	r0,r0
80002d7a:	f0 00       	*unknown*

80002d7c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80002d7c:	eb cd 40 80 	pushm	r7,lr
80002d80:	18 97       	mov	r7,r12
	if( pv )
80002d82:	58 0c       	cp.w	r12,0
80002d84:	c0 80       	breq	80002d94 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80002d86:	f0 1f 00 05 	mcall	80002d98 <vPortFree+0x1c>
		{
			free( pv );
80002d8a:	0e 9c       	mov	r12,r7
80002d8c:	f0 1f 00 04 	mcall	80002d9c <vPortFree+0x20>
		}
		xTaskResumeAll();
80002d90:	f0 1f 00 04 	mcall	80002da0 <vPortFree+0x24>
80002d94:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	31 90       	mov	r0,25
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	39 f4       	mov	r4,-97
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	34 40       	mov	r0,68

80002da4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002da4:	eb cd 40 80 	pushm	r7,lr
80002da8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80002daa:	f0 1f 00 06 	mcall	80002dc0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80002dae:	0e 9c       	mov	r12,r7
80002db0:	f0 1f 00 05 	mcall	80002dc4 <pvPortMalloc+0x20>
80002db4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80002db6:	f0 1f 00 05 	mcall	80002dc8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80002dba:	0e 9c       	mov	r12,r7
80002dbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002dc0:	80 00       	ld.sh	r0,r0[0x0]
80002dc2:	31 90       	mov	r0,25
80002dc4:	80 00       	ld.sh	r0,r0[0x0]
80002dc6:	3a 04       	mov	r4,-96
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	34 40       	mov	r0,68

80002dcc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80002dcc:	d4 01       	pushm	lr
80002dce:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002dd0:	78 09       	ld.w	r9,r12[0x0]
80002dd2:	58 09       	cp.w	r9,0
80002dd4:	c1 10       	breq	80002df6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80002dd6:	78 3a       	ld.w	r10,r12[0xc]
80002dd8:	79 09       	ld.w	r9,r12[0x40]
80002dda:	f4 09 00 09 	add	r9,r10,r9
80002dde:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80002de0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80002de2:	14 39       	cp.w	r9,r10
80002de4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002de8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80002dec:	79 0a       	ld.w	r10,r12[0x40]
80002dee:	78 3b       	ld.w	r11,r12[0xc]
80002df0:	10 9c       	mov	r12,r8
80002df2:	f0 1f 00 02 	mcall	80002df8 <prvCopyDataFromQueue+0x2c>
80002df6:	d8 02       	popm	pc
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	3e 48       	mov	r8,-28

80002dfc <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002dfc:	eb cd 40 80 	pushm	r7,lr
80002e00:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002e02:	79 08       	ld.w	r8,r12[0x40]
80002e04:	58 08       	cp.w	r8,0
80002e06:	c2 50       	breq	80002e50 <prvCopyDataToQueue+0x54>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80002e08:	58 0a       	cp.w	r10,0
80002e0a:	c1 01       	brne	80002e2a <prvCopyDataToQueue+0x2e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e0c:	10 9a       	mov	r10,r8
80002e0e:	78 2c       	ld.w	r12,r12[0x8]
80002e10:	f0 1f 00 13 	mcall	80002e5c <prvCopyDataToQueue+0x60>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002e14:	6e 29       	ld.w	r9,r7[0x8]
80002e16:	6f 08       	ld.w	r8,r7[0x40]
80002e18:	f2 08 00 08 	add	r8,r9,r8
80002e1c:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80002e1e:	6e 19       	ld.w	r9,r7[0x4]
80002e20:	12 38       	cp.w	r8,r9
80002e22:	c1 73       	brcs	80002e50 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002e24:	6e 08       	ld.w	r8,r7[0x0]
80002e26:	8f 28       	st.w	r7[0x8],r8
80002e28:	c1 48       	rjmp	80002e50 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80002e2a:	10 9a       	mov	r10,r8
80002e2c:	78 3c       	ld.w	r12,r12[0xc]
80002e2e:	f0 1f 00 0c 	mcall	80002e5c <prvCopyDataToQueue+0x60>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80002e32:	6f 08       	ld.w	r8,r7[0x40]
80002e34:	6e 39       	ld.w	r9,r7[0xc]
80002e36:	f2 08 01 08 	sub	r8,r9,r8
80002e3a:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80002e3c:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002e3e:	12 38       	cp.w	r8,r9
80002e40:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002e44:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002e48:	f3 d8 e3 19 	subcs	r9,r9,r8
80002e4c:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002e50:	6e e8       	ld.w	r8,r7[0x38]
80002e52:	2f f8       	sub	r8,-1
80002e54:	8f e8       	st.w	r7[0x38],r8
}
80002e56:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e5a:	00 00       	add	r0,r0
80002e5c:	80 00       	ld.sh	r0,r0[0x0]
80002e5e:	3e 48       	mov	r8,-28

80002e60 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80002e60:	eb cd 40 c0 	pushm	r6-r7,lr
80002e64:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002e66:	f0 1f 00 23 	mcall	80002ef0 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002e6a:	6f 28       	ld.w	r8,r7[0x48]
80002e6c:	58 08       	cp.w	r8,0
80002e6e:	e0 8a 00 18 	brle	80002e9e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002e72:	6e 98       	ld.w	r8,r7[0x24]
80002e74:	58 08       	cp.w	r8,0
80002e76:	c1 40       	breq	80002e9e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002e78:	ee c6 ff dc 	sub	r6,r7,-36
80002e7c:	c0 48       	rjmp	80002e84 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002e7e:	6e 98       	ld.w	r8,r7[0x24]
80002e80:	58 08       	cp.w	r8,0
80002e82:	c0 e0       	breq	80002e9e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002e84:	0c 9c       	mov	r12,r6
80002e86:	f0 1f 00 1c 	mcall	80002ef4 <prvUnlockQueue+0x94>
80002e8a:	c0 30       	breq	80002e90 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80002e8c:	f0 1f 00 1b 	mcall	80002ef8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80002e90:	6f 28       	ld.w	r8,r7[0x48]
80002e92:	20 18       	sub	r8,1
80002e94:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002e98:	58 08       	cp.w	r8,0
80002e9a:	fe 99 ff f2 	brgt	80002e7e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002e9e:	3f f8       	mov	r8,-1
80002ea0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002ea4:	f0 1f 00 16 	mcall	80002efc <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002ea8:	f0 1f 00 12 	mcall	80002ef0 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002eac:	6f 18       	ld.w	r8,r7[0x44]
80002eae:	58 08       	cp.w	r8,0
80002eb0:	e0 8a 00 18 	brle	80002ee0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002eb4:	6e 48       	ld.w	r8,r7[0x10]
80002eb6:	58 08       	cp.w	r8,0
80002eb8:	c1 40       	breq	80002ee0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002eba:	ee c6 ff f0 	sub	r6,r7,-16
80002ebe:	c0 48       	rjmp	80002ec6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002ec0:	6e 48       	ld.w	r8,r7[0x10]
80002ec2:	58 08       	cp.w	r8,0
80002ec4:	c0 e0       	breq	80002ee0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002ec6:	0c 9c       	mov	r12,r6
80002ec8:	f0 1f 00 0b 	mcall	80002ef4 <prvUnlockQueue+0x94>
80002ecc:	c0 30       	breq	80002ed2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80002ece:	f0 1f 00 0b 	mcall	80002ef8 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80002ed2:	6f 18       	ld.w	r8,r7[0x44]
80002ed4:	20 18       	sub	r8,1
80002ed6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002eda:	58 08       	cp.w	r8,0
80002edc:	fe 99 ff f2 	brgt	80002ec0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002ee0:	3f f8       	mov	r8,-1
80002ee2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002ee6:	f0 1f 00 06 	mcall	80002efc <prvUnlockQueue+0x9c>
}
80002eea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eee:	00 00       	add	r0,r0
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	2c 64       	sub	r4,-58
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	32 b0       	mov	r0,43
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	32 34       	mov	r4,35
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	2d 0c       	sub	r12,-48

80002f00 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002f00:	d4 31       	pushm	r0-r7,lr
80002f02:	20 5d       	sub	sp,20
80002f04:	18 97       	mov	r7,r12
80002f06:	50 0b       	stdsp	sp[0x0],r11
80002f08:	50 2a       	stdsp	sp[0x8],r10
80002f0a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002f0c:	f8 c1 ff dc 	sub	r1,r12,-36
80002f10:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f12:	fa c4 ff f4 	sub	r4,sp,-12
80002f16:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002f18:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002f1a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002f1e:	f0 1f 00 36 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002f22:	6e e8       	ld.w	r8,r7[0x38]
80002f24:	58 08       	cp.w	r8,0
80002f26:	c2 40       	breq	80002f6e <xQueueGenericReceive+0x6e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80002f28:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002f2a:	40 0b       	lddsp	r11,sp[0x0]
80002f2c:	0e 9c       	mov	r12,r7
80002f2e:	f0 1f 00 33 	mcall	80002ff8 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002f32:	40 18       	lddsp	r8,sp[0x4]
80002f34:	58 08       	cp.w	r8,0
80002f36:	c0 f1       	brne	80002f54 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80002f38:	6e e8       	ld.w	r8,r7[0x38]
80002f3a:	20 18       	sub	r8,1
80002f3c:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002f3e:	6e 48       	ld.w	r8,r7[0x10]
80002f40:	58 08       	cp.w	r8,0
80002f42:	c1 20       	breq	80002f66 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002f44:	ee cc ff f0 	sub	r12,r7,-16
80002f48:	f0 1f 00 2d 	mcall	80002ffc <xQueueGenericReceive+0xfc>
80002f4c:	58 1c       	cp.w	r12,1
80002f4e:	c0 c1       	brne	80002f66 <xQueueGenericReceive+0x66>
						{
							portYIELD_WITHIN_API();
80002f50:	d7 33       	scall
80002f52:	c0 a8       	rjmp	80002f66 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80002f54:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002f56:	6e 98       	ld.w	r8,r7[0x24]
80002f58:	58 08       	cp.w	r8,0
80002f5a:	c0 60       	breq	80002f66 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002f5c:	02 9c       	mov	r12,r1
80002f5e:	f0 1f 00 28 	mcall	80002ffc <xQueueGenericReceive+0xfc>
80002f62:	c0 20       	breq	80002f66 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80002f64:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80002f66:	f0 1f 00 27 	mcall	80003000 <xQueueGenericReceive+0x100>
80002f6a:	30 1c       	mov	r12,1
				return pdPASS;
80002f6c:	c4 28       	rjmp	80002ff0 <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002f6e:	40 28       	lddsp	r8,sp[0x8]
80002f70:	58 08       	cp.w	r8,0
80002f72:	c0 51       	brne	80002f7c <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002f74:	f0 1f 00 23 	mcall	80003000 <xQueueGenericReceive+0x100>
80002f78:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002f7a:	c3 b8       	rjmp	80002ff0 <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002f7c:	58 05       	cp.w	r5,0
80002f7e:	c0 51       	brne	80002f88 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f80:	08 9c       	mov	r12,r4
80002f82:	f0 1f 00 21 	mcall	80003004 <xQueueGenericReceive+0x104>
80002f86:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80002f88:	f0 1f 00 1e 	mcall	80003000 <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002f8c:	f0 1f 00 1f 	mcall	80003008 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002f90:	f0 1f 00 19 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
80002f94:	6f 18       	ld.w	r8,r7[0x44]
80002f96:	5b f8       	cp.w	r8,-1
80002f98:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002f9c:	6f 28       	ld.w	r8,r7[0x48]
80002f9e:	5b f8       	cp.w	r8,-1
80002fa0:	ef f2 0a 12 	st.weq	r7[0x48],r2
80002fa4:	f0 1f 00 17 	mcall	80003000 <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002fa8:	06 9b       	mov	r11,r3
80002faa:	08 9c       	mov	r12,r4
80002fac:	f0 1f 00 18 	mcall	8000300c <xQueueGenericReceive+0x10c>
80002fb0:	c1 a1       	brne	80002fe4 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002fb2:	f0 1f 00 11 	mcall	80002ff4 <xQueueGenericReceive+0xf4>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80002fb6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80002fb8:	f0 1f 00 12 	mcall	80003000 <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80002fbc:	58 06       	cp.w	r6,0
80002fbe:	c0 d1       	brne	80002fd8 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002fc0:	40 2b       	lddsp	r11,sp[0x8]
80002fc2:	02 9c       	mov	r12,r1
80002fc4:	f0 1f 00 13 	mcall	80003010 <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80002fc8:	0e 9c       	mov	r12,r7
80002fca:	f0 1f 00 13 	mcall	80003014 <xQueueGenericReceive+0x114>
				if( !xTaskResumeAll() )
80002fce:	f0 1f 00 13 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fd2:	ca 61       	brne	80002f1e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80002fd4:	d7 33       	scall
80002fd6:	ca 4b       	rjmp	80002f1e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002fd8:	0e 9c       	mov	r12,r7
80002fda:	f0 1f 00 0f 	mcall	80003014 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
80002fde:	f0 1f 00 0f 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fe2:	c9 eb       	rjmp	80002f1e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80002fe4:	0e 9c       	mov	r12,r7
80002fe6:	f0 1f 00 0c 	mcall	80003014 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80002fea:	f0 1f 00 0c 	mcall	80003018 <xQueueGenericReceive+0x118>
80002fee:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80002ff0:	2f bd       	sub	sp,-20
80002ff2:	d8 32       	popm	r0-r7,pc
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	2c 64       	sub	r4,-58
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	2d cc       	sub	r12,-36
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	32 b0       	mov	r0,43
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	2d 0c       	sub	r12,-48
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	32 1c       	mov	r12,33
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	31 90       	mov	r0,25
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	32 40       	mov	r0,36
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	35 84       	mov	r4,88
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	2e 60       	sub	r0,-26
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	34 40       	mov	r0,68

8000301c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000301c:	d4 31       	pushm	r0-r7,lr
8000301e:	20 5d       	sub	sp,20
80003020:	18 97       	mov	r7,r12
80003022:	50 0b       	stdsp	sp[0x0],r11
80003024:	50 2a       	stdsp	sp[0x8],r10
80003026:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80003028:	f8 c0 ff f0 	sub	r0,r12,-16
8000302c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000302e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80003032:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80003034:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80003038:	f0 1f 00 2f 	mcall	800030f4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000303c:	6e e9       	ld.w	r9,r7[0x38]
8000303e:	6e f8       	ld.w	r8,r7[0x3c]
80003040:	10 39       	cp.w	r9,r8
80003042:	c1 42       	brcc	8000306a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80003044:	40 1a       	lddsp	r10,sp[0x4]
80003046:	40 0b       	lddsp	r11,sp[0x0]
80003048:	0e 9c       	mov	r12,r7
8000304a:	f0 1f 00 2c 	mcall	800030f8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000304e:	6e 98       	ld.w	r8,r7[0x24]
80003050:	58 08       	cp.w	r8,0
80003052:	c0 80       	breq	80003062 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80003054:	ee cc ff dc 	sub	r12,r7,-36
80003058:	f0 1f 00 29 	mcall	800030fc <xQueueGenericSend+0xe0>
8000305c:	58 1c       	cp.w	r12,1
8000305e:	c0 21       	brne	80003062 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80003060:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80003062:	f0 1f 00 28 	mcall	80003100 <xQueueGenericSend+0xe4>
80003066:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80003068:	c4 38       	rjmp	800030ee <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000306a:	40 28       	lddsp	r8,sp[0x8]
8000306c:	58 08       	cp.w	r8,0
8000306e:	c0 51       	brne	80003078 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80003070:	f0 1f 00 24 	mcall	80003100 <xQueueGenericSend+0xe4>
80003074:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80003076:	c3 c8       	rjmp	800030ee <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80003078:	58 04       	cp.w	r4,0
8000307a:	c0 51       	brne	80003084 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000307c:	06 9c       	mov	r12,r3
8000307e:	f0 1f 00 22 	mcall	80003104 <xQueueGenericSend+0xe8>
80003082:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80003084:	f0 1f 00 1f 	mcall	80003100 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80003088:	f0 1f 00 20 	mcall	80003108 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000308c:	f0 1f 00 1a 	mcall	800030f4 <xQueueGenericSend+0xd8>
80003090:	6f 18       	ld.w	r8,r7[0x44]
80003092:	5b f8       	cp.w	r8,-1
80003094:	ef f1 0a 11 	st.weq	r7[0x44],r1
80003098:	6f 28       	ld.w	r8,r7[0x48]
8000309a:	5b f8       	cp.w	r8,-1
8000309c:	ef f1 0a 12 	st.weq	r7[0x48],r1
800030a0:	f0 1f 00 18 	mcall	80003100 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800030a4:	04 9b       	mov	r11,r2
800030a6:	06 9c       	mov	r12,r3
800030a8:	f0 1f 00 19 	mcall	8000310c <xQueueGenericSend+0xf0>
800030ac:	c1 b1       	brne	800030e2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800030ae:	f0 1f 00 12 	mcall	800030f4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800030b2:	6e e5       	ld.w	r5,r7[0x38]
800030b4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800030b6:	f0 1f 00 13 	mcall	80003100 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800030ba:	0c 35       	cp.w	r5,r6
800030bc:	c0 d1       	brne	800030d6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800030be:	40 2b       	lddsp	r11,sp[0x8]
800030c0:	00 9c       	mov	r12,r0
800030c2:	f0 1f 00 14 	mcall	80003110 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800030c6:	0e 9c       	mov	r12,r7
800030c8:	f0 1f 00 13 	mcall	80003114 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800030cc:	f0 1f 00 13 	mcall	80003118 <xQueueGenericSend+0xfc>
800030d0:	cb 41       	brne	80003038 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800030d2:	d7 33       	scall
800030d4:	cb 2b       	rjmp	80003038 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800030d6:	0e 9c       	mov	r12,r7
800030d8:	f0 1f 00 0f 	mcall	80003114 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800030dc:	f0 1f 00 0f 	mcall	80003118 <xQueueGenericSend+0xfc>
800030e0:	ca cb       	rjmp	80003038 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800030e2:	0e 9c       	mov	r12,r7
800030e4:	f0 1f 00 0c 	mcall	80003114 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800030e8:	f0 1f 00 0c 	mcall	80003118 <xQueueGenericSend+0xfc>
800030ec:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800030ee:	2f bd       	sub	sp,-20
800030f0:	d8 32       	popm	r0-r7,pc
800030f2:	00 00       	add	r0,r0
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	2c 64       	sub	r4,-58
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2d fc       	sub	r12,-33
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	32 b0       	mov	r0,43
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2d 0c       	sub	r12,-48
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	32 1c       	mov	r12,33
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	31 90       	mov	r0,25
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	32 40       	mov	r0,36
80003110:	80 00       	ld.sh	r0,r0[0x0]
80003112:	35 84       	mov	r4,88
80003114:	80 00       	ld.sh	r0,r0[0x0]
80003116:	2e 60       	sub	r0,-26
80003118:	80 00       	ld.sh	r0,r0[0x0]
8000311a:	34 40       	mov	r0,68

8000311c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000311c:	d4 21       	pushm	r4-r7,lr
8000311e:	18 97       	mov	r7,r12
80003120:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80003122:	58 0c       	cp.w	r12,0
80003124:	c2 f0       	breq	80003182 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003126:	34 cc       	mov	r12,76
80003128:	f0 1f 00 17 	mcall	80003184 <xQueueCreate+0x68>
8000312c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000312e:	c2 a0       	breq	80003182 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80003130:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80003134:	e8 cc ff ff 	sub	r12,r4,-1
80003138:	f0 1f 00 13 	mcall	80003184 <xQueueCreate+0x68>
8000313c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000313e:	c1 e0       	breq	8000317a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80003140:	f8 04 00 04 	add	r4,r12,r4
80003144:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80003146:	30 08       	mov	r8,0
80003148:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000314a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000314c:	ee c8 00 01 	sub	r8,r7,1
80003150:	ad 38       	mul	r8,r6
80003152:	10 0c       	add	r12,r8
80003154:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80003156:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80003158:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000315c:	3f f8       	mov	r8,-1
8000315e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80003162:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80003166:	ea cc ff f0 	sub	r12,r5,-16
8000316a:	f0 1f 00 08 	mcall	80003188 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000316e:	ea cc ff dc 	sub	r12,r5,-36
80003172:	f0 1f 00 06 	mcall	80003188 <xQueueCreate+0x6c>
80003176:	0a 9c       	mov	r12,r5
80003178:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000317a:	0a 9c       	mov	r12,r5
8000317c:	f0 1f 00 04 	mcall	8000318c <xQueueCreate+0x70>
80003180:	d8 2a       	popm	r4-r7,pc,r12=0
80003182:	d8 2a       	popm	r4-r7,pc,r12=0
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	2d a4       	sub	r4,-38
80003188:	80 00       	ld.sh	r0,r0[0x0]
8000318a:	2b d8       	sub	r8,-67
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	2d 7c       	sub	r12,-41

80003190 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80003190:	48 38       	lddpc	r8,8000319c <vTaskSuspendAll+0xc>
80003192:	70 09       	ld.w	r9,r8[0x0]
80003194:	2f f9       	sub	r9,-1
80003196:	91 09       	st.w	r8[0x0],r9
}
80003198:	5e fc       	retal	r12
8000319a:	00 00       	add	r0,r0
8000319c:	00 00       	add	r0,r0
8000319e:	07 28       	ld.uh	r8,r3++

800031a0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800031a0:	49 a8       	lddpc	r8,80003208 <vTaskSwitchContext+0x68>
800031a2:	70 08       	ld.w	r8,r8[0x0]
800031a4:	58 08       	cp.w	r8,0
800031a6:	c0 b1       	brne	800031bc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031a8:	49 98       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>
800031aa:	70 08       	ld.w	r8,r8[0x0]
800031ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800031b0:	49 89       	lddpc	r9,80003210 <vTaskSwitchContext+0x70>
800031b2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800031b6:	58 08       	cp.w	r8,0
800031b8:	c0 60       	breq	800031c4 <vTaskSwitchContext+0x24>
800031ba:	c1 18       	rjmp	800031dc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800031bc:	30 19       	mov	r9,1
800031be:	49 68       	lddpc	r8,80003214 <vTaskSwitchContext+0x74>
800031c0:	91 09       	st.w	r8[0x0],r9
800031c2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800031c4:	49 28       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031c6:	49 3a       	lddpc	r10,80003210 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800031c8:	70 09       	ld.w	r9,r8[0x0]
800031ca:	20 19       	sub	r9,1
800031cc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800031ce:	70 09       	ld.w	r9,r8[0x0]
800031d0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800031d4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800031d8:	58 09       	cp.w	r9,0
800031da:	cf 70       	breq	800031c8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800031dc:	48 c8       	lddpc	r8,8000320c <vTaskSwitchContext+0x6c>
800031de:	70 08       	ld.w	r8,r8[0x0]
800031e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800031e4:	48 b9       	lddpc	r9,80003210 <vTaskSwitchContext+0x70>
800031e6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800031ea:	70 19       	ld.w	r9,r8[0x4]
800031ec:	72 19       	ld.w	r9,r9[0x4]
800031ee:	91 19       	st.w	r8[0x4],r9
800031f0:	f0 ca ff f8 	sub	r10,r8,-8
800031f4:	14 39       	cp.w	r9,r10
800031f6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800031fa:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800031fe:	70 18       	ld.w	r8,r8[0x4]
80003200:	70 39       	ld.w	r9,r8[0xc]
80003202:	48 68       	lddpc	r8,80003218 <vTaskSwitchContext+0x78>
80003204:	91 09       	st.w	r8[0x0],r9
80003206:	5e fc       	retal	r12
80003208:	00 00       	add	r0,r0
8000320a:	07 28       	ld.uh	r8,r3++
8000320c:	00 00       	add	r0,r0
8000320e:	07 48       	ld.w	r8,--r3
80003210:	00 00       	add	r0,r0
80003212:	06 6c       	and	r12,r3
80003214:	00 00       	add	r0,r0
80003216:	07 30       	ld.ub	r0,r3++
80003218:	00 00       	add	r0,r0
8000321a:	07 0c       	ld.w	r12,r3++

8000321c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000321c:	48 48       	lddpc	r8,8000322c <vTaskSetTimeOutState+0x10>
8000321e:	70 08       	ld.w	r8,r8[0x0]
80003220:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80003222:	48 48       	lddpc	r8,80003230 <vTaskSetTimeOutState+0x14>
80003224:	70 08       	ld.w	r8,r8[0x0]
80003226:	99 18       	st.w	r12[0x4],r8
}
80003228:	5e fc       	retal	r12
8000322a:	00 00       	add	r0,r0
8000322c:	00 00       	add	r0,r0
8000322e:	06 64       	and	r4,r3
80003230:	00 00       	add	r0,r0
80003232:	07 24       	ld.uh	r4,r3++

80003234 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80003234:	30 19       	mov	r9,1
80003236:	48 28       	lddpc	r8,8000323c <vTaskMissedYield+0x8>
80003238:	91 09       	st.w	r8[0x0],r9
}
8000323a:	5e fc       	retal	r12
8000323c:	00 00       	add	r0,r0
8000323e:	07 30       	ld.ub	r0,r3++

80003240 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80003240:	eb cd 40 c0 	pushm	r6-r7,lr
80003244:	18 97       	mov	r7,r12
80003246:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80003248:	f0 1f 00 15 	mcall	8000329c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000324c:	6c 08       	ld.w	r8,r6[0x0]
8000324e:	5b f8       	cp.w	r8,-1
80003250:	c0 31       	brne	80003256 <xTaskCheckForTimeOut+0x16>
80003252:	30 07       	mov	r7,0
80003254:	c1 f8       	rjmp	80003292 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80003256:	49 39       	lddpc	r9,800032a0 <xTaskCheckForTimeOut+0x60>
80003258:	72 09       	ld.w	r9,r9[0x0]
8000325a:	6e 0a       	ld.w	r10,r7[0x0]
8000325c:	12 3a       	cp.w	r10,r9
8000325e:	c0 70       	breq	8000326c <xTaskCheckForTimeOut+0x2c>
80003260:	49 19       	lddpc	r9,800032a4 <xTaskCheckForTimeOut+0x64>
80003262:	72 09       	ld.w	r9,r9[0x0]
80003264:	6e 1a       	ld.w	r10,r7[0x4]
80003266:	12 3a       	cp.w	r10,r9
80003268:	e0 88 00 14 	brls	80003290 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000326c:	48 e9       	lddpc	r9,800032a4 <xTaskCheckForTimeOut+0x64>
8000326e:	72 0a       	ld.w	r10,r9[0x0]
80003270:	6e 19       	ld.w	r9,r7[0x4]
80003272:	12 1a       	sub	r10,r9
80003274:	14 38       	cp.w	r8,r10
80003276:	e0 88 00 0d 	brls	80003290 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000327a:	48 ba       	lddpc	r10,800032a4 <xTaskCheckForTimeOut+0x64>
8000327c:	74 0a       	ld.w	r10,r10[0x0]
8000327e:	14 19       	sub	r9,r10
80003280:	f2 08 00 08 	add	r8,r9,r8
80003284:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80003286:	0e 9c       	mov	r12,r7
80003288:	f0 1f 00 08 	mcall	800032a8 <xTaskCheckForTimeOut+0x68>
8000328c:	30 07       	mov	r7,0
8000328e:	c0 28       	rjmp	80003292 <xTaskCheckForTimeOut+0x52>
80003290:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80003292:	f0 1f 00 07 	mcall	800032ac <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80003296:	0e 9c       	mov	r12,r7
80003298:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	2c 64       	sub	r4,-58
800032a0:	00 00       	add	r0,r0
800032a2:	06 64       	and	r4,r3
800032a4:	00 00       	add	r0,r0
800032a6:	07 24       	ld.uh	r4,r3++
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	32 1c       	mov	r12,33
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	2d 0c       	sub	r12,-48

800032b0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800032b0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800032b4:	78 38       	ld.w	r8,r12[0xc]
800032b6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800032b8:	ee c6 ff e8 	sub	r6,r7,-24
800032bc:	0c 9c       	mov	r12,r6
800032be:	f0 1f 00 15 	mcall	80003310 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800032c2:	49 58       	lddpc	r8,80003314 <xTaskRemoveFromEventList+0x64>
800032c4:	70 08       	ld.w	r8,r8[0x0]
800032c6:	58 08       	cp.w	r8,0
800032c8:	c1 71       	brne	800032f6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800032ca:	ee c6 ff fc 	sub	r6,r7,-4
800032ce:	0c 9c       	mov	r12,r6
800032d0:	f0 1f 00 10 	mcall	80003310 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800032d4:	6e bc       	ld.w	r12,r7[0x2c]
800032d6:	49 18       	lddpc	r8,80003318 <xTaskRemoveFromEventList+0x68>
800032d8:	70 08       	ld.w	r8,r8[0x0]
800032da:	10 3c       	cp.w	r12,r8
800032dc:	e0 88 00 04 	brls	800032e4 <xTaskRemoveFromEventList+0x34>
800032e0:	48 e8       	lddpc	r8,80003318 <xTaskRemoveFromEventList+0x68>
800032e2:	91 0c       	st.w	r8[0x0],r12
800032e4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800032e8:	0c 9b       	mov	r11,r6
800032ea:	48 d8       	lddpc	r8,8000331c <xTaskRemoveFromEventList+0x6c>
800032ec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800032f0:	f0 1f 00 0c 	mcall	80003320 <xTaskRemoveFromEventList+0x70>
800032f4:	c0 58       	rjmp	800032fe <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800032f6:	0c 9b       	mov	r11,r6
800032f8:	48 bc       	lddpc	r12,80003324 <xTaskRemoveFromEventList+0x74>
800032fa:	f0 1f 00 0a 	mcall	80003320 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800032fe:	48 b8       	lddpc	r8,80003328 <xTaskRemoveFromEventList+0x78>
80003300:	70 08       	ld.w	r8,r8[0x0]
80003302:	6e b9       	ld.w	r9,r7[0x2c]
80003304:	70 b8       	ld.w	r8,r8[0x2c]
80003306:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80003308:	5f 2c       	srhs	r12
8000330a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000330e:	00 00       	add	r0,r0
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	2c 3c       	sub	r12,-61
80003314:	00 00       	add	r0,r0
80003316:	07 28       	ld.uh	r8,r3++
80003318:	00 00       	add	r0,r0
8000331a:	07 48       	ld.w	r8,--r3
8000331c:	00 00       	add	r0,r0
8000331e:	06 6c       	and	r12,r3
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	2b ec       	sub	r12,-66
80003324:	00 00       	add	r0,r0
80003326:	07 10       	ld.sh	r0,r3++
80003328:	00 00       	add	r0,r0
8000332a:	07 0c       	ld.w	r12,r3++

8000332c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000332c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003330:	4b 98       	lddpc	r8,80003414 <vTaskIncrementTick+0xe8>
80003332:	70 08       	ld.w	r8,r8[0x0]
80003334:	58 08       	cp.w	r8,0
80003336:	c6 91       	brne	80003408 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80003338:	4b 88       	lddpc	r8,80003418 <vTaskIncrementTick+0xec>
8000333a:	70 09       	ld.w	r9,r8[0x0]
8000333c:	2f f9       	sub	r9,-1
8000333e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80003340:	70 08       	ld.w	r8,r8[0x0]
80003342:	58 08       	cp.w	r8,0
80003344:	c1 a1       	brne	80003378 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80003346:	4b 68       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003348:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000334a:	4b 69       	lddpc	r9,80003420 <vTaskIncrementTick+0xf4>
8000334c:	72 0b       	ld.w	r11,r9[0x0]
8000334e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80003350:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80003352:	4b 59       	lddpc	r9,80003424 <vTaskIncrementTick+0xf8>
80003354:	72 0a       	ld.w	r10,r9[0x0]
80003356:	2f fa       	sub	r10,-1
80003358:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000335a:	70 08       	ld.w	r8,r8[0x0]
8000335c:	70 08       	ld.w	r8,r8[0x0]
8000335e:	58 08       	cp.w	r8,0
80003360:	c0 51       	brne	8000336a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80003362:	3f f9       	mov	r9,-1
80003364:	4b 18       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
80003366:	91 09       	st.w	r8[0x0],r9
80003368:	c0 88       	rjmp	80003378 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000336a:	4a d8       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
8000336c:	70 08       	ld.w	r8,r8[0x0]
8000336e:	70 38       	ld.w	r8,r8[0xc]
80003370:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80003372:	70 19       	ld.w	r9,r8[0x4]
80003374:	4a d8       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
80003376:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80003378:	4a 88       	lddpc	r8,80003418 <vTaskIncrementTick+0xec>
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	4a b8       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
8000337e:	70 08       	ld.w	r8,r8[0x0]
80003380:	10 39       	cp.w	r9,r8
80003382:	c4 73       	brcs	80003410 <vTaskIncrementTick+0xe4>
80003384:	4a 68       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003386:	70 08       	ld.w	r8,r8[0x0]
80003388:	70 08       	ld.w	r8,r8[0x0]
8000338a:	58 08       	cp.w	r8,0
8000338c:	c0 c0       	breq	800033a4 <vTaskIncrementTick+0x78>
8000338e:	4a 48       	lddpc	r8,8000341c <vTaskIncrementTick+0xf0>
80003390:	70 08       	ld.w	r8,r8[0x0]
80003392:	70 38       	ld.w	r8,r8[0xc]
80003394:	70 37       	ld.w	r7,r8[0xc]
80003396:	6e 18       	ld.w	r8,r7[0x4]
80003398:	4a 09       	lddpc	r9,80003418 <vTaskIncrementTick+0xec>
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	12 38       	cp.w	r8,r9
8000339e:	e0 88 00 14 	brls	800033c6 <vTaskIncrementTick+0x9a>
800033a2:	c0 e8       	rjmp	800033be <vTaskIncrementTick+0x92>
800033a4:	3f f9       	mov	r9,-1
800033a6:	4a 18       	lddpc	r8,80003428 <vTaskIncrementTick+0xfc>
800033a8:	91 09       	st.w	r8[0x0],r9
800033aa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800033ae:	6a 08       	ld.w	r8,r5[0x0]
800033b0:	70 38       	ld.w	r8,r8[0xc]
800033b2:	70 37       	ld.w	r7,r8[0xc]
800033b4:	6e 18       	ld.w	r8,r7[0x4]
800033b6:	64 09       	ld.w	r9,r2[0x0]
800033b8:	12 38       	cp.w	r8,r9
800033ba:	e0 88 00 0a 	brls	800033ce <vTaskIncrementTick+0xa2>
800033be:	49 b9       	lddpc	r9,80003428 <vTaskIncrementTick+0xfc>
800033c0:	93 08       	st.w	r9[0x0],r8
800033c2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800033c6:	49 a4       	lddpc	r4,8000342c <vTaskIncrementTick+0x100>
800033c8:	49 a3       	lddpc	r3,80003430 <vTaskIncrementTick+0x104>
800033ca:	49 55       	lddpc	r5,8000341c <vTaskIncrementTick+0xf0>
800033cc:	49 32       	lddpc	r2,80003418 <vTaskIncrementTick+0xec>
800033ce:	ee c6 ff fc 	sub	r6,r7,-4
800033d2:	0c 9c       	mov	r12,r6
800033d4:	f0 1f 00 18 	mcall	80003434 <vTaskIncrementTick+0x108>
800033d8:	6e a8       	ld.w	r8,r7[0x28]
800033da:	58 08       	cp.w	r8,0
800033dc:	c0 50       	breq	800033e6 <vTaskIncrementTick+0xba>
800033de:	ee cc ff e8 	sub	r12,r7,-24
800033e2:	f0 1f 00 15 	mcall	80003434 <vTaskIncrementTick+0x108>
800033e6:	6e bc       	ld.w	r12,r7[0x2c]
800033e8:	68 08       	ld.w	r8,r4[0x0]
800033ea:	10 3c       	cp.w	r12,r8
800033ec:	e9 fc ba 00 	st.whi	r4[0x0],r12
800033f0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800033f4:	0c 9b       	mov	r11,r6
800033f6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800033fa:	f0 1f 00 10 	mcall	80003438 <vTaskIncrementTick+0x10c>
800033fe:	6a 08       	ld.w	r8,r5[0x0]
80003400:	70 08       	ld.w	r8,r8[0x0]
80003402:	58 08       	cp.w	r8,0
80003404:	cd 51       	brne	800033ae <vTaskIncrementTick+0x82>
80003406:	cc fb       	rjmp	800033a4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80003408:	48 d8       	lddpc	r8,8000343c <vTaskIncrementTick+0x110>
8000340a:	70 09       	ld.w	r9,r8[0x0]
8000340c:	2f f9       	sub	r9,-1
8000340e:	91 09       	st.w	r8[0x0],r9
80003410:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003414:	00 00       	add	r0,r0
80003416:	07 28       	ld.uh	r8,r3++
80003418:	00 00       	add	r0,r0
8000341a:	07 24       	ld.uh	r4,r3++
8000341c:	00 00       	add	r0,r0
8000341e:	06 60       	and	r0,r3
80003420:	00 00       	add	r0,r0
80003422:	06 68       	and	r8,r3
80003424:	00 00       	add	r0,r0
80003426:	06 64       	and	r4,r3
80003428:	00 00       	add	r0,r0
8000342a:	00 24       	rsub	r4,r0
8000342c:	00 00       	add	r0,r0
8000342e:	07 48       	ld.w	r8,--r3
80003430:	00 00       	add	r0,r0
80003432:	06 6c       	and	r12,r3
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	2c 3c       	sub	r12,-61
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	2b ec       	sub	r12,-66
8000343c:	00 00       	add	r0,r0
8000343e:	06 5c       	eor	r12,r3

80003440 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80003440:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80003444:	f0 1f 00 2c 	mcall	800034f4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80003448:	4a c8       	lddpc	r8,800034f8 <xTaskResumeAll+0xb8>
8000344a:	70 09       	ld.w	r9,r8[0x0]
8000344c:	20 19       	sub	r9,1
8000344e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80003450:	70 08       	ld.w	r8,r8[0x0]
80003452:	58 08       	cp.w	r8,0
80003454:	c4 91       	brne	800034e6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80003456:	4a a8       	lddpc	r8,800034fc <xTaskResumeAll+0xbc>
80003458:	70 08       	ld.w	r8,r8[0x0]
8000345a:	58 08       	cp.w	r8,0
8000345c:	c4 50       	breq	800034e6 <xTaskResumeAll+0xa6>
8000345e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80003460:	4a 85       	lddpc	r5,80003500 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80003462:	4a 93       	lddpc	r3,80003504 <xTaskResumeAll+0xc4>
80003464:	4a 92       	lddpc	r2,80003508 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003466:	4a a1       	lddpc	r1,8000350c <xTaskResumeAll+0xcc>
80003468:	c1 e8       	rjmp	800034a4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000346a:	6a 38       	ld.w	r8,r5[0xc]
8000346c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000346e:	ee cc ff e8 	sub	r12,r7,-24
80003472:	f0 1f 00 28 	mcall	80003510 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80003476:	ee c6 ff fc 	sub	r6,r7,-4
8000347a:	0c 9c       	mov	r12,r6
8000347c:	f0 1f 00 25 	mcall	80003510 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80003480:	6e bc       	ld.w	r12,r7[0x2c]
80003482:	66 08       	ld.w	r8,r3[0x0]
80003484:	10 3c       	cp.w	r12,r8
80003486:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000348a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000348e:	0c 9b       	mov	r11,r6
80003490:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80003494:	f0 1f 00 20 	mcall	80003514 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80003498:	62 08       	ld.w	r8,r1[0x0]
8000349a:	6e b9       	ld.w	r9,r7[0x2c]
8000349c:	70 b8       	ld.w	r8,r8[0x2c]
8000349e:	10 39       	cp.w	r9,r8
800034a0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800034a4:	6a 08       	ld.w	r8,r5[0x0]
800034a6:	58 08       	cp.w	r8,0
800034a8:	ce 11       	brne	8000346a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034aa:	49 c8       	lddpc	r8,80003518 <xTaskResumeAll+0xd8>
800034ac:	70 08       	ld.w	r8,r8[0x0]
800034ae:	58 08       	cp.w	r8,0
800034b0:	c0 f0       	breq	800034ce <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034b2:	49 a8       	lddpc	r8,80003518 <xTaskResumeAll+0xd8>
800034b4:	70 08       	ld.w	r8,r8[0x0]
800034b6:	58 08       	cp.w	r8,0
800034b8:	c1 10       	breq	800034da <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800034ba:	49 87       	lddpc	r7,80003518 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800034bc:	f0 1f 00 18 	mcall	8000351c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800034c0:	6e 08       	ld.w	r8,r7[0x0]
800034c2:	20 18       	sub	r8,1
800034c4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800034c6:	6e 08       	ld.w	r8,r7[0x0]
800034c8:	58 08       	cp.w	r8,0
800034ca:	cf 91       	brne	800034bc <xTaskResumeAll+0x7c>
800034cc:	c0 78       	rjmp	800034da <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800034ce:	58 14       	cp.w	r4,1
800034d0:	c0 50       	breq	800034da <xTaskResumeAll+0x9a>
800034d2:	49 48       	lddpc	r8,80003520 <xTaskResumeAll+0xe0>
800034d4:	70 08       	ld.w	r8,r8[0x0]
800034d6:	58 18       	cp.w	r8,1
800034d8:	c0 71       	brne	800034e6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800034da:	30 09       	mov	r9,0
800034dc:	49 18       	lddpc	r8,80003520 <xTaskResumeAll+0xe0>
800034de:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800034e0:	d7 33       	scall
800034e2:	30 17       	mov	r7,1
800034e4:	c0 28       	rjmp	800034e8 <xTaskResumeAll+0xa8>
800034e6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800034e8:	f0 1f 00 0f 	mcall	80003524 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800034ec:	0e 9c       	mov	r12,r7
800034ee:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800034f2:	00 00       	add	r0,r0
800034f4:	80 00       	ld.sh	r0,r0[0x0]
800034f6:	2c 64       	sub	r4,-58
800034f8:	00 00       	add	r0,r0
800034fa:	07 28       	ld.uh	r8,r3++
800034fc:	00 00       	add	r0,r0
800034fe:	07 2c       	ld.uh	r12,r3++
80003500:	00 00       	add	r0,r0
80003502:	07 10       	ld.sh	r0,r3++
80003504:	00 00       	add	r0,r0
80003506:	07 48       	ld.w	r8,--r3
80003508:	00 00       	add	r0,r0
8000350a:	06 6c       	and	r12,r3
8000350c:	00 00       	add	r0,r0
8000350e:	07 0c       	ld.w	r12,r3++
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	2c 3c       	sub	r12,-61
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	2b ec       	sub	r12,-66
80003518:	00 00       	add	r0,r0
8000351a:	06 5c       	eor	r12,r3
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	33 2c       	mov	r12,50
80003520:	00 00       	add	r0,r0
80003522:	07 30       	ld.ub	r0,r3++
80003524:	80 00       	ld.sh	r0,r0[0x0]
80003526:	2d 0c       	sub	r12,-48

80003528 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80003528:	eb cd 40 80 	pushm	r7,lr
8000352c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000352e:	49 08       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
80003530:	70 08       	ld.w	r8,r8[0x0]
80003532:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80003534:	48 f8       	lddpc	r8,80003570 <prvAddCurrentTaskToDelayedList+0x48>
80003536:	70 08       	ld.w	r8,r8[0x0]
80003538:	10 3c       	cp.w	r12,r8
8000353a:	c0 a2       	brcc	8000354e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000353c:	48 c8       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
8000353e:	70 0b       	ld.w	r11,r8[0x0]
80003540:	48 d8       	lddpc	r8,80003574 <prvAddCurrentTaskToDelayedList+0x4c>
80003542:	70 0c       	ld.w	r12,r8[0x0]
80003544:	2f cb       	sub	r11,-4
80003546:	f0 1f 00 0d 	mcall	80003578 <prvAddCurrentTaskToDelayedList+0x50>
8000354a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000354e:	48 88       	lddpc	r8,8000356c <prvAddCurrentTaskToDelayedList+0x44>
80003550:	70 0b       	ld.w	r11,r8[0x0]
80003552:	48 b8       	lddpc	r8,8000357c <prvAddCurrentTaskToDelayedList+0x54>
80003554:	70 0c       	ld.w	r12,r8[0x0]
80003556:	2f cb       	sub	r11,-4
80003558:	f0 1f 00 08 	mcall	80003578 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000355c:	48 98       	lddpc	r8,80003580 <prvAddCurrentTaskToDelayedList+0x58>
8000355e:	70 08       	ld.w	r8,r8[0x0]
80003560:	10 37       	cp.w	r7,r8
80003562:	c0 32       	brcc	80003568 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80003564:	48 78       	lddpc	r8,80003580 <prvAddCurrentTaskToDelayedList+0x58>
80003566:	91 07       	st.w	r8[0x0],r7
80003568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000356c:	00 00       	add	r0,r0
8000356e:	07 0c       	ld.w	r12,r3++
80003570:	00 00       	add	r0,r0
80003572:	07 24       	ld.uh	r4,r3++
80003574:	00 00       	add	r0,r0
80003576:	06 68       	and	r8,r3
80003578:	80 00       	ld.sh	r0,r0[0x0]
8000357a:	2c 08       	sub	r8,-64
8000357c:	00 00       	add	r0,r0
8000357e:	06 60       	and	r0,r3
80003580:	00 00       	add	r0,r0
80003582:	00 24       	rsub	r4,r0

80003584 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80003584:	eb cd 40 c0 	pushm	r6-r7,lr
80003588:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000358a:	48 e7       	lddpc	r7,800035c0 <vTaskPlaceOnEventList+0x3c>
8000358c:	6e 0b       	ld.w	r11,r7[0x0]
8000358e:	2e 8b       	sub	r11,-24
80003590:	f0 1f 00 0d 	mcall	800035c4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80003594:	6e 0c       	ld.w	r12,r7[0x0]
80003596:	2f cc       	sub	r12,-4
80003598:	f0 1f 00 0c 	mcall	800035c8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
8000359c:	5b f6       	cp.w	r6,-1
8000359e:	c0 81       	brne	800035ae <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800035a0:	6e 0b       	ld.w	r11,r7[0x0]
800035a2:	2f cb       	sub	r11,-4
800035a4:	48 ac       	lddpc	r12,800035cc <vTaskPlaceOnEventList+0x48>
800035a6:	f0 1f 00 0b 	mcall	800035d0 <vTaskPlaceOnEventList+0x4c>
800035aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800035ae:	48 a8       	lddpc	r8,800035d4 <vTaskPlaceOnEventList+0x50>
800035b0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800035b2:	ec 0c 00 0c 	add	r12,r6,r12
800035b6:	f0 1f 00 09 	mcall	800035d8 <vTaskPlaceOnEventList+0x54>
800035ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035be:	00 00       	add	r0,r0
800035c0:	00 00       	add	r0,r0
800035c2:	07 0c       	ld.w	r12,r3++
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	2c 08       	sub	r8,-64
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	2c 3c       	sub	r12,-61
800035cc:	00 00       	add	r0,r0
800035ce:	07 34       	ld.ub	r4,r3++
800035d0:	80 00       	ld.sh	r0,r0[0x0]
800035d2:	2b ec       	sub	r12,-66
800035d4:	00 00       	add	r0,r0
800035d6:	07 24       	ld.uh	r4,r3++
800035d8:	80 00       	ld.sh	r0,r0[0x0]
800035da:	35 28       	mov	r8,82

800035dc <dip204_example_configure_joystick_IT>:
	Enable_global_interrupt();
}


void dip204_example_configure_joystick_IT(void)
{
800035dc:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_UP , GPIO_FALLING_EDGE);
800035e0:	30 2b       	mov	r11,2
800035e2:	31 ac       	mov	r12,26
800035e4:	f0 1f 00 18 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_DOWN , GPIO_FALLING_EDGE);
800035e8:	30 2b       	mov	r11,2
800035ea:	31 bc       	mov	r12,27
800035ec:	f0 1f 00 16 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_RIGHT , GPIO_FALLING_EDGE);
800035f0:	30 2b       	mov	r11,2
800035f2:	31 cc       	mov	r12,28
800035f4:	f0 1f 00 14 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_PUSH , GPIO_FALLING_EDGE);
800035f8:	30 2b       	mov	r11,2
800035fa:	31 4c       	mov	r12,20
800035fc:	f0 1f 00 12 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_LEFT , GPIO_FALLING_EDGE);
80003600:	30 2b       	mov	r11,2
80003602:	31 9c       	mov	r12,25
80003604:	f0 1f 00 10 	mcall	80003644 <dip204_example_configure_joystick_IT+0x68>

	/* Disable all interrupts */
	Disable_global_interrupt();
80003608:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_UP/8), AVR32_INTC_INT1);
8000360a:	49 07       	lddpc	r7,80003648 <dip204_example_configure_joystick_IT+0x6c>
8000360c:	30 1a       	mov	r10,1
8000360e:	34 3b       	mov	r11,67
80003610:	0e 9c       	mov	r12,r7
80003612:	f0 1f 00 0f 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_DOWN/8), AVR32_INTC_INT1);
80003616:	30 1a       	mov	r10,1
80003618:	34 3b       	mov	r11,67
8000361a:	0e 9c       	mov	r12,r7
8000361c:	f0 1f 00 0c 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_RIGHT/8), AVR32_INTC_INT1);
80003620:	30 1a       	mov	r10,1
80003622:	34 3b       	mov	r11,67
80003624:	0e 9c       	mov	r12,r7
80003626:	f0 1f 00 0a 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_LEFT/8), AVR32_INTC_INT1);
8000362a:	30 1a       	mov	r10,1
8000362c:	34 3b       	mov	r11,67
8000362e:	0e 9c       	mov	r12,r7
80003630:	f0 1f 00 07 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	INTC_register_interrupt( &dip204_example_Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_PUSH/8), AVR32_INTC_INT1);
80003634:	30 1a       	mov	r10,1
80003636:	34 2b       	mov	r11,66
80003638:	0e 9c       	mov	r12,r7
8000363a:	f0 1f 00 05 	mcall	8000364c <dip204_example_configure_joystick_IT+0x70>
	/* Enable all interrupts */
	Enable_global_interrupt();
8000363e:	d5 03       	csrf	0x10
}
80003640:	e3 cd 80 80 	ldm	sp++,r7,pc
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	26 70       	sub	r0,103
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	38 30       	mov	r0,-125
8000364c:	80 00       	ld.sh	r0,r0[0x0]
8000364e:	26 e8       	sub	r8,110

80003650 <dip204_example_configure_push_buttons_IT>:
	}
}


void dip204_example_configure_push_buttons_IT(void)
{
80003650:	eb cd 40 80 	pushm	r7,lr
	gpio_enable_pin_interrupt(GPIO_CHARSET , GPIO_RISING_EDGE);
80003654:	30 1b       	mov	r11,1
80003656:	35 8c       	mov	r12,88
80003658:	f0 1f 00 0f 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_PLUS , GPIO_RISING_EDGE);
8000365c:	30 1b       	mov	r11,1
8000365e:	35 2c       	mov	r12,82
80003660:	f0 1f 00 0d 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	gpio_enable_pin_interrupt(GPIO_BACKLIGHT_MINUS , GPIO_RISING_EDGE);
80003664:	30 1b       	mov	r11,1
80003666:	35 5c       	mov	r12,85
80003668:	f0 1f 00 0b 	mcall	80003694 <dip204_example_configure_push_buttons_IT+0x44>

	/* Disable all interrupts */
	Disable_global_interrupt();
8000366c:	d3 03       	ssrf	0x10
	/* register PB0 handler on level 1 */
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_PLUS/8), AVR32_INTC_INT1);
8000366e:	48 b7       	lddpc	r7,80003698 <dip204_example_configure_push_buttons_IT+0x48>
80003670:	30 1a       	mov	r10,1
80003672:	34 ab       	mov	r11,74
80003674:	0e 9c       	mov	r12,r7
80003676:	f0 1f 00 0a 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_BACKLIGHT_MINUS/8), AVR32_INTC_INT1);
8000367a:	30 1a       	mov	r10,1
8000367c:	34 ab       	mov	r11,74
8000367e:	0e 9c       	mov	r12,r7
80003680:	f0 1f 00 07 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	INTC_register_interrupt( &dip204_example_PB_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_CHARSET/8), AVR32_INTC_INT1);
80003684:	30 1a       	mov	r10,1
80003686:	34 bb       	mov	r11,75
80003688:	0e 9c       	mov	r12,r7
8000368a:	f0 1f 00 05 	mcall	8000369c <dip204_example_configure_push_buttons_IT+0x4c>
	/* Enable all interrupts */
	Enable_global_interrupt();
8000368e:	d5 03       	csrf	0x10
}
80003690:	e3 cd 80 80 	ldm	sp++,r7,pc
80003694:	80 00       	ld.sh	r0,r0[0x0]
80003696:	26 70       	sub	r0,103
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	39 14       	mov	r4,-111
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	26 e8       	sub	r8,110

800036a0 <main>:
	/* Enable all interrupts */
	Enable_global_interrupt();
}

int main(void)
{
800036a0:	d4 31       	pushm	r0-r7,lr
800036a2:	20 4d       	sub	sp,16
		{DIP204_SPI_MOSI_PIN, DIP204_SPI_MOSI_FUNCTION},  // MOSI.
		{DIP204_SPI_NPCS_PIN, DIP204_SPI_NPCS_FUNCTION}   // Chip Select NPCS.
	};

	// Switch the CPU main clock to oscillator 0
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
800036a4:	30 3a       	mov	r10,3
800036a6:	e0 6b 1b 00 	mov	r11,6912
800036aa:	ea 1b 00 b7 	orh	r11,0xb7
800036ae:	fe 7c 0c 00 	mov	r12,-62464
800036b2:	f0 1f 00 49 	mcall	800037d4 <main+0x134>

	// Disable all interrupts.
	Disable_global_interrupt();
800036b6:	d3 03       	ssrf	0x10

	// init the interrupts
	INTC_init_interrupts();
800036b8:	f0 1f 00 48 	mcall	800037d8 <main+0x138>

	// Enable all interrupts.
	Enable_global_interrupt();
800036bc:	d5 03       	csrf	0x10
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800036be:	4c 88       	lddpc	r8,800037dc <main+0x13c>
800036c0:	f0 ea 00 00 	ld.d	r10,r8[0]
800036c4:	fa eb 00 00 	st.d	sp[0],r10
800036c8:	f0 e8 00 08 	ld.d	r8,r8[8]
800036cc:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI
	gpio_enable_module(DIP204_SPI_GPIO_MAP,
800036d0:	30 4b       	mov	r11,4
800036d2:	4c 4c       	lddpc	r12,800037e0 <main+0x140>
800036d4:	f0 1f 00 44 	mcall	800037e4 <main+0x144>
	sizeof(DIP204_SPI_GPIO_MAP) / sizeof(DIP204_SPI_GPIO_MAP[0]));

	// Initialize as master
	spi_initMaster(DIP204_SPI, &spiOptions);
800036d8:	1a 9b       	mov	r11,sp
800036da:	fe 7c 28 00 	mov	r12,-55296
800036de:	f0 1f 00 43 	mcall	800037e8 <main+0x148>

	// Set selection mode: variable_ps, pcs_decode, delay
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
800036e2:	30 09       	mov	r9,0
800036e4:	12 9a       	mov	r10,r9
800036e6:	12 9b       	mov	r11,r9
800036e8:	fe 7c 28 00 	mov	r12,-55296
800036ec:	f0 1f 00 40 	mcall	800037ec <main+0x14c>

	// Enable SPI
	spi_enable(DIP204_SPI);
800036f0:	fe 7c 28 00 	mov	r12,-55296
800036f4:	f0 1f 00 3f 	mcall	800037f0 <main+0x150>

	// setup chip registers
	spi_setupChipReg(DIP204_SPI, &spiOptions, FOSC0);
800036f8:	e0 6a 1b 00 	mov	r10,6912
800036fc:	ea 1a 00 b7 	orh	r10,0xb7
80003700:	1a 9b       	mov	r11,sp
80003702:	fe 7c 28 00 	mov	r12,-55296
80003706:	f0 1f 00 3c 	mcall	800037f4 <main+0x154>

	// configure local push buttons
	dip204_example_configure_push_buttons_IT();
8000370a:	f0 1f 00 3c 	mcall	800037f8 <main+0x158>

	// configure local joystick
	dip204_example_configure_joystick_IT();
8000370e:	f0 1f 00 3c 	mcall	800037fc <main+0x15c>

	// initialize delay driver
	delay_init( FOSC0 );

	// initialize LCD
	dip204_init(backlight_PWM, true);
80003712:	30 1b       	mov	r11,1
80003714:	16 9c       	mov	r12,r11
80003716:	f0 1f 00 3b 	mcall	80003800 <main+0x160>

	// reset marker
	current_char = 0x10;
8000371a:	31 09       	mov	r9,16
8000371c:	4b a8       	lddpc	r8,80003804 <main+0x164>
8000371e:	b0 09       	st.h	r8[0x0],r9

	// Display default message.
	dip204_set_cursor_position(8,1);
80003720:	30 1b       	mov	r11,1
80003722:	30 8c       	mov	r12,8
80003724:	f0 1f 00 39 	mcall	80003808 <main+0x168>
	dip204_write_string("ATMEL");
80003728:	4b 9c       	lddpc	r12,8000380c <main+0x16c>
8000372a:	f0 1f 00 3a 	mcall	80003810 <main+0x170>
	dip204_set_cursor_position(7,2);
8000372e:	30 2b       	mov	r11,2
80003730:	30 7c       	mov	r12,7
80003732:	f0 1f 00 36 	mcall	80003808 <main+0x168>
	dip204_write_string("EVK1100");
80003736:	4b 8c       	lddpc	r12,80003814 <main+0x174>
80003738:	f0 1f 00 36 	mcall	80003810 <main+0x170>
	dip204_set_cursor_position(6,3);
8000373c:	30 3b       	mov	r11,3
8000373e:	30 6c       	mov	r12,6
80003740:	f0 1f 00 32 	mcall	80003808 <main+0x168>
	dip204_write_string("AVR32 UC3");
80003744:	4b 5c       	lddpc	r12,80003818 <main+0x178>
80003746:	f0 1f 00 33 	mcall	80003810 <main+0x170>
	dip204_set_cursor_position(3,4);
8000374a:	30 4b       	mov	r11,4
8000374c:	30 3c       	mov	r12,3
8000374e:	f0 1f 00 2f 	mcall	80003808 <main+0x168>
	dip204_write_string("AT32UC3A Series");
80003752:	4b 3c       	lddpc	r12,8000381c <main+0x17c>
80003754:	f0 1f 00 2f 	mcall	80003810 <main+0x170>
	dip204_hide_cursor();
80003758:	f0 1f 00 32 	mcall	80003820 <main+0x180>

	/* do a loop */
	while (1)
	{
		if (display)
8000375c:	4b 24       	lddpc	r4,80003824 <main+0x184>
8000375e:	30 05       	mov	r5,0
		{
			delay_ms(400);  // A delay so that it is humanly possible to see the
			// character(s) before they are cleared.
			// Clear line 1 column 19
			dip204_set_cursor_position(19,1);
80003760:	30 13       	mov	r3,1
80003762:	31 36       	mov	r6,19
			dip204_write_string(" ");
80003764:	4b 17       	lddpc	r7,80003828 <main+0x188>
			// Clear line 2 from column 18 to column 20.
			dip204_set_cursor_position(18,2);
80003766:	30 22       	mov	r2,2
80003768:	31 21       	mov	r1,18
			dip204_write_string("   "); // 3 spaces
8000376a:	4b 10       	lddpc	r0,8000382c <main+0x18c>
	dip204_hide_cursor();

	/* do a loop */
	while (1)
	{
		if (display)
8000376c:	88 08       	ld.sh	r8,r4[0x0]
8000376e:	ea 08 19 00 	cp.h	r8,r5
80003772:	c3 00       	breq	800037d2 <main+0x132>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003774:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80003778:	e0 69 36 00 	mov	r9,13824
8000377c:	ea 19 01 6e 	orh	r9,0x16e
80003780:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003784:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003788:	14 38       	cp.w	r8,r10
8000378a:	e0 88 00 08 	brls	8000379a <main+0xfa>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000378e:	12 38       	cp.w	r8,r9
80003790:	fe 98 ff fa 	brls	80003784 <main+0xe4>
80003794:	12 3a       	cp.w	r10,r9
80003796:	c0 73       	brcs	800037a4 <main+0x104>
80003798:	cf 6b       	rjmp	80003784 <main+0xe4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000379a:	12 38       	cp.w	r8,r9
8000379c:	e0 8b 00 04 	brhi	800037a4 <main+0x104>
800037a0:	12 3a       	cp.w	r10,r9
800037a2:	cf 12       	brcc	80003784 <main+0xe4>
		{
			delay_ms(400);  // A delay so that it is humanly possible to see the
			// character(s) before they are cleared.
			// Clear line 1 column 19
			dip204_set_cursor_position(19,1);
800037a4:	06 9b       	mov	r11,r3
800037a6:	0c 9c       	mov	r12,r6
800037a8:	f0 1f 00 18 	mcall	80003808 <main+0x168>
			dip204_write_string(" ");
800037ac:	0e 9c       	mov	r12,r7
800037ae:	f0 1f 00 19 	mcall	80003810 <main+0x170>
			// Clear line 2 from column 18 to column 20.
			dip204_set_cursor_position(18,2);
800037b2:	04 9b       	mov	r11,r2
800037b4:	02 9c       	mov	r12,r1
800037b6:	f0 1f 00 15 	mcall	80003808 <main+0x168>
			dip204_write_string("   "); // 3 spaces
800037ba:	00 9c       	mov	r12,r0
800037bc:	f0 1f 00 15 	mcall	80003810 <main+0x170>
			// Clear line 3 column 19
			dip204_set_cursor_position(19,3);
800037c0:	30 3b       	mov	r11,3
800037c2:	0c 9c       	mov	r12,r6
800037c4:	f0 1f 00 11 	mcall	80003808 <main+0x168>
			dip204_write_string(" ");
800037c8:	0e 9c       	mov	r12,r7
800037ca:	f0 1f 00 12 	mcall	80003810 <main+0x170>
			display = 0;
800037ce:	a8 05       	st.h	r4[0x0],r5
800037d0:	cc eb       	rjmp	8000376c <main+0xcc>
800037d2:	c0 08       	rjmp	800037d2 <main+0x132>
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	28 80       	sub	r0,-120
800037d8:	80 00       	ld.sh	r0,r0[0x0]
800037da:	27 68       	sub	r8,118
800037dc:	80 00       	ld.sh	r0,r0[0x0]
800037de:	46 b8       	lddsp	r8,sp[0x1ac]
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	46 c8       	lddsp	r8,sp[0x1b0]
800037e4:	80 00       	ld.sh	r0,r0[0x0]
800037e6:	26 08       	sub	r8,96
800037e8:	80 00       	ld.sh	r0,r0[0x0]
800037ea:	29 92       	sub	r2,-103
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	29 ca       	sub	r10,-100
800037f0:	80 00       	ld.sh	r0,r0[0x0]
800037f2:	29 f6       	sub	r6,-97
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	2a 38       	sub	r8,-93
800037f8:	80 00       	ld.sh	r0,r0[0x0]
800037fa:	36 50       	mov	r0,101
800037fc:	80 00       	ld.sh	r0,r0[0x0]
800037fe:	35 dc       	mov	r12,93
80003800:	80 00       	ld.sh	r0,r0[0x0]
80003802:	23 70       	sub	r0,55
80003804:	00 00       	add	r0,r0
80003806:	07 4c       	ld.w	r12,--r3
80003808:	80 00       	ld.sh	r0,r0[0x0]
8000380a:	22 24       	sub	r4,34
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	46 e8       	lddsp	r8,sp[0x1b8]
80003810:	80 00       	ld.sh	r0,r0[0x0]
80003812:	21 cc       	sub	r12,28
80003814:	80 00       	ld.sh	r0,r0[0x0]
80003816:	46 f0       	lddsp	r0,sp[0x1bc]
80003818:	80 00       	ld.sh	r0,r0[0x0]
8000381a:	46 f8       	lddsp	r8,sp[0x1bc]
8000381c:	80 00       	ld.sh	r0,r0[0x0]
8000381e:	47 04       	lddsp	r4,sp[0x1c0]
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	22 b4       	sub	r4,43
80003824:	00 00       	add	r0,r0
80003826:	07 8c       	ld.ub	r12,r3[0x0]
80003828:	80 00       	ld.sh	r0,r0[0x0]
8000382a:	47 14       	lddsp	r4,sp[0x1c4]
8000382c:	80 00       	ld.sh	r0,r0[0x0]
8000382e:	47 18       	lddsp	r8,sp[0x1c4]

80003830 <dip204_example_Joy_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_Joy_int_handler(void)
{
80003830:	d4 01       	pushm	lr
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_UP))
80003832:	31 ac       	mov	r12,26
80003834:	f0 1f 00 31 	mcall	800038f8 <dip204_example_Joy_int_handler+0xc8>
80003838:	c0 f0       	breq	80003856 <dip204_example_Joy_int_handler+0x26>
	{
		dip204_set_cursor_position(19,1);
8000383a:	30 1b       	mov	r11,1
8000383c:	31 3c       	mov	r12,19
8000383e:	f0 1f 00 30 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDE);
80003842:	e0 6c 00 de 	mov	r12,222
80003846:	f0 1f 00 2f 	mcall	80003900 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
8000384a:	30 19       	mov	r9,1
8000384c:	4a e8       	lddpc	r8,80003904 <dip204_example_Joy_int_handler+0xd4>
8000384e:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_UP);
80003850:	31 ac       	mov	r12,26
80003852:	f0 1f 00 2e 	mcall	80003908 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_DOWN))
80003856:	31 bc       	mov	r12,27
80003858:	f0 1f 00 28 	mcall	800038f8 <dip204_example_Joy_int_handler+0xc8>
8000385c:	c0 f0       	breq	8000387a <dip204_example_Joy_int_handler+0x4a>
	{
		dip204_set_cursor_position(19,3);
8000385e:	30 3b       	mov	r11,3
80003860:	31 3c       	mov	r12,19
80003862:	f0 1f 00 27 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE0);
80003866:	e0 6c 00 e0 	mov	r12,224
8000386a:	f0 1f 00 26 	mcall	80003900 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
8000386e:	30 19       	mov	r9,1
80003870:	4a 58       	lddpc	r8,80003904 <dip204_example_Joy_int_handler+0xd4>
80003872:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_DOWN);
80003874:	31 bc       	mov	r12,27
80003876:	f0 1f 00 25 	mcall	80003908 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_LEFT))
8000387a:	31 9c       	mov	r12,25
8000387c:	f0 1f 00 1f 	mcall	800038f8 <dip204_example_Joy_int_handler+0xc8>
80003880:	c0 f0       	breq	8000389e <dip204_example_Joy_int_handler+0x6e>
	{
		dip204_set_cursor_position(18,2);
80003882:	30 2b       	mov	r11,2
80003884:	31 2c       	mov	r12,18
80003886:	f0 1f 00 1e 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xE1);
8000388a:	e0 6c 00 e1 	mov	r12,225
8000388e:	f0 1f 00 1d 	mcall	80003900 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
80003892:	30 19       	mov	r9,1
80003894:	49 c8       	lddpc	r8,80003904 <dip204_example_Joy_int_handler+0xd4>
80003896:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_LEFT);
80003898:	31 9c       	mov	r12,25
8000389a:	f0 1f 00 1c 	mcall	80003908 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT))
8000389e:	31 cc       	mov	r12,28
800038a0:	f0 1f 00 16 	mcall	800038f8 <dip204_example_Joy_int_handler+0xc8>
800038a4:	c0 f0       	breq	800038c2 <dip204_example_Joy_int_handler+0x92>
	{
		dip204_set_cursor_position(20,2);
800038a6:	30 2b       	mov	r11,2
800038a8:	31 4c       	mov	r12,20
800038aa:	f0 1f 00 15 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xDF);
800038ae:	e0 6c 00 df 	mov	r12,223
800038b2:	f0 1f 00 14 	mcall	80003900 <dip204_example_Joy_int_handler+0xd0>
		display = 1;
800038b6:	30 19       	mov	r9,1
800038b8:	49 38       	lddpc	r8,80003904 <dip204_example_Joy_int_handler+0xd4>
800038ba:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT);
800038bc:	31 cc       	mov	r12,28
800038be:	f0 1f 00 13 	mcall	80003908 <dip204_example_Joy_int_handler+0xd8>
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_PUSH))
800038c2:	31 4c       	mov	r12,20
800038c4:	f0 1f 00 0d 	mcall	800038f8 <dip204_example_Joy_int_handler+0xc8>
800038c8:	c1 60       	breq	800038f4 <dip204_example_Joy_int_handler+0xc4>
	{
		dip204_set_cursor_position(19,2);
800038ca:	30 2b       	mov	r11,2
800038cc:	31 3c       	mov	r12,19
800038ce:	f0 1f 00 0c 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_data(0xBB);
800038d2:	e0 6c 00 bb 	mov	r12,187
800038d6:	f0 1f 00 0b 	mcall	80003900 <dip204_example_Joy_int_handler+0xd0>
		dip204_set_cursor_position(1,4);
800038da:	30 4b       	mov	r11,4
800038dc:	30 1c       	mov	r12,1
800038de:	f0 1f 00 08 	mcall	800038fc <dip204_example_Joy_int_handler+0xcc>
		dip204_write_string("  AT32UC3A Series   ");
800038e2:	48 bc       	lddpc	r12,8000390c <dip204_example_Joy_int_handler+0xdc>
800038e4:	f0 1f 00 0b 	mcall	80003910 <dip204_example_Joy_int_handler+0xe0>
		display = 1;
800038e8:	30 19       	mov	r9,1
800038ea:	48 78       	lddpc	r8,80003904 <dip204_example_Joy_int_handler+0xd4>
800038ec:	b0 09       	st.h	r8[0x0],r9
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_PUSH);
800038ee:	31 4c       	mov	r12,20
800038f0:	f0 1f 00 06 	mcall	80003908 <dip204_example_Joy_int_handler+0xd8>
	}
}
800038f4:	d4 02       	popm	lr
800038f6:	d6 03       	rete
800038f8:	80 00       	ld.sh	r0,r0[0x0]
800038fa:	26 b6       	sub	r6,107
800038fc:	80 00       	ld.sh	r0,r0[0x0]
800038fe:	22 24       	sub	r4,34
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	22 80       	sub	r0,40
80003904:	00 00       	add	r0,r0
80003906:	07 8c       	ld.ub	r12,r3[0x0]
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	26 ce       	sub	lr,108
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	47 1c       	lddsp	r12,sp[0x1c4]
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	21 cc       	sub	r12,28

80003914 <dip204_example_PB_int_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void dip204_example_PB_int_handler(void)
{
80003914:	eb cd 40 c0 	pushm	r6-r7,lr
	unsigned short i;

	/* display all available chars */
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
80003918:	35 8c       	mov	r12,88
8000391a:	f0 1f 00 23 	mcall	800039a4 <dip204_example_PB_int_handler+0x90>
8000391e:	c2 b0       	breq	80003974 <dip204_example_PB_int_handler+0x60>
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
80003920:	30 4b       	mov	r11,4
80003922:	30 1c       	mov	r12,1
80003924:	f0 1f 00 21 	mcall	800039a8 <dip204_example_PB_int_handler+0x94>
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
80003928:	4a 18       	lddpc	r8,800039ac <dip204_example_PB_int_handler+0x98>
8000392a:	90 07       	ld.sh	r7,r8[0x0]
8000392c:	0e 98       	mov	r8,r7
8000392e:	5c 78       	castu.h	r8
80003930:	f0 c9 ff f0 	sub	r9,r8,-16
80003934:	12 38       	cp.w	r8,r9
80003936:	c0 e4       	brge	80003952 <dip204_example_PB_int_handler+0x3e>
80003938:	49 d6       	lddpc	r6,800039ac <dip204_example_PB_int_handler+0x98>
		{
			dip204_write_data(i);
8000393a:	0e 9c       	mov	r12,r7
8000393c:	5c 5c       	castu.b	r12
8000393e:	f0 1f 00 1d 	mcall	800039b0 <dip204_example_PB_int_handler+0x9c>
	if (gpio_get_pin_interrupt_flag(GPIO_CHARSET))
	{
		/* go to first column of 4th line */
		dip204_set_cursor_position(1,4);
		/* display 20 chars of charmap */
		for (i = current_char; i < current_char + 0x10; i++)
80003942:	2f f7       	sub	r7,-1
80003944:	5c 87       	casts.h	r7
80003946:	0e 99       	mov	r9,r7
80003948:	5c 79       	castu.h	r9
8000394a:	8c 88       	ld.uh	r8,r6[0x0]
8000394c:	2f 08       	sub	r8,-16
8000394e:	10 39       	cp.w	r9,r8
80003950:	cf 55       	brlt	8000393a <dip204_example_PB_int_handler+0x26>
		{
			dip204_write_data(i);
		}
		dip204_write_string("    ");
80003952:	49 9c       	lddpc	r12,800039b4 <dip204_example_PB_int_handler+0xa0>
80003954:	f0 1f 00 19 	mcall	800039b8 <dip204_example_PB_int_handler+0xa4>
		/* mark position in charmap */
		current_char = i;
80003958:	49 58       	lddpc	r8,800039ac <dip204_example_PB_int_handler+0x98>
8000395a:	b0 07       	st.h	r8[0x0],r7
		/* reset marker */
		if (current_char >= 0xFF)
8000395c:	e0 68 00 fe 	mov	r8,254
80003960:	f0 07 19 00 	cp.h	r7,r8
80003964:	e0 88 00 05 	brls	8000396e <dip204_example_PB_int_handler+0x5a>
		{
			current_char = 0x10;
80003968:	31 09       	mov	r9,16
8000396a:	49 18       	lddpc	r8,800039ac <dip204_example_PB_int_handler+0x98>
8000396c:	b0 09       	st.h	r8[0x0],r9
		}
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_CHARSET);
8000396e:	35 8c       	mov	r12,88
80003970:	f0 1f 00 13 	mcall	800039bc <dip204_example_PB_int_handler+0xa8>
	}
	/* increase backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS))
80003974:	35 2c       	mov	r12,82
80003976:	f0 1f 00 0c 	mcall	800039a4 <dip204_example_PB_int_handler+0x90>
8000397a:	c0 70       	breq	80003988 <dip204_example_PB_int_handler+0x74>
	{
		dip204_set_backlight(backlight_power_increase);
8000397c:	30 0c       	mov	r12,0
8000397e:	f0 1f 00 11 	mcall	800039c0 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_PLUS);
80003982:	35 2c       	mov	r12,82
80003984:	f0 1f 00 0e 	mcall	800039bc <dip204_example_PB_int_handler+0xa8>
	}
	/* decrease backlight power */
	if (gpio_get_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS))
80003988:	35 5c       	mov	r12,85
8000398a:	f0 1f 00 07 	mcall	800039a4 <dip204_example_PB_int_handler+0x90>
8000398e:	c0 70       	breq	8000399c <dip204_example_PB_int_handler+0x88>
	{
		dip204_set_backlight(backlight_power_decrease);
80003990:	30 1c       	mov	r12,1
80003992:	f0 1f 00 0c 	mcall	800039c0 <dip204_example_PB_int_handler+0xac>
		/* allow new interrupt : clear the IFR flag */
		gpio_clear_pin_interrupt_flag(GPIO_BACKLIGHT_MINUS);
80003996:	35 5c       	mov	r12,85
80003998:	f0 1f 00 09 	mcall	800039bc <dip204_example_PB_int_handler+0xa8>
	}
}
8000399c:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
800039a0:	d6 03       	rete
800039a2:	00 00       	add	r0,r0
800039a4:	80 00       	ld.sh	r0,r0[0x0]
800039a6:	26 b6       	sub	r6,107
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	22 24       	sub	r4,34
800039ac:	00 00       	add	r0,r0
800039ae:	07 4c       	ld.w	r12,--r3
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	22 80       	sub	r0,40
800039b4:	80 00       	ld.sh	r0,r0[0x0]
800039b6:	47 34       	lddsp	r4,sp[0x1cc]
800039b8:	80 00       	ld.sh	r0,r0[0x0]
800039ba:	21 cc       	sub	r12,28
800039bc:	80 00       	ld.sh	r0,r0[0x0]
800039be:	26 ce       	sub	lr,108
800039c0:	80 00       	ld.sh	r0,r0[0x0]
800039c2:	22 e4       	sub	r4,46

800039c4 <atexit>:
800039c4:	d4 01       	pushm	lr
800039c6:	30 09       	mov	r9,0
800039c8:	18 9b       	mov	r11,r12
800039ca:	12 9a       	mov	r10,r9
800039cc:	12 9c       	mov	r12,r9
800039ce:	e0 a0 03 17 	rcall	80003ffc <__register_exitproc>
800039d2:	d8 02       	popm	pc

800039d4 <exit>:
800039d4:	d4 21       	pushm	r4-r7,lr
800039d6:	30 0b       	mov	r11,0
800039d8:	18 97       	mov	r7,r12
800039da:	e0 a0 03 63 	rcall	800040a0 <__call_exitprocs>
800039de:	fe c8 f2 9e 	sub	r8,pc,-3426
800039e2:	70 0c       	ld.w	r12,r8[0x0]
800039e4:	78 a8       	ld.w	r8,r12[0x28]
800039e6:	58 08       	cp.w	r8,0
800039e8:	c0 20       	breq	800039ec <exit+0x18>
800039ea:	5d 18       	icall	r8
800039ec:	0e 9c       	mov	r12,r7
800039ee:	e0 a0 02 e6 	rcall	80003fba <_exit>
800039f2:	d7 03       	nop

800039f4 <free>:
800039f4:	d4 01       	pushm	lr
800039f6:	e0 68 01 18 	mov	r8,280
800039fa:	18 9b       	mov	r11,r12
800039fc:	70 0c       	ld.w	r12,r8[0x0]
800039fe:	e0 a0 04 05 	rcall	80004208 <_free_r>
80003a02:	d8 02       	popm	pc

80003a04 <malloc>:
80003a04:	d4 01       	pushm	lr
80003a06:	e0 68 01 18 	mov	r8,280
80003a0a:	18 9b       	mov	r11,r12
80003a0c:	70 0c       	ld.w	r12,r8[0x0]
80003a0e:	c0 3c       	rcall	80003a14 <_malloc_r>
80003a10:	d8 02       	popm	pc
80003a12:	d7 03       	nop

80003a14 <_malloc_r>:
80003a14:	d4 31       	pushm	r0-r7,lr
80003a16:	f6 c8 ff f5 	sub	r8,r11,-11
80003a1a:	18 95       	mov	r5,r12
80003a1c:	10 97       	mov	r7,r8
80003a1e:	e0 17 ff f8 	andl	r7,0xfff8
80003a22:	59 68       	cp.w	r8,22
80003a24:	f9 b7 08 10 	movls	r7,16
80003a28:	16 37       	cp.w	r7,r11
80003a2a:	5f 38       	srlo	r8
80003a2c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80003a30:	c0 50       	breq	80003a3a <_malloc_r+0x26>
80003a32:	30 c8       	mov	r8,12
80003a34:	99 38       	st.w	r12[0xc],r8
80003a36:	e0 8f 01 f8 	bral	80003e26 <_malloc_r+0x412>
80003a3a:	fe b0 f9 79 	rcall	80002d2c <__malloc_lock>
80003a3e:	e0 47 01 f7 	cp.w	r7,503
80003a42:	e0 8b 00 1d 	brhi	80003a7c <_malloc_r+0x68>
80003a46:	ee 03 16 03 	lsr	r3,r7,0x3
80003a4a:	e0 68 01 1c 	mov	r8,284
80003a4e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80003a52:	70 36       	ld.w	r6,r8[0xc]
80003a54:	10 36       	cp.w	r6,r8
80003a56:	c0 61       	brne	80003a62 <_malloc_r+0x4e>
80003a58:	ec c8 ff f8 	sub	r8,r6,-8
80003a5c:	70 36       	ld.w	r6,r8[0xc]
80003a5e:	10 36       	cp.w	r6,r8
80003a60:	c0 c0       	breq	80003a78 <_malloc_r+0x64>
80003a62:	6c 18       	ld.w	r8,r6[0x4]
80003a64:	e0 18 ff fc 	andl	r8,0xfffc
80003a68:	6c 3a       	ld.w	r10,r6[0xc]
80003a6a:	ec 08 00 09 	add	r9,r6,r8
80003a6e:	0a 9c       	mov	r12,r5
80003a70:	6c 28       	ld.w	r8,r6[0x8]
80003a72:	95 28       	st.w	r10[0x8],r8
80003a74:	91 3a       	st.w	r8[0xc],r10
80003a76:	c4 78       	rjmp	80003b04 <_malloc_r+0xf0>
80003a78:	2f e3       	sub	r3,-2
80003a7a:	c4 d8       	rjmp	80003b14 <_malloc_r+0x100>
80003a7c:	ee 03 16 09 	lsr	r3,r7,0x9
80003a80:	c0 41       	brne	80003a88 <_malloc_r+0x74>
80003a82:	ee 03 16 03 	lsr	r3,r7,0x3
80003a86:	c2 68       	rjmp	80003ad2 <_malloc_r+0xbe>
80003a88:	58 43       	cp.w	r3,4
80003a8a:	e0 8b 00 06 	brhi	80003a96 <_malloc_r+0x82>
80003a8e:	ee 03 16 06 	lsr	r3,r7,0x6
80003a92:	2c 83       	sub	r3,-56
80003a94:	c1 f8       	rjmp	80003ad2 <_malloc_r+0xbe>
80003a96:	59 43       	cp.w	r3,20
80003a98:	e0 8b 00 04 	brhi	80003aa0 <_malloc_r+0x8c>
80003a9c:	2a 53       	sub	r3,-91
80003a9e:	c1 a8       	rjmp	80003ad2 <_malloc_r+0xbe>
80003aa0:	e0 43 00 54 	cp.w	r3,84
80003aa4:	e0 8b 00 06 	brhi	80003ab0 <_malloc_r+0x9c>
80003aa8:	ee 03 16 0c 	lsr	r3,r7,0xc
80003aac:	29 23       	sub	r3,-110
80003aae:	c1 28       	rjmp	80003ad2 <_malloc_r+0xbe>
80003ab0:	e0 43 01 54 	cp.w	r3,340
80003ab4:	e0 8b 00 06 	brhi	80003ac0 <_malloc_r+0xac>
80003ab8:	ee 03 16 0f 	lsr	r3,r7,0xf
80003abc:	28 93       	sub	r3,-119
80003abe:	c0 a8       	rjmp	80003ad2 <_malloc_r+0xbe>
80003ac0:	e0 43 05 54 	cp.w	r3,1364
80003ac4:	e0 88 00 04 	brls	80003acc <_malloc_r+0xb8>
80003ac8:	37 e3       	mov	r3,126
80003aca:	c0 48       	rjmp	80003ad2 <_malloc_r+0xbe>
80003acc:	ee 03 16 12 	lsr	r3,r7,0x12
80003ad0:	28 43       	sub	r3,-124
80003ad2:	e0 6a 01 1c 	mov	r10,284
80003ad6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80003ada:	74 36       	ld.w	r6,r10[0xc]
80003adc:	c1 98       	rjmp	80003b0e <_malloc_r+0xfa>
80003ade:	6c 19       	ld.w	r9,r6[0x4]
80003ae0:	e0 19 ff fc 	andl	r9,0xfffc
80003ae4:	f2 07 01 0b 	sub	r11,r9,r7
80003ae8:	58 fb       	cp.w	r11,15
80003aea:	e0 8a 00 04 	brle	80003af2 <_malloc_r+0xde>
80003aee:	20 13       	sub	r3,1
80003af0:	c1 18       	rjmp	80003b12 <_malloc_r+0xfe>
80003af2:	6c 38       	ld.w	r8,r6[0xc]
80003af4:	58 0b       	cp.w	r11,0
80003af6:	c0 b5       	brlt	80003b0c <_malloc_r+0xf8>
80003af8:	6c 2a       	ld.w	r10,r6[0x8]
80003afa:	ec 09 00 09 	add	r9,r6,r9
80003afe:	0a 9c       	mov	r12,r5
80003b00:	91 2a       	st.w	r8[0x8],r10
80003b02:	95 38       	st.w	r10[0xc],r8
80003b04:	72 18       	ld.w	r8,r9[0x4]
80003b06:	a1 a8       	sbr	r8,0x0
80003b08:	93 18       	st.w	r9[0x4],r8
80003b0a:	cb c8       	rjmp	80003c82 <_malloc_r+0x26e>
80003b0c:	10 96       	mov	r6,r8
80003b0e:	14 36       	cp.w	r6,r10
80003b10:	ce 71       	brne	80003ade <_malloc_r+0xca>
80003b12:	2f f3       	sub	r3,-1
80003b14:	e0 6a 01 1c 	mov	r10,284
80003b18:	f4 cc ff f8 	sub	r12,r10,-8
80003b1c:	78 26       	ld.w	r6,r12[0x8]
80003b1e:	18 36       	cp.w	r6,r12
80003b20:	c6 c0       	breq	80003bf8 <_malloc_r+0x1e4>
80003b22:	6c 19       	ld.w	r9,r6[0x4]
80003b24:	e0 19 ff fc 	andl	r9,0xfffc
80003b28:	f2 07 01 08 	sub	r8,r9,r7
80003b2c:	58 f8       	cp.w	r8,15
80003b2e:	e0 89 00 8f 	brgt	80003c4c <_malloc_r+0x238>
80003b32:	99 3c       	st.w	r12[0xc],r12
80003b34:	99 2c       	st.w	r12[0x8],r12
80003b36:	58 08       	cp.w	r8,0
80003b38:	c0 55       	brlt	80003b42 <_malloc_r+0x12e>
80003b3a:	ec 09 00 09 	add	r9,r6,r9
80003b3e:	0a 9c       	mov	r12,r5
80003b40:	ce 2b       	rjmp	80003b04 <_malloc_r+0xf0>
80003b42:	e0 49 01 ff 	cp.w	r9,511
80003b46:	e0 8b 00 13 	brhi	80003b6c <_malloc_r+0x158>
80003b4a:	a3 99       	lsr	r9,0x3
80003b4c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80003b50:	70 2b       	ld.w	r11,r8[0x8]
80003b52:	8d 38       	st.w	r6[0xc],r8
80003b54:	8d 2b       	st.w	r6[0x8],r11
80003b56:	97 36       	st.w	r11[0xc],r6
80003b58:	91 26       	st.w	r8[0x8],r6
80003b5a:	a3 49       	asr	r9,0x2
80003b5c:	74 18       	ld.w	r8,r10[0x4]
80003b5e:	30 1b       	mov	r11,1
80003b60:	f6 09 09 49 	lsl	r9,r11,r9
80003b64:	f1 e9 10 09 	or	r9,r8,r9
80003b68:	95 19       	st.w	r10[0x4],r9
80003b6a:	c4 78       	rjmp	80003bf8 <_malloc_r+0x1e4>
80003b6c:	f2 0a 16 09 	lsr	r10,r9,0x9
80003b70:	58 4a       	cp.w	r10,4
80003b72:	e0 8b 00 07 	brhi	80003b80 <_malloc_r+0x16c>
80003b76:	f2 0a 16 06 	lsr	r10,r9,0x6
80003b7a:	2c 8a       	sub	r10,-56
80003b7c:	c2 08       	rjmp	80003bbc <_malloc_r+0x1a8>
80003b7e:	d7 03       	nop
80003b80:	59 4a       	cp.w	r10,20
80003b82:	e0 8b 00 04 	brhi	80003b8a <_malloc_r+0x176>
80003b86:	2a 5a       	sub	r10,-91
80003b88:	c1 a8       	rjmp	80003bbc <_malloc_r+0x1a8>
80003b8a:	e0 4a 00 54 	cp.w	r10,84
80003b8e:	e0 8b 00 06 	brhi	80003b9a <_malloc_r+0x186>
80003b92:	f2 0a 16 0c 	lsr	r10,r9,0xc
80003b96:	29 2a       	sub	r10,-110
80003b98:	c1 28       	rjmp	80003bbc <_malloc_r+0x1a8>
80003b9a:	e0 4a 01 54 	cp.w	r10,340
80003b9e:	e0 8b 00 06 	brhi	80003baa <_malloc_r+0x196>
80003ba2:	f2 0a 16 0f 	lsr	r10,r9,0xf
80003ba6:	28 9a       	sub	r10,-119
80003ba8:	c0 a8       	rjmp	80003bbc <_malloc_r+0x1a8>
80003baa:	e0 4a 05 54 	cp.w	r10,1364
80003bae:	e0 88 00 04 	brls	80003bb6 <_malloc_r+0x1a2>
80003bb2:	37 ea       	mov	r10,126
80003bb4:	c0 48       	rjmp	80003bbc <_malloc_r+0x1a8>
80003bb6:	f2 0a 16 12 	lsr	r10,r9,0x12
80003bba:	28 4a       	sub	r10,-124
80003bbc:	e0 6b 01 1c 	mov	r11,284
80003bc0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80003bc4:	68 28       	ld.w	r8,r4[0x8]
80003bc6:	08 38       	cp.w	r8,r4
80003bc8:	c0 e1       	brne	80003be4 <_malloc_r+0x1d0>
80003bca:	76 19       	ld.w	r9,r11[0x4]
80003bcc:	a3 4a       	asr	r10,0x2
80003bce:	30 1e       	mov	lr,1
80003bd0:	fc 0a 09 4a 	lsl	r10,lr,r10
80003bd4:	f3 ea 10 0a 	or	r10,r9,r10
80003bd8:	10 99       	mov	r9,r8
80003bda:	97 1a       	st.w	r11[0x4],r10
80003bdc:	c0 a8       	rjmp	80003bf0 <_malloc_r+0x1dc>
80003bde:	70 28       	ld.w	r8,r8[0x8]
80003be0:	08 38       	cp.w	r8,r4
80003be2:	c0 60       	breq	80003bee <_malloc_r+0x1da>
80003be4:	70 1a       	ld.w	r10,r8[0x4]
80003be6:	e0 1a ff fc 	andl	r10,0xfffc
80003bea:	14 39       	cp.w	r9,r10
80003bec:	cf 93       	brcs	80003bde <_malloc_r+0x1ca>
80003bee:	70 39       	ld.w	r9,r8[0xc]
80003bf0:	8d 39       	st.w	r6[0xc],r9
80003bf2:	8d 28       	st.w	r6[0x8],r8
80003bf4:	91 36       	st.w	r8[0xc],r6
80003bf6:	93 26       	st.w	r9[0x8],r6
80003bf8:	e6 08 14 02 	asr	r8,r3,0x2
80003bfc:	30 1b       	mov	r11,1
80003bfe:	e0 64 01 1c 	mov	r4,284
80003c02:	f6 08 09 4b 	lsl	r11,r11,r8
80003c06:	68 18       	ld.w	r8,r4[0x4]
80003c08:	10 3b       	cp.w	r11,r8
80003c0a:	e0 8b 00 6b 	brhi	80003ce0 <_malloc_r+0x2cc>
80003c0e:	f7 e8 00 09 	and	r9,r11,r8
80003c12:	c0 b1       	brne	80003c28 <_malloc_r+0x214>
80003c14:	e0 13 ff fc 	andl	r3,0xfffc
80003c18:	a1 7b       	lsl	r11,0x1
80003c1a:	2f c3       	sub	r3,-4
80003c1c:	c0 38       	rjmp	80003c22 <_malloc_r+0x20e>
80003c1e:	2f c3       	sub	r3,-4
80003c20:	a1 7b       	lsl	r11,0x1
80003c22:	f7 e8 00 09 	and	r9,r11,r8
80003c26:	cf c0       	breq	80003c1e <_malloc_r+0x20a>
80003c28:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80003c2c:	06 92       	mov	r2,r3
80003c2e:	1c 91       	mov	r1,lr
80003c30:	62 36       	ld.w	r6,r1[0xc]
80003c32:	c2 e8       	rjmp	80003c8e <_malloc_r+0x27a>
80003c34:	6c 1a       	ld.w	r10,r6[0x4]
80003c36:	e0 1a ff fc 	andl	r10,0xfffc
80003c3a:	f4 07 01 08 	sub	r8,r10,r7
80003c3e:	58 f8       	cp.w	r8,15
80003c40:	e0 8a 00 15 	brle	80003c6a <_malloc_r+0x256>
80003c44:	6c 3a       	ld.w	r10,r6[0xc]
80003c46:	6c 29       	ld.w	r9,r6[0x8]
80003c48:	95 29       	st.w	r10[0x8],r9
80003c4a:	93 3a       	st.w	r9[0xc],r10
80003c4c:	0e 99       	mov	r9,r7
80003c4e:	ec 07 00 07 	add	r7,r6,r7
80003c52:	a1 a9       	sbr	r9,0x0
80003c54:	99 37       	st.w	r12[0xc],r7
80003c56:	99 27       	st.w	r12[0x8],r7
80003c58:	8d 19       	st.w	r6[0x4],r9
80003c5a:	ee 08 09 08 	st.w	r7[r8],r8
80003c5e:	8f 2c       	st.w	r7[0x8],r12
80003c60:	8f 3c       	st.w	r7[0xc],r12
80003c62:	a1 a8       	sbr	r8,0x0
80003c64:	0a 9c       	mov	r12,r5
80003c66:	8f 18       	st.w	r7[0x4],r8
80003c68:	c0 d8       	rjmp	80003c82 <_malloc_r+0x26e>
80003c6a:	6c 39       	ld.w	r9,r6[0xc]
80003c6c:	58 08       	cp.w	r8,0
80003c6e:	c0 f5       	brlt	80003c8c <_malloc_r+0x278>
80003c70:	ec 0a 00 0a 	add	r10,r6,r10
80003c74:	74 18       	ld.w	r8,r10[0x4]
80003c76:	a1 a8       	sbr	r8,0x0
80003c78:	0a 9c       	mov	r12,r5
80003c7a:	95 18       	st.w	r10[0x4],r8
80003c7c:	6c 28       	ld.w	r8,r6[0x8]
80003c7e:	93 28       	st.w	r9[0x8],r8
80003c80:	91 39       	st.w	r8[0xc],r9
80003c82:	fe b0 f8 5b 	rcall	80002d38 <__malloc_unlock>
80003c86:	ec cc ff f8 	sub	r12,r6,-8
80003c8a:	d8 32       	popm	r0-r7,pc
80003c8c:	12 96       	mov	r6,r9
80003c8e:	02 36       	cp.w	r6,r1
80003c90:	cd 21       	brne	80003c34 <_malloc_r+0x220>
80003c92:	2f f2       	sub	r2,-1
80003c94:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80003c98:	c0 30       	breq	80003c9e <_malloc_r+0x28a>
80003c9a:	2f 81       	sub	r1,-8
80003c9c:	cc ab       	rjmp	80003c30 <_malloc_r+0x21c>
80003c9e:	1c 98       	mov	r8,lr
80003ca0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80003ca4:	c0 81       	brne	80003cb4 <_malloc_r+0x2a0>
80003ca6:	68 19       	ld.w	r9,r4[0x4]
80003ca8:	f6 08 11 ff 	rsub	r8,r11,-1
80003cac:	f3 e8 00 08 	and	r8,r9,r8
80003cb0:	89 18       	st.w	r4[0x4],r8
80003cb2:	c0 78       	rjmp	80003cc0 <_malloc_r+0x2ac>
80003cb4:	f0 c9 00 08 	sub	r9,r8,8
80003cb8:	20 13       	sub	r3,1
80003cba:	70 08       	ld.w	r8,r8[0x0]
80003cbc:	12 38       	cp.w	r8,r9
80003cbe:	cf 10       	breq	80003ca0 <_malloc_r+0x28c>
80003cc0:	a1 7b       	lsl	r11,0x1
80003cc2:	68 18       	ld.w	r8,r4[0x4]
80003cc4:	10 3b       	cp.w	r11,r8
80003cc6:	e0 8b 00 0d 	brhi	80003ce0 <_malloc_r+0x2cc>
80003cca:	58 0b       	cp.w	r11,0
80003ccc:	c0 a0       	breq	80003ce0 <_malloc_r+0x2cc>
80003cce:	04 93       	mov	r3,r2
80003cd0:	c0 38       	rjmp	80003cd6 <_malloc_r+0x2c2>
80003cd2:	2f c3       	sub	r3,-4
80003cd4:	a1 7b       	lsl	r11,0x1
80003cd6:	f7 e8 00 09 	and	r9,r11,r8
80003cda:	ca 71       	brne	80003c28 <_malloc_r+0x214>
80003cdc:	cf bb       	rjmp	80003cd2 <_malloc_r+0x2be>
80003cde:	d7 03       	nop
80003ce0:	68 23       	ld.w	r3,r4[0x8]
80003ce2:	66 12       	ld.w	r2,r3[0x4]
80003ce4:	e0 12 ff fc 	andl	r2,0xfffc
80003ce8:	0e 32       	cp.w	r2,r7
80003cea:	5f 39       	srlo	r9
80003cec:	e4 07 01 08 	sub	r8,r2,r7
80003cf0:	58 f8       	cp.w	r8,15
80003cf2:	5f aa       	srle	r10
80003cf4:	f5 e9 10 09 	or	r9,r10,r9
80003cf8:	e0 80 00 98 	breq	80003e28 <_malloc_r+0x414>
80003cfc:	e0 68 07 58 	mov	r8,1880
80003d00:	70 01       	ld.w	r1,r8[0x0]
80003d02:	e0 68 05 28 	mov	r8,1320
80003d06:	2f 01       	sub	r1,-16
80003d08:	70 08       	ld.w	r8,r8[0x0]
80003d0a:	0e 01       	add	r1,r7
80003d0c:	5b f8       	cp.w	r8,-1
80003d0e:	c0 40       	breq	80003d16 <_malloc_r+0x302>
80003d10:	28 11       	sub	r1,-127
80003d12:	e0 11 ff 80 	andl	r1,0xff80
80003d16:	02 9b       	mov	r11,r1
80003d18:	0a 9c       	mov	r12,r5
80003d1a:	c3 bd       	rcall	80003f90 <_sbrk_r>
80003d1c:	18 96       	mov	r6,r12
80003d1e:	5b fc       	cp.w	r12,-1
80003d20:	c7 40       	breq	80003e08 <_malloc_r+0x3f4>
80003d22:	e6 02 00 08 	add	r8,r3,r2
80003d26:	10 3c       	cp.w	r12,r8
80003d28:	c0 32       	brcc	80003d2e <_malloc_r+0x31a>
80003d2a:	08 33       	cp.w	r3,r4
80003d2c:	c6 e1       	brne	80003e08 <_malloc_r+0x3f4>
80003d2e:	e0 6a 07 5c 	mov	r10,1884
80003d32:	74 09       	ld.w	r9,r10[0x0]
80003d34:	e2 09 00 09 	add	r9,r1,r9
80003d38:	95 09       	st.w	r10[0x0],r9
80003d3a:	10 36       	cp.w	r6,r8
80003d3c:	c0 a1       	brne	80003d50 <_malloc_r+0x33c>
80003d3e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80003d42:	c0 71       	brne	80003d50 <_malloc_r+0x33c>
80003d44:	e2 02 00 02 	add	r2,r1,r2
80003d48:	68 28       	ld.w	r8,r4[0x8]
80003d4a:	a1 a2       	sbr	r2,0x0
80003d4c:	91 12       	st.w	r8[0x4],r2
80003d4e:	c4 e8       	rjmp	80003dea <_malloc_r+0x3d6>
80003d50:	e0 6a 05 28 	mov	r10,1320
80003d54:	74 0b       	ld.w	r11,r10[0x0]
80003d56:	5b fb       	cp.w	r11,-1
80003d58:	c0 31       	brne	80003d5e <_malloc_r+0x34a>
80003d5a:	95 06       	st.w	r10[0x0],r6
80003d5c:	c0 78       	rjmp	80003d6a <_malloc_r+0x356>
80003d5e:	ec 09 00 09 	add	r9,r6,r9
80003d62:	e0 6a 07 5c 	mov	r10,1884
80003d66:	10 19       	sub	r9,r8
80003d68:	95 09       	st.w	r10[0x0],r9
80003d6a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80003d6e:	f0 09 11 08 	rsub	r9,r8,8
80003d72:	58 08       	cp.w	r8,0
80003d74:	f2 08 17 10 	movne	r8,r9
80003d78:	ed d8 e1 06 	addne	r6,r6,r8
80003d7c:	28 08       	sub	r8,-128
80003d7e:	ec 01 00 01 	add	r1,r6,r1
80003d82:	0a 9c       	mov	r12,r5
80003d84:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80003d88:	f0 01 01 01 	sub	r1,r8,r1
80003d8c:	02 9b       	mov	r11,r1
80003d8e:	c0 1d       	rcall	80003f90 <_sbrk_r>
80003d90:	e0 68 07 5c 	mov	r8,1884
80003d94:	5b fc       	cp.w	r12,-1
80003d96:	ec 0c 17 00 	moveq	r12,r6
80003d9a:	f9 b1 00 00 	moveq	r1,0
80003d9e:	70 09       	ld.w	r9,r8[0x0]
80003da0:	0c 1c       	sub	r12,r6
80003da2:	89 26       	st.w	r4[0x8],r6
80003da4:	02 0c       	add	r12,r1
80003da6:	12 01       	add	r1,r9
80003da8:	a1 ac       	sbr	r12,0x0
80003daa:	91 01       	st.w	r8[0x0],r1
80003dac:	8d 1c       	st.w	r6[0x4],r12
80003dae:	08 33       	cp.w	r3,r4
80003db0:	c1 d0       	breq	80003dea <_malloc_r+0x3d6>
80003db2:	58 f2       	cp.w	r2,15
80003db4:	e0 8b 00 05 	brhi	80003dbe <_malloc_r+0x3aa>
80003db8:	30 18       	mov	r8,1
80003dba:	8d 18       	st.w	r6[0x4],r8
80003dbc:	c2 68       	rjmp	80003e08 <_malloc_r+0x3f4>
80003dbe:	30 59       	mov	r9,5
80003dc0:	20 c2       	sub	r2,12
80003dc2:	e0 12 ff f8 	andl	r2,0xfff8
80003dc6:	e6 02 00 08 	add	r8,r3,r2
80003dca:	91 29       	st.w	r8[0x8],r9
80003dcc:	91 19       	st.w	r8[0x4],r9
80003dce:	66 18       	ld.w	r8,r3[0x4]
80003dd0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003dd4:	e5 e8 10 08 	or	r8,r2,r8
80003dd8:	87 18       	st.w	r3[0x4],r8
80003dda:	58 f2       	cp.w	r2,15
80003ddc:	e0 88 00 07 	brls	80003dea <_malloc_r+0x3d6>
80003de0:	e6 cb ff f8 	sub	r11,r3,-8
80003de4:	0a 9c       	mov	r12,r5
80003de6:	e0 a0 02 11 	rcall	80004208 <_free_r>
80003dea:	e0 69 07 54 	mov	r9,1876
80003dee:	72 0a       	ld.w	r10,r9[0x0]
80003df0:	e0 68 07 5c 	mov	r8,1884
80003df4:	70 08       	ld.w	r8,r8[0x0]
80003df6:	14 38       	cp.w	r8,r10
80003df8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003dfc:	e0 69 07 50 	mov	r9,1872
80003e00:	72 0a       	ld.w	r10,r9[0x0]
80003e02:	14 38       	cp.w	r8,r10
80003e04:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80003e08:	68 28       	ld.w	r8,r4[0x8]
80003e0a:	70 18       	ld.w	r8,r8[0x4]
80003e0c:	e0 18 ff fc 	andl	r8,0xfffc
80003e10:	0e 38       	cp.w	r8,r7
80003e12:	5f 39       	srlo	r9
80003e14:	0e 18       	sub	r8,r7
80003e16:	58 f8       	cp.w	r8,15
80003e18:	5f aa       	srle	r10
80003e1a:	f5 e9 10 09 	or	r9,r10,r9
80003e1e:	c0 50       	breq	80003e28 <_malloc_r+0x414>
80003e20:	0a 9c       	mov	r12,r5
80003e22:	fe b0 f7 8b 	rcall	80002d38 <__malloc_unlock>
80003e26:	d8 3a       	popm	r0-r7,pc,r12=0
80003e28:	68 26       	ld.w	r6,r4[0x8]
80003e2a:	a1 a8       	sbr	r8,0x0
80003e2c:	0e 99       	mov	r9,r7
80003e2e:	a1 a9       	sbr	r9,0x0
80003e30:	8d 19       	st.w	r6[0x4],r9
80003e32:	ec 07 00 07 	add	r7,r6,r7
80003e36:	0a 9c       	mov	r12,r5
80003e38:	89 27       	st.w	r4[0x8],r7
80003e3a:	8f 18       	st.w	r7[0x4],r8
80003e3c:	fe b0 f7 7e 	rcall	80002d38 <__malloc_unlock>
80003e40:	ec cc ff f8 	sub	r12,r6,-8
80003e44:	d8 32       	popm	r0-r7,pc
80003e46:	d7 03       	nop

80003e48 <memcpy>:
80003e48:	58 8a       	cp.w	r10,8
80003e4a:	c2 f5       	brlt	80003ea8 <memcpy+0x60>
80003e4c:	f9 eb 10 09 	or	r9,r12,r11
80003e50:	e2 19 00 03 	andl	r9,0x3,COH
80003e54:	e0 81 00 97 	brne	80003f82 <memcpy+0x13a>
80003e58:	e0 4a 00 20 	cp.w	r10,32
80003e5c:	c3 b4       	brge	80003ed2 <memcpy+0x8a>
80003e5e:	f4 08 14 02 	asr	r8,r10,0x2
80003e62:	f0 09 11 08 	rsub	r9,r8,8
80003e66:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80003e6a:	76 69       	ld.w	r9,r11[0x18]
80003e6c:	99 69       	st.w	r12[0x18],r9
80003e6e:	76 59       	ld.w	r9,r11[0x14]
80003e70:	99 59       	st.w	r12[0x14],r9
80003e72:	76 49       	ld.w	r9,r11[0x10]
80003e74:	99 49       	st.w	r12[0x10],r9
80003e76:	76 39       	ld.w	r9,r11[0xc]
80003e78:	99 39       	st.w	r12[0xc],r9
80003e7a:	76 29       	ld.w	r9,r11[0x8]
80003e7c:	99 29       	st.w	r12[0x8],r9
80003e7e:	76 19       	ld.w	r9,r11[0x4]
80003e80:	99 19       	st.w	r12[0x4],r9
80003e82:	76 09       	ld.w	r9,r11[0x0]
80003e84:	99 09       	st.w	r12[0x0],r9
80003e86:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80003e8a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80003e8e:	e0 1a 00 03 	andl	r10,0x3
80003e92:	f4 0a 11 04 	rsub	r10,r10,4
80003e96:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003e9a:	17 a9       	ld.ub	r9,r11[0x2]
80003e9c:	b0 a9       	st.b	r8[0x2],r9
80003e9e:	17 99       	ld.ub	r9,r11[0x1]
80003ea0:	b0 99       	st.b	r8[0x1],r9
80003ea2:	17 89       	ld.ub	r9,r11[0x0]
80003ea4:	b0 89       	st.b	r8[0x0],r9
80003ea6:	5e fc       	retal	r12
80003ea8:	f4 0a 11 09 	rsub	r10,r10,9
80003eac:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80003eb0:	17 f9       	ld.ub	r9,r11[0x7]
80003eb2:	b8 f9       	st.b	r12[0x7],r9
80003eb4:	17 e9       	ld.ub	r9,r11[0x6]
80003eb6:	b8 e9       	st.b	r12[0x6],r9
80003eb8:	17 d9       	ld.ub	r9,r11[0x5]
80003eba:	b8 d9       	st.b	r12[0x5],r9
80003ebc:	17 c9       	ld.ub	r9,r11[0x4]
80003ebe:	b8 c9       	st.b	r12[0x4],r9
80003ec0:	17 b9       	ld.ub	r9,r11[0x3]
80003ec2:	b8 b9       	st.b	r12[0x3],r9
80003ec4:	17 a9       	ld.ub	r9,r11[0x2]
80003ec6:	b8 a9       	st.b	r12[0x2],r9
80003ec8:	17 99       	ld.ub	r9,r11[0x1]
80003eca:	b8 99       	st.b	r12[0x1],r9
80003ecc:	17 89       	ld.ub	r9,r11[0x0]
80003ece:	b8 89       	st.b	r12[0x0],r9
80003ed0:	5e fc       	retal	r12
80003ed2:	eb cd 40 c0 	pushm	r6-r7,lr
80003ed6:	18 99       	mov	r9,r12
80003ed8:	22 0a       	sub	r10,32
80003eda:	b7 07       	ld.d	r6,r11++
80003edc:	b3 26       	st.d	r9++,r6
80003ede:	b7 07       	ld.d	r6,r11++
80003ee0:	b3 26       	st.d	r9++,r6
80003ee2:	b7 07       	ld.d	r6,r11++
80003ee4:	b3 26       	st.d	r9++,r6
80003ee6:	b7 07       	ld.d	r6,r11++
80003ee8:	b3 26       	st.d	r9++,r6
80003eea:	22 0a       	sub	r10,32
80003eec:	cf 74       	brge	80003eda <memcpy+0x92>
80003eee:	2f 0a       	sub	r10,-16
80003ef0:	c0 65       	brlt	80003efc <memcpy+0xb4>
80003ef2:	b7 07       	ld.d	r6,r11++
80003ef4:	b3 26       	st.d	r9++,r6
80003ef6:	b7 07       	ld.d	r6,r11++
80003ef8:	b3 26       	st.d	r9++,r6
80003efa:	21 0a       	sub	r10,16
80003efc:	5c 3a       	neg	r10
80003efe:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80003f02:	d7 03       	nop
80003f04:	d7 03       	nop
80003f06:	f7 36 00 0e 	ld.ub	r6,r11[14]
80003f0a:	f3 66 00 0e 	st.b	r9[14],r6
80003f0e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80003f12:	f3 66 00 0d 	st.b	r9[13],r6
80003f16:	f7 36 00 0c 	ld.ub	r6,r11[12]
80003f1a:	f3 66 00 0c 	st.b	r9[12],r6
80003f1e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80003f22:	f3 66 00 0b 	st.b	r9[11],r6
80003f26:	f7 36 00 0a 	ld.ub	r6,r11[10]
80003f2a:	f3 66 00 0a 	st.b	r9[10],r6
80003f2e:	f7 36 00 09 	ld.ub	r6,r11[9]
80003f32:	f3 66 00 09 	st.b	r9[9],r6
80003f36:	f7 36 00 08 	ld.ub	r6,r11[8]
80003f3a:	f3 66 00 08 	st.b	r9[8],r6
80003f3e:	f7 36 00 07 	ld.ub	r6,r11[7]
80003f42:	f3 66 00 07 	st.b	r9[7],r6
80003f46:	f7 36 00 06 	ld.ub	r6,r11[6]
80003f4a:	f3 66 00 06 	st.b	r9[6],r6
80003f4e:	f7 36 00 05 	ld.ub	r6,r11[5]
80003f52:	f3 66 00 05 	st.b	r9[5],r6
80003f56:	f7 36 00 04 	ld.ub	r6,r11[4]
80003f5a:	f3 66 00 04 	st.b	r9[4],r6
80003f5e:	f7 36 00 03 	ld.ub	r6,r11[3]
80003f62:	f3 66 00 03 	st.b	r9[3],r6
80003f66:	f7 36 00 02 	ld.ub	r6,r11[2]
80003f6a:	f3 66 00 02 	st.b	r9[2],r6
80003f6e:	f7 36 00 01 	ld.ub	r6,r11[1]
80003f72:	f3 66 00 01 	st.b	r9[1],r6
80003f76:	f7 36 00 00 	ld.ub	r6,r11[0]
80003f7a:	f3 66 00 00 	st.b	r9[0],r6
80003f7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003f82:	20 1a       	sub	r10,1
80003f84:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80003f88:	f8 0a 0b 09 	st.b	r12[r10],r9
80003f8c:	cf b1       	brne	80003f82 <memcpy+0x13a>
80003f8e:	5e fc       	retal	r12

80003f90 <_sbrk_r>:
80003f90:	d4 21       	pushm	r4-r7,lr
80003f92:	30 08       	mov	r8,0
80003f94:	18 97       	mov	r7,r12
80003f96:	e0 66 07 90 	mov	r6,1936
80003f9a:	16 9c       	mov	r12,r11
80003f9c:	8d 08       	st.w	r6[0x0],r8
80003f9e:	c1 3c       	rcall	80003fc4 <_sbrk>
80003fa0:	5b fc       	cp.w	r12,-1
80003fa2:	c0 51       	brne	80003fac <_sbrk_r+0x1c>
80003fa4:	6c 08       	ld.w	r8,r6[0x0]
80003fa6:	58 08       	cp.w	r8,0
80003fa8:	ef f8 1a 03 	st.wne	r7[0xc],r8
80003fac:	d8 22       	popm	r4-r7,pc
80003fae:	d7 03       	nop

80003fb0 <_init_argv>:
80003fb0:	30 e8       	mov	r8,14
80003fb2:	d6 73       	breakpoint
80003fb4:	3f fc       	mov	r12,-1
80003fb6:	35 8b       	mov	r11,88
80003fb8:	5e fc       	retal	r12

80003fba <_exit>:
80003fba:	30 d8       	mov	r8,13
80003fbc:	d6 73       	breakpoint
80003fbe:	3f fc       	mov	r12,-1
80003fc0:	35 8b       	mov	r11,88
80003fc2:	c0 08       	rjmp	80003fc2 <_exit+0x8>

80003fc4 <_sbrk>:
80003fc4:	d4 01       	pushm	lr
80003fc6:	e0 68 07 84 	mov	r8,1924
80003fca:	70 09       	ld.w	r9,r8[0x0]
80003fcc:	58 09       	cp.w	r9,0
80003fce:	c0 41       	brne	80003fd6 <_sbrk+0x12>
80003fd0:	e0 69 07 98 	mov	r9,1944
80003fd4:	91 09       	st.w	r8[0x0],r9
80003fd6:	e0 69 07 84 	mov	r9,1924
80003fda:	e0 6a f0 00 	mov	r10,61440
80003fde:	72 08       	ld.w	r8,r9[0x0]
80003fe0:	f0 0c 00 0c 	add	r12,r8,r12
80003fe4:	14 3c       	cp.w	r12,r10
80003fe6:	e0 8b 00 04 	brhi	80003fee <_sbrk+0x2a>
80003fea:	93 0c       	st.w	r9[0x0],r12
80003fec:	c0 58       	rjmp	80003ff6 <_sbrk+0x32>
80003fee:	cb fc       	rcall	8000416c <__errno>
80003ff0:	30 c8       	mov	r8,12
80003ff2:	99 08       	st.w	r12[0x0],r8
80003ff4:	3f f8       	mov	r8,-1
80003ff6:	10 9c       	mov	r12,r8
80003ff8:	d8 02       	popm	pc
80003ffa:	d7 03       	nop

80003ffc <__register_exitproc>:
80003ffc:	d4 31       	pushm	r0-r7,lr
80003ffe:	fe c8 f8 be 	sub	r8,pc,-1858
80004002:	70 03       	ld.w	r3,r8[0x0]
80004004:	67 24       	ld.w	r4,r3[0x48]
80004006:	e6 c8 ff b4 	sub	r8,r3,-76
8000400a:	58 04       	cp.w	r4,0
8000400c:	f0 04 17 00 	moveq	r4,r8
80004010:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80004014:	18 97       	mov	r7,r12
80004016:	16 96       	mov	r6,r11
80004018:	14 95       	mov	r5,r10
8000401a:	12 92       	mov	r2,r9
8000401c:	68 18       	ld.w	r8,r4[0x4]
8000401e:	59 f8       	cp.w	r8,31
80004020:	e0 8a 00 0e 	brle	8000403c <__register_exitproc+0x40>
80004024:	e0 6c 00 8c 	mov	r12,140
80004028:	fe b0 fc ee 	rcall	80003a04 <malloc>
8000402c:	18 94       	mov	r4,r12
8000402e:	c3 80       	breq	8000409e <__register_exitproc+0xa2>
80004030:	67 28       	ld.w	r8,r3[0x48]
80004032:	99 08       	st.w	r12[0x0],r8
80004034:	e7 4c 00 48 	st.w	r3[72],r12
80004038:	30 08       	mov	r8,0
8000403a:	99 18       	st.w	r12[0x4],r8
8000403c:	58 07       	cp.w	r7,0
8000403e:	c2 70       	breq	8000408c <__register_exitproc+0x90>
80004040:	e8 fc 00 88 	ld.w	r12,r4[136]
80004044:	58 0c       	cp.w	r12,0
80004046:	c0 d1       	brne	80004060 <__register_exitproc+0x64>
80004048:	e0 6c 01 08 	mov	r12,264
8000404c:	fe b0 fc dc 	rcall	80003a04 <malloc>
80004050:	c2 70       	breq	8000409e <__register_exitproc+0xa2>
80004052:	30 08       	mov	r8,0
80004054:	e9 4c 00 88 	st.w	r4[136],r12
80004058:	f9 48 01 04 	st.w	r12[260],r8
8000405c:	f9 48 01 00 	st.w	r12[256],r8
80004060:	68 18       	ld.w	r8,r4[0x4]
80004062:	f0 c9 ff e0 	sub	r9,r8,-32
80004066:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000406a:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000406e:	30 1a       	mov	r10,1
80004070:	f8 f9 01 00 	ld.w	r9,r12[256]
80004074:	f4 08 09 48 	lsl	r8,r10,r8
80004078:	10 49       	or	r9,r8
8000407a:	f9 49 01 00 	st.w	r12[256],r9
8000407e:	58 27       	cp.w	r7,2
80004080:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80004084:	f3 d8 e0 38 	oreq	r8,r9,r8
80004088:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000408c:	68 18       	ld.w	r8,r4[0x4]
8000408e:	30 0c       	mov	r12,0
80004090:	f0 c9 ff ff 	sub	r9,r8,-1
80004094:	2f e8       	sub	r8,-2
80004096:	89 19       	st.w	r4[0x4],r9
80004098:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000409c:	d8 32       	popm	r0-r7,pc
8000409e:	dc 3a       	popm	r0-r7,pc,r12=-1

800040a0 <__call_exitprocs>:
800040a0:	d4 31       	pushm	r0-r7,lr
800040a2:	20 3d       	sub	sp,12
800040a4:	fe c8 f9 64 	sub	r8,pc,-1692
800040a8:	50 2c       	stdsp	sp[0x8],r12
800040aa:	70 08       	ld.w	r8,r8[0x0]
800040ac:	16 91       	mov	r1,r11
800040ae:	50 08       	stdsp	sp[0x0],r8
800040b0:	2b 88       	sub	r8,-72
800040b2:	50 18       	stdsp	sp[0x4],r8
800040b4:	40 0a       	lddsp	r10,sp[0x0]
800040b6:	40 14       	lddsp	r4,sp[0x4]
800040b8:	75 27       	ld.w	r7,r10[0x48]
800040ba:	c5 58       	rjmp	80004164 <__call_exitprocs+0xc4>
800040bc:	6e 15       	ld.w	r5,r7[0x4]
800040be:	ee f6 00 88 	ld.w	r6,r7[136]
800040c2:	ea c2 ff ff 	sub	r2,r5,-1
800040c6:	20 15       	sub	r5,1
800040c8:	ee 02 00 22 	add	r2,r7,r2<<0x2
800040cc:	ec 05 00 23 	add	r3,r6,r5<<0x2
800040d0:	c3 58       	rjmp	8000413a <__call_exitprocs+0x9a>
800040d2:	58 01       	cp.w	r1,0
800040d4:	c0 70       	breq	800040e2 <__call_exitprocs+0x42>
800040d6:	58 06       	cp.w	r6,0
800040d8:	c2 e0       	breq	80004134 <__call_exitprocs+0x94>
800040da:	e6 f8 00 80 	ld.w	r8,r3[128]
800040de:	02 38       	cp.w	r8,r1
800040e0:	c2 a1       	brne	80004134 <__call_exitprocs+0x94>
800040e2:	6e 19       	ld.w	r9,r7[0x4]
800040e4:	64 08       	ld.w	r8,r2[0x0]
800040e6:	20 19       	sub	r9,1
800040e8:	12 35       	cp.w	r5,r9
800040ea:	ef f5 0a 01 	st.weq	r7[0x4],r5
800040ee:	f9 b9 01 00 	movne	r9,0
800040f2:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800040f6:	58 08       	cp.w	r8,0
800040f8:	c1 e0       	breq	80004134 <__call_exitprocs+0x94>
800040fa:	6e 10       	ld.w	r0,r7[0x4]
800040fc:	58 06       	cp.w	r6,0
800040fe:	c0 90       	breq	80004110 <__call_exitprocs+0x70>
80004100:	30 1a       	mov	r10,1
80004102:	f4 05 09 49 	lsl	r9,r10,r5
80004106:	ec fa 01 00 	ld.w	r10,r6[256]
8000410a:	f3 ea 00 0a 	and	r10,r9,r10
8000410e:	c0 31       	brne	80004114 <__call_exitprocs+0x74>
80004110:	5d 18       	icall	r8
80004112:	c0 b8       	rjmp	80004128 <__call_exitprocs+0x88>
80004114:	ec fa 01 04 	ld.w	r10,r6[260]
80004118:	66 0b       	ld.w	r11,r3[0x0]
8000411a:	14 69       	and	r9,r10
8000411c:	c0 41       	brne	80004124 <__call_exitprocs+0x84>
8000411e:	40 2c       	lddsp	r12,sp[0x8]
80004120:	5d 18       	icall	r8
80004122:	c0 38       	rjmp	80004128 <__call_exitprocs+0x88>
80004124:	16 9c       	mov	r12,r11
80004126:	5d 18       	icall	r8
80004128:	6e 18       	ld.w	r8,r7[0x4]
8000412a:	10 30       	cp.w	r0,r8
8000412c:	cc 41       	brne	800040b4 <__call_exitprocs+0x14>
8000412e:	68 08       	ld.w	r8,r4[0x0]
80004130:	0e 38       	cp.w	r8,r7
80004132:	cc 11       	brne	800040b4 <__call_exitprocs+0x14>
80004134:	20 15       	sub	r5,1
80004136:	20 43       	sub	r3,4
80004138:	20 42       	sub	r2,4
8000413a:	58 05       	cp.w	r5,0
8000413c:	cc b4       	brge	800040d2 <__call_exitprocs+0x32>
8000413e:	6e 18       	ld.w	r8,r7[0x4]
80004140:	58 08       	cp.w	r8,0
80004142:	c0 f1       	brne	80004160 <__call_exitprocs+0xc0>
80004144:	6e 08       	ld.w	r8,r7[0x0]
80004146:	58 08       	cp.w	r8,0
80004148:	c0 c0       	breq	80004160 <__call_exitprocs+0xc0>
8000414a:	89 08       	st.w	r4[0x0],r8
8000414c:	58 06       	cp.w	r6,0
8000414e:	c0 40       	breq	80004156 <__call_exitprocs+0xb6>
80004150:	0c 9c       	mov	r12,r6
80004152:	fe b0 fc 51 	rcall	800039f4 <free>
80004156:	0e 9c       	mov	r12,r7
80004158:	fe b0 fc 4e 	rcall	800039f4 <free>
8000415c:	68 07       	ld.w	r7,r4[0x0]
8000415e:	c0 38       	rjmp	80004164 <__call_exitprocs+0xc4>
80004160:	0e 94       	mov	r4,r7
80004162:	6e 07       	ld.w	r7,r7[0x0]
80004164:	58 07       	cp.w	r7,0
80004166:	ca b1       	brne	800040bc <__call_exitprocs+0x1c>
80004168:	2f dd       	sub	sp,-12
8000416a:	d8 32       	popm	r0-r7,pc

8000416c <__errno>:
8000416c:	e0 68 01 18 	mov	r8,280
80004170:	70 0c       	ld.w	r12,r8[0x0]
80004172:	2f 4c       	sub	r12,-12
80004174:	5e fc       	retal	r12
80004176:	d7 03       	nop

80004178 <_malloc_trim_r>:
80004178:	d4 21       	pushm	r4-r7,lr
8000417a:	16 95       	mov	r5,r11
8000417c:	18 97       	mov	r7,r12
8000417e:	fe b0 f5 d7 	rcall	80002d2c <__malloc_lock>
80004182:	e0 64 01 1c 	mov	r4,284
80004186:	68 28       	ld.w	r8,r4[0x8]
80004188:	70 16       	ld.w	r6,r8[0x4]
8000418a:	e0 16 ff fc 	andl	r6,0xfffc
8000418e:	ec c8 ff 91 	sub	r8,r6,-111
80004192:	f0 05 01 05 	sub	r5,r8,r5
80004196:	e0 15 ff 80 	andl	r5,0xff80
8000419a:	ea c5 00 80 	sub	r5,r5,128
8000419e:	e0 45 00 7f 	cp.w	r5,127
800041a2:	e0 8a 00 22 	brle	800041e6 <_malloc_trim_r+0x6e>
800041a6:	30 0b       	mov	r11,0
800041a8:	0e 9c       	mov	r12,r7
800041aa:	cf 3e       	rcall	80003f90 <_sbrk_r>
800041ac:	68 28       	ld.w	r8,r4[0x8]
800041ae:	0c 08       	add	r8,r6
800041b0:	10 3c       	cp.w	r12,r8
800041b2:	c1 a1       	brne	800041e6 <_malloc_trim_r+0x6e>
800041b4:	ea 0b 11 00 	rsub	r11,r5,0
800041b8:	0e 9c       	mov	r12,r7
800041ba:	ce be       	rcall	80003f90 <_sbrk_r>
800041bc:	5b fc       	cp.w	r12,-1
800041be:	c1 81       	brne	800041ee <_malloc_trim_r+0x76>
800041c0:	30 0b       	mov	r11,0
800041c2:	0e 9c       	mov	r12,r7
800041c4:	ce 6e       	rcall	80003f90 <_sbrk_r>
800041c6:	68 28       	ld.w	r8,r4[0x8]
800041c8:	f8 08 01 09 	sub	r9,r12,r8
800041cc:	58 f9       	cp.w	r9,15
800041ce:	e0 8a 00 0c 	brle	800041e6 <_malloc_trim_r+0x6e>
800041d2:	a1 a9       	sbr	r9,0x0
800041d4:	91 19       	st.w	r8[0x4],r9
800041d6:	e0 68 05 28 	mov	r8,1320
800041da:	70 09       	ld.w	r9,r8[0x0]
800041dc:	e0 68 07 5c 	mov	r8,1884
800041e0:	f8 09 01 09 	sub	r9,r12,r9
800041e4:	91 09       	st.w	r8[0x0],r9
800041e6:	0e 9c       	mov	r12,r7
800041e8:	fe b0 f5 a8 	rcall	80002d38 <__malloc_unlock>
800041ec:	d8 2a       	popm	r4-r7,pc,r12=0
800041ee:	68 28       	ld.w	r8,r4[0x8]
800041f0:	0a 16       	sub	r6,r5
800041f2:	a1 a6       	sbr	r6,0x0
800041f4:	91 16       	st.w	r8[0x4],r6
800041f6:	e0 68 07 5c 	mov	r8,1884
800041fa:	70 09       	ld.w	r9,r8[0x0]
800041fc:	0a 19       	sub	r9,r5
800041fe:	0e 9c       	mov	r12,r7
80004200:	91 09       	st.w	r8[0x0],r9
80004202:	fe b0 f5 9b 	rcall	80002d38 <__malloc_unlock>
80004206:	da 2a       	popm	r4-r7,pc,r12=1

80004208 <_free_r>:
80004208:	d4 21       	pushm	r4-r7,lr
8000420a:	16 96       	mov	r6,r11
8000420c:	18 97       	mov	r7,r12
8000420e:	58 0b       	cp.w	r11,0
80004210:	e0 80 00 c0 	breq	80004390 <_free_r+0x188>
80004214:	fe b0 f5 8c 	rcall	80002d2c <__malloc_lock>
80004218:	20 86       	sub	r6,8
8000421a:	e0 6a 01 1c 	mov	r10,284
8000421e:	6c 18       	ld.w	r8,r6[0x4]
80004220:	74 2e       	ld.w	lr,r10[0x8]
80004222:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004226:	a1 c8       	cbr	r8,0x0
80004228:	ec 08 00 09 	add	r9,r6,r8
8000422c:	72 1b       	ld.w	r11,r9[0x4]
8000422e:	e0 1b ff fc 	andl	r11,0xfffc
80004232:	1c 39       	cp.w	r9,lr
80004234:	c1 e1       	brne	80004270 <_free_r+0x68>
80004236:	f6 08 00 08 	add	r8,r11,r8
8000423a:	58 0c       	cp.w	r12,0
8000423c:	c0 81       	brne	8000424c <_free_r+0x44>
8000423e:	6c 09       	ld.w	r9,r6[0x0]
80004240:	12 16       	sub	r6,r9
80004242:	12 08       	add	r8,r9
80004244:	6c 3b       	ld.w	r11,r6[0xc]
80004246:	6c 29       	ld.w	r9,r6[0x8]
80004248:	97 29       	st.w	r11[0x8],r9
8000424a:	93 3b       	st.w	r9[0xc],r11
8000424c:	10 99       	mov	r9,r8
8000424e:	95 26       	st.w	r10[0x8],r6
80004250:	a1 a9       	sbr	r9,0x0
80004252:	8d 19       	st.w	r6[0x4],r9
80004254:	e0 69 05 24 	mov	r9,1316
80004258:	72 09       	ld.w	r9,r9[0x0]
8000425a:	12 38       	cp.w	r8,r9
8000425c:	c0 63       	brcs	80004268 <_free_r+0x60>
8000425e:	e0 68 07 58 	mov	r8,1880
80004262:	0e 9c       	mov	r12,r7
80004264:	70 0b       	ld.w	r11,r8[0x0]
80004266:	c8 9f       	rcall	80004178 <_malloc_trim_r>
80004268:	0e 9c       	mov	r12,r7
8000426a:	fe b0 f5 67 	rcall	80002d38 <__malloc_unlock>
8000426e:	d8 22       	popm	r4-r7,pc
80004270:	93 1b       	st.w	r9[0x4],r11
80004272:	58 0c       	cp.w	r12,0
80004274:	c0 30       	breq	8000427a <_free_r+0x72>
80004276:	30 0c       	mov	r12,0
80004278:	c1 08       	rjmp	80004298 <_free_r+0x90>
8000427a:	6c 0e       	ld.w	lr,r6[0x0]
8000427c:	f4 c5 ff f8 	sub	r5,r10,-8
80004280:	1c 16       	sub	r6,lr
80004282:	1c 08       	add	r8,lr
80004284:	6c 2e       	ld.w	lr,r6[0x8]
80004286:	0a 3e       	cp.w	lr,r5
80004288:	f9 bc 00 01 	moveq	r12,1
8000428c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80004290:	eb fe 1a 02 	st.wne	r5[0x8],lr
80004294:	fd f5 1a 03 	st.wne	lr[0xc],r5
80004298:	f2 0b 00 0e 	add	lr,r9,r11
8000429c:	7c 1e       	ld.w	lr,lr[0x4]
8000429e:	ed be 00 00 	bld	lr,0x0
800042a2:	c1 40       	breq	800042ca <_free_r+0xc2>
800042a4:	16 08       	add	r8,r11
800042a6:	58 0c       	cp.w	r12,0
800042a8:	c0 d1       	brne	800042c2 <_free_r+0xba>
800042aa:	e0 6e 01 1c 	mov	lr,284
800042ae:	72 2b       	ld.w	r11,r9[0x8]
800042b0:	2f 8e       	sub	lr,-8
800042b2:	1c 3b       	cp.w	r11,lr
800042b4:	c0 71       	brne	800042c2 <_free_r+0xba>
800042b6:	97 36       	st.w	r11[0xc],r6
800042b8:	97 26       	st.w	r11[0x8],r6
800042ba:	8d 2b       	st.w	r6[0x8],r11
800042bc:	8d 3b       	st.w	r6[0xc],r11
800042be:	30 1c       	mov	r12,1
800042c0:	c0 58       	rjmp	800042ca <_free_r+0xc2>
800042c2:	72 2b       	ld.w	r11,r9[0x8]
800042c4:	72 39       	ld.w	r9,r9[0xc]
800042c6:	93 2b       	st.w	r9[0x8],r11
800042c8:	97 39       	st.w	r11[0xc],r9
800042ca:	10 99       	mov	r9,r8
800042cc:	ec 08 09 08 	st.w	r6[r8],r8
800042d0:	a1 a9       	sbr	r9,0x0
800042d2:	8d 19       	st.w	r6[0x4],r9
800042d4:	58 0c       	cp.w	r12,0
800042d6:	c5 a1       	brne	8000438a <_free_r+0x182>
800042d8:	e0 48 01 ff 	cp.w	r8,511
800042dc:	e0 8b 00 13 	brhi	80004302 <_free_r+0xfa>
800042e0:	a3 98       	lsr	r8,0x3
800042e2:	f4 08 00 39 	add	r9,r10,r8<<0x3
800042e6:	72 2b       	ld.w	r11,r9[0x8]
800042e8:	8d 39       	st.w	r6[0xc],r9
800042ea:	8d 2b       	st.w	r6[0x8],r11
800042ec:	97 36       	st.w	r11[0xc],r6
800042ee:	93 26       	st.w	r9[0x8],r6
800042f0:	a3 48       	asr	r8,0x2
800042f2:	74 19       	ld.w	r9,r10[0x4]
800042f4:	30 1b       	mov	r11,1
800042f6:	f6 08 09 48 	lsl	r8,r11,r8
800042fa:	f3 e8 10 08 	or	r8,r9,r8
800042fe:	95 18       	st.w	r10[0x4],r8
80004300:	c4 58       	rjmp	8000438a <_free_r+0x182>
80004302:	f0 0b 16 09 	lsr	r11,r8,0x9
80004306:	58 4b       	cp.w	r11,4
80004308:	e0 8b 00 06 	brhi	80004314 <_free_r+0x10c>
8000430c:	f0 0b 16 06 	lsr	r11,r8,0x6
80004310:	2c 8b       	sub	r11,-56
80004312:	c2 08       	rjmp	80004352 <_free_r+0x14a>
80004314:	59 4b       	cp.w	r11,20
80004316:	e0 8b 00 04 	brhi	8000431e <_free_r+0x116>
8000431a:	2a 5b       	sub	r11,-91
8000431c:	c1 b8       	rjmp	80004352 <_free_r+0x14a>
8000431e:	e0 4b 00 54 	cp.w	r11,84
80004322:	e0 8b 00 06 	brhi	8000432e <_free_r+0x126>
80004326:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000432a:	29 2b       	sub	r11,-110
8000432c:	c1 38       	rjmp	80004352 <_free_r+0x14a>
8000432e:	e0 4b 01 54 	cp.w	r11,340
80004332:	e0 8b 00 06 	brhi	8000433e <_free_r+0x136>
80004336:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000433a:	28 9b       	sub	r11,-119
8000433c:	c0 b8       	rjmp	80004352 <_free_r+0x14a>
8000433e:	e0 4b 05 54 	cp.w	r11,1364
80004342:	e0 88 00 05 	brls	8000434c <_free_r+0x144>
80004346:	37 eb       	mov	r11,126
80004348:	c0 58       	rjmp	80004352 <_free_r+0x14a>
8000434a:	d7 03       	nop
8000434c:	f0 0b 16 12 	lsr	r11,r8,0x12
80004350:	28 4b       	sub	r11,-124
80004352:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80004356:	78 29       	ld.w	r9,r12[0x8]
80004358:	18 39       	cp.w	r9,r12
8000435a:	c0 e1       	brne	80004376 <_free_r+0x16e>
8000435c:	74 18       	ld.w	r8,r10[0x4]
8000435e:	a3 4b       	asr	r11,0x2
80004360:	30 1c       	mov	r12,1
80004362:	f8 0b 09 4b 	lsl	r11,r12,r11
80004366:	f1 eb 10 0b 	or	r11,r8,r11
8000436a:	12 98       	mov	r8,r9
8000436c:	95 1b       	st.w	r10[0x4],r11
8000436e:	c0 a8       	rjmp	80004382 <_free_r+0x17a>
80004370:	72 29       	ld.w	r9,r9[0x8]
80004372:	18 39       	cp.w	r9,r12
80004374:	c0 60       	breq	80004380 <_free_r+0x178>
80004376:	72 1a       	ld.w	r10,r9[0x4]
80004378:	e0 1a ff fc 	andl	r10,0xfffc
8000437c:	14 38       	cp.w	r8,r10
8000437e:	cf 93       	brcs	80004370 <_free_r+0x168>
80004380:	72 38       	ld.w	r8,r9[0xc]
80004382:	8d 38       	st.w	r6[0xc],r8
80004384:	8d 29       	st.w	r6[0x8],r9
80004386:	93 36       	st.w	r9[0xc],r6
80004388:	91 26       	st.w	r8[0x8],r6
8000438a:	0e 9c       	mov	r12,r7
8000438c:	fe b0 f4 d6 	rcall	80002d38 <__malloc_unlock>
80004390:	d8 22       	popm	r4-r7,pc
80004392:	d7 03       	nop

80004394 <__do_global_ctors_aux>:
80004394:	d4 21       	pushm	r4-r7,lr
80004396:	30 c7       	mov	r7,12
80004398:	c0 28       	rjmp	8000439c <__do_global_ctors_aux+0x8>
8000439a:	5d 18       	icall	r8
8000439c:	20 47       	sub	r7,4
8000439e:	6e 08       	ld.w	r8,r7[0x0]
800043a0:	5b f8       	cp.w	r8,-1
800043a2:	cf c1       	brne	8000439a <__do_global_ctors_aux+0x6>
800043a4:	d8 22       	popm	r4-r7,pc
800043a6:	d7 03       	nop

Disassembly of section .exception:

80004400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80004400:	c0 08       	rjmp	80004400 <_evba>
	...

80004404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80004404:	c0 08       	rjmp	80004404 <_handle_TLB_Multiple_Hit>
	...

80004408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80004408:	c0 08       	rjmp	80004408 <_handle_Bus_Error_Data_Fetch>
	...

8000440c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000440c:	c0 08       	rjmp	8000440c <_handle_Bus_Error_Instruction_Fetch>
	...

80004410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80004410:	c0 08       	rjmp	80004410 <_handle_NMI>
	...

80004414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80004414:	c0 08       	rjmp	80004414 <_handle_Instruction_Address>
	...

80004418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80004418:	c0 08       	rjmp	80004418 <_handle_ITLB_Protection>
	...

8000441c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000441c:	c0 08       	rjmp	8000441c <_handle_Breakpoint>
	...

80004420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80004420:	c0 08       	rjmp	80004420 <_handle_Illegal_Opcode>
	...

80004424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80004424:	c0 08       	rjmp	80004424 <_handle_Unimplemented_Instruction>
	...

80004428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80004428:	c0 08       	rjmp	80004428 <_handle_Privilege_Violation>
	...

8000442c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
8000442c:	c0 08       	rjmp	8000442c <_handle_Floating_Point>
	...

80004430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80004430:	c0 08       	rjmp	80004430 <_handle_Coprocessor_Absent>
	...

80004434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80004434:	c0 08       	rjmp	80004434 <_handle_Data_Address_Read>
	...

80004438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80004438:	c0 08       	rjmp	80004438 <_handle_Data_Address_Write>
	...

8000443c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000443c:	c0 08       	rjmp	8000443c <_handle_DTLB_Protection_Read>
	...

80004440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80004440:	c0 08       	rjmp	80004440 <_handle_DTLB_Protection_Write>
	...

80004444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80004444:	c0 08       	rjmp	80004444 <_handle_DTLB_Modified>
	...

80004450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80004450:	c0 08       	rjmp	80004450 <_handle_ITLB_Miss>
	...

80004460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80004460:	c0 08       	rjmp	80004460 <_handle_DTLB_Miss_Read>
	...

80004470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80004470:	c0 08       	rjmp	80004470 <_handle_DTLB_Miss_Write>
	...

80004500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80004500:	fe cf 18 8c 	sub	pc,pc,6284

80004504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80004504:	30 0c       	mov	r12,0
80004506:	fe b0 f1 5b 	rcall	800027bc <_get_interrupt_handler>
8000450a:	58 0c       	cp.w	r12,0
8000450c:	f8 0f 17 10 	movne	pc,r12
80004510:	d6 03       	rete

80004512 <_int1>:
80004512:	30 1c       	mov	r12,1
80004514:	fe b0 f1 54 	rcall	800027bc <_get_interrupt_handler>
80004518:	58 0c       	cp.w	r12,0
8000451a:	f8 0f 17 10 	movne	pc,r12
8000451e:	d6 03       	rete

80004520 <_int2>:
80004520:	30 2c       	mov	r12,2
80004522:	fe b0 f1 4d 	rcall	800027bc <_get_interrupt_handler>
80004526:	58 0c       	cp.w	r12,0
80004528:	f8 0f 17 10 	movne	pc,r12
8000452c:	d6 03       	rete

8000452e <_int3>:
8000452e:	30 3c       	mov	r12,3
80004530:	fe b0 f1 46 	rcall	800027bc <_get_interrupt_handler>
80004534:	58 0c       	cp.w	r12,0
80004536:	f8 0f 17 10 	movne	pc,r12
8000453a:	d6 03       	rete
8000453c:	d7 03       	nop
8000453e:	d7 03       	nop
80004540:	d7 03       	nop
80004542:	d7 03       	nop
80004544:	d7 03       	nop
80004546:	d7 03       	nop
80004548:	d7 03       	nop
8000454a:	d7 03       	nop
8000454c:	d7 03       	nop
8000454e:	d7 03       	nop
80004550:	d7 03       	nop
80004552:	d7 03       	nop
80004554:	d7 03       	nop
80004556:	d7 03       	nop
80004558:	d7 03       	nop
8000455a:	d7 03       	nop
8000455c:	d7 03       	nop
8000455e:	d7 03       	nop
80004560:	d7 03       	nop
80004562:	d7 03       	nop
80004564:	d7 03       	nop
80004566:	d7 03       	nop
80004568:	d7 03       	nop
8000456a:	d7 03       	nop
8000456c:	d7 03       	nop
8000456e:	d7 03       	nop
80004570:	d7 03       	nop
80004572:	d7 03       	nop
80004574:	d7 03       	nop
80004576:	d7 03       	nop
80004578:	d7 03       	nop
8000457a:	d7 03       	nop
8000457c:	d7 03       	nop
8000457e:	d7 03       	nop
80004580:	d7 03       	nop
80004582:	d7 03       	nop
80004584:	d7 03       	nop
80004586:	d7 03       	nop
80004588:	d7 03       	nop
8000458a:	d7 03       	nop
8000458c:	d7 03       	nop
8000458e:	d7 03       	nop
80004590:	d7 03       	nop
80004592:	d7 03       	nop
80004594:	d7 03       	nop
80004596:	d7 03       	nop
80004598:	d7 03       	nop
8000459a:	d7 03       	nop
8000459c:	d7 03       	nop
8000459e:	d7 03       	nop
800045a0:	d7 03       	nop
800045a2:	d7 03       	nop
800045a4:	d7 03       	nop
800045a6:	d7 03       	nop
800045a8:	d7 03       	nop
800045aa:	d7 03       	nop
800045ac:	d7 03       	nop
800045ae:	d7 03       	nop
800045b0:	d7 03       	nop
800045b2:	d7 03       	nop
800045b4:	d7 03       	nop
800045b6:	d7 03       	nop
800045b8:	d7 03       	nop
800045ba:	d7 03       	nop
800045bc:	d7 03       	nop
800045be:	d7 03       	nop
800045c0:	d7 03       	nop
800045c2:	d7 03       	nop
800045c4:	d7 03       	nop
800045c6:	d7 03       	nop
800045c8:	d7 03       	nop
800045ca:	d7 03       	nop
800045cc:	d7 03       	nop
800045ce:	d7 03       	nop
800045d0:	d7 03       	nop
800045d2:	d7 03       	nop
800045d4:	d7 03       	nop
800045d6:	d7 03       	nop
800045d8:	d7 03       	nop
800045da:	d7 03       	nop
800045dc:	d7 03       	nop
800045de:	d7 03       	nop
800045e0:	d7 03       	nop
800045e2:	d7 03       	nop
800045e4:	d7 03       	nop
800045e6:	d7 03       	nop
800045e8:	d7 03       	nop
800045ea:	d7 03       	nop
800045ec:	d7 03       	nop
800045ee:	d7 03       	nop
800045f0:	d7 03       	nop
800045f2:	d7 03       	nop
800045f4:	d7 03       	nop
800045f6:	d7 03       	nop
800045f8:	d7 03       	nop
800045fa:	d7 03       	nop
800045fc:	d7 03       	nop
800045fe:	d7 03       	nop

Disassembly of section .fini:

80004600 <_fini>:
80004600:	eb cd 40 40 	pushm	r6,lr
80004604:	48 26       	lddpc	r6,8000460c <_fini+0xc>
80004606:	1e 26       	rsub	r6,pc
80004608:	c0 48       	rjmp	80004610 <_fini+0x10>
8000460a:	d7 03       	nop
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	45 ea       	lddsp	r10,sp[0x178]
80004610:	fe b0 ed 3c 	rcall	80002088 <__do_global_dtors_aux>
80004614:	e3 cd 80 40 	ldm	sp++,r6,pc
